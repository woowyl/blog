{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/concise/source/css/app.less","path":"css/app.less","modified":1,"renderable":1},{"_id":"themes/concise/source/css/archive.less","path":"css/archive.less","modified":1,"renderable":1},{"_id":"themes/concise/source/css/article.less","path":"css/article.less","modified":1,"renderable":1},{"_id":"themes/concise/source/css/aside.css","path":"css/aside.css","modified":1,"renderable":1},{"_id":"themes/concise/source/css/aside.less","path":"css/aside.less","modified":1,"renderable":1},{"_id":"themes/concise/source/css/category.less","path":"css/category.less","modified":1,"renderable":1},{"_id":"themes/concise/source/css/comments.less","path":"css/comments.less","modified":1,"renderable":1},{"_id":"themes/concise/source/css/footer.less","path":"css/footer.less","modified":1,"renderable":1},{"_id":"themes/concise/source/css/icons.less","path":"css/icons.less","modified":1,"renderable":1},{"_id":"themes/concise/source/css/markdown.css","path":"css/markdown.css","modified":1,"renderable":1},{"_id":"themes/concise/source/css/markdown.less","path":"css/markdown.less","modified":1,"renderable":1},{"_id":"themes/concise/source/css/mixin.less","path":"css/mixin.less","modified":1,"renderable":1},{"_id":"themes/concise/source/css/monokai-sublime.less","path":"css/monokai-sublime.less","modified":1,"renderable":1},{"_id":"themes/concise/source/css/nav.less","path":"css/nav.less","modified":1,"renderable":1},{"_id":"themes/concise/source/css/page.less","path":"css/page.less","modified":1,"renderable":1},{"_id":"themes/concise/source/css/reset.less","path":"css/reset.less","modified":1,"renderable":1},{"_id":"themes/concise/source/css/style.less","path":"css/style.less","modified":1,"renderable":1},{"_id":"themes/concise/source/css/tags.less","path":"css/tags.less","modified":1,"renderable":1},{"_id":"themes/concise/source/css/vars.less","path":"css/vars.less","modified":1,"renderable":1},{"_id":"themes/concise/source/css/widget.less","path":"css/widget.less","modified":1,"renderable":1},{"_id":"themes/concise/source/images/favicon.ico","path":"images/favicon.ico","modified":1,"renderable":1},{"_id":"themes/concise/source/fonts/icomoon.eot","path":"fonts/icomoon.eot","modified":1,"renderable":1},{"_id":"themes/concise/source/fonts/icomoon.svg","path":"fonts/icomoon.svg","modified":1,"renderable":1},{"_id":"themes/concise/source/fonts/icomoon.ttf","path":"fonts/icomoon.ttf","modified":1,"renderable":1},{"_id":"themes/concise/source/fonts/icomoon.woff","path":"fonts/icomoon.woff","modified":1,"renderable":1},{"_id":"themes/concise/source/js/scrollspy.min.js","path":"js/scrollspy.min.js","modified":1,"renderable":1},{"_id":"themes/concise/source/svg/github.svg","path":"svg/github.svg","modified":1,"renderable":1},{"_id":"themes/concise/source/svg/more.svg","path":"svg/more.svg","modified":1,"renderable":1},{"_id":"themes/concise/source/svg/twitter.svg","path":"svg/twitter.svg","modified":1,"renderable":1},{"_id":"themes/concise/source/svg/weibo.svg","path":"svg/weibo.svg","modified":1,"renderable":1},{"_id":"themes/concise/source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"330eb9aa056345f9fa921250b104af352fe4b7d5","modified":1599038817481},{"_id":"themes/concise/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1599038817492},{"_id":"themes/concise/README.md","hash":"b03c8fd76a7391d2d570e6a4b5b74f86b941658a","modified":1599038817493},{"_id":"themes/concise/_config.example.yml","hash":"e76ce037a58e93924e42cbd2e8e68bbe14f2e345","modified":1599038817493},{"_id":"themes/concise/_config.yml","hash":"e1b1b626efdfc6dcefa229d0d1c3a42e4be72e5c","modified":1599038817493},{"_id":"source/.DS_Store","hash":"0bedfba3e896c6314058eee34df9067056142fe2","modified":1615170721283},{"_id":"source/_posts/.DS_Store","hash":"c7ff8b069a95f40a83e6af6356ff2276c7fff4e3","modified":1615170852243},{"_id":"source/_posts/hello-world.md","hash":"6886ae0279b65cccfa63cc97a2e9b01e53c88da9","modified":1615179927620},{"_id":"source/about/index.md","hash":"be19da9b9b7f860ceb19fba7df4909d0db1fd878","modified":1599038817491},{"_id":"source/tags/index.md","hash":"138d1dc7ba8f3ee36ffa6cec3d2500f86830670e","modified":1599038817492},{"_id":"themes/concise/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1599038817493},{"_id":"themes/concise/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1599038817493},{"_id":"themes/concise/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1599038817493},{"_id":"themes/concise/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1599038817494},{"_id":"themes/concise/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1599038817494},{"_id":"themes/concise/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1599038817494},{"_id":"themes/concise/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1599038817494},{"_id":"themes/concise/layout/archive.ejs","hash":"20a4f9193abdaf8b3ee0e7191f055d075d91e87c","modified":1599038817496},{"_id":"themes/concise/layout/categories.ejs","hash":"1a302302df07dcb13b92992580c2661de5d3baf0","modified":1599038817496},{"_id":"themes/concise/layout/category.ejs","hash":"e29542322fe798281a40eed476468aa8afba7d50","modified":1599038817497},{"_id":"themes/concise/layout/index.ejs","hash":"e29542322fe798281a40eed476468aa8afba7d50","modified":1599038817497},{"_id":"themes/concise/layout/layout.ejs","hash":"d559ed7f6ee8dcaf0eb2230a64cfb1c62820990d","modified":1599038817497},{"_id":"themes/concise/layout/page.ejs","hash":"576ae239f3aa9cda0aede19e9a7ff13e92fed13c","modified":1599038817497},{"_id":"themes/concise/layout/post.ejs","hash":"d948161b862e2e2956f4e940ff3668cdebf1e1b2","modified":1599038817497},{"_id":"themes/concise/layout/tag.ejs","hash":"0ef29619219277632a221155e51a85673011e248","modified":1599038817497},{"_id":"themes/concise/layout/tags.ejs","hash":"8b3a6ad1d789addeb628ad7a7d5ffc8a4b764bb3","modified":1599038817497},{"_id":"themes/concise/scripts/include.js","hash":"3fd0947904a06209d1f58e97efe77d06abbabcb5","modified":1599038817498},{"_id":"source/_posts/back-end/nginx.md","hash":"1e0d6f1bb6d9fc04eeb14fc3874e34106224dd7e","modified":1615181154217},{"_id":"source/_posts/daily/2020-04-16-bit.md","hash":"03435d8a0bd23421b9b1f0c038826b0d9ce53860","modified":1615174450741},{"_id":"source/_posts/font-end/.DS_Store","hash":"370950b206546d49869cb54d2119ce051fa67f9f","modified":1615170852242},{"_id":"source/_posts/language/IEEE754.md","hash":"269a4685e101925523cc7ce34d2e5034f507050d","modified":1615181987287},{"_id":"source/_posts/language/charset.md","hash":"2990174a06c600ced06162099ffbaba7751560af","modified":1615174183706},{"_id":"source/_posts/language/program_language.md","hash":"7da25eb1023f4935fac00f319df9d2c6d0ecceba","modified":1615174106555},{"_id":"themes/concise/layout/_partial/archive.ejs","hash":"67891e427712e39d73058f3001eabd8758dd0bbf","modified":1599038817495},{"_id":"themes/concise/layout/_partial/article.ejs","hash":"40cff2943bda22e0ad6ffc5b4a24917d1a797bea","modified":1599038817495},{"_id":"themes/concise/layout/_partial/articles.ejs","hash":"3ca4869df35f85c39997a99ea32b3366e02de34a","modified":1599038817495},{"_id":"themes/concise/layout/_partial/aside.ejs","hash":"4131ae3397adc56859798339790a5dccbb262298","modified":1599038817495},{"_id":"themes/concise/layout/_partial/comments.ejs","hash":"1585a780494dafed3718574d985cbb4aea315aaf","modified":1599038817495},{"_id":"themes/concise/layout/_partial/footer.ejs","hash":"448dba8ce42c6446a28a93c197e49b1d4fee357f","modified":1599038817496},{"_id":"themes/concise/layout/_partial/header.ejs","hash":"740d7291b058f99626f6fca568a1b92c092079f2","modified":1599038817496},{"_id":"themes/concise/layout/_partial/nav.ejs","hash":"c87ed02859a3e826dfc990af7e9a0564958a2c1c","modified":1599038817496},{"_id":"themes/concise/source/css/app.less","hash":"a8bfa3a9e5e74d39432226adcf433da07a4e60f9","modified":1599038817498},{"_id":"themes/concise/source/css/archive.less","hash":"076c2ac3988547fd857544aff3f60e544961d2dd","modified":1599038817498},{"_id":"themes/concise/source/css/article.less","hash":"3ed8ddf7df23032e901e86c4435c59504f476161","modified":1599038817498},{"_id":"themes/concise/source/css/aside.css","hash":"c44cab3a442add8ccc8e6cbccf8e0c8663236a2f","modified":1599038817499},{"_id":"themes/concise/source/css/aside.less","hash":"4a35b2441e82bbe4a83e8527e9ba4f97217f4081","modified":1599038817499},{"_id":"themes/concise/source/css/category.less","hash":"30fbaf3cc326b6d1068e3fb4f5ece7c97de6b00c","modified":1599038817499},{"_id":"themes/concise/source/css/comments.less","hash":"1f9e8a30adaaf373d714394988036ec88707a6cd","modified":1599038817499},{"_id":"themes/concise/source/css/footer.less","hash":"4c28c726f272590bc681a404fb54ca9e5ca0145e","modified":1599038817499},{"_id":"themes/concise/source/css/icons.less","hash":"f055a61fa6971272efc7ecea708f229d99a2cf58","modified":1599038817499},{"_id":"themes/concise/source/css/markdown.css","hash":"f6300abe3b2435cd9dbb750345d64e5c6b2f0e32","modified":1615181471010},{"_id":"themes/concise/source/css/markdown.less","hash":"b10288aa6822fff51765e7f8fa03ed2f82bd13e8","modified":1599038817500},{"_id":"themes/concise/source/css/mixin.less","hash":"96f224ac301293c97dd313da67ca727c8ff17837","modified":1599038817500},{"_id":"themes/concise/source/css/monokai-sublime.less","hash":"e655d22dbb9f09179d306c5840b7ffaac69dd41e","modified":1599038817500},{"_id":"themes/concise/source/css/nav.less","hash":"c237fbc4dedf5a385d020a8d785549b28f69afde","modified":1599038817500},{"_id":"themes/concise/source/css/page.less","hash":"2c10c522627d8a486ab8a7ad91614a5a3a2b0c66","modified":1599038817501},{"_id":"themes/concise/source/css/reset.less","hash":"b72f89888fce30fb24ecd61c82827eff5c4d970e","modified":1599038817501},{"_id":"themes/concise/source/css/style.less","hash":"1cb267913e61225328507e9bf4a4645e6060d866","modified":1599038817501},{"_id":"themes/concise/source/css/tags.less","hash":"9e32cc862df2baec3aeec85a325ec0ba6d8a81b4","modified":1599038817501},{"_id":"themes/concise/source/css/vars.less","hash":"33875f71421caf72d8a86a7dbc011fb64eb7e475","modified":1599038817501},{"_id":"themes/concise/source/css/widget.less","hash":"8373c2246dfb0261278003f1985a53707494e0b9","modified":1599038817501},{"_id":"themes/concise/source/images/favicon.ico","hash":"491d07d9a67349261e4daccd4d2c18a9ebcd71c3","modified":1599038817503},{"_id":"themes/concise/source/fonts/icomoon.eot","hash":"8300564edcd12262c6b8b97ba225bc00b72f5984","modified":1599038817501},{"_id":"themes/concise/source/fonts/icomoon.svg","hash":"53a7893b9b630440f7381b156d3b7c9566c47523","modified":1599038817502},{"_id":"themes/concise/source/fonts/icomoon.ttf","hash":"6b577c657ccb5de7c321e51942a52922a4e95ec1","modified":1599038817502},{"_id":"themes/concise/source/fonts/icomoon.woff","hash":"5a3b86fa1122f78d9b285fbd390bf142721c51ed","modified":1599038817502},{"_id":"themes/concise/source/js/scrollspy.min.js","hash":"076f7db44c3a05147144f736cae159baf1612f72","modified":1599038817503},{"_id":"themes/concise/source/svg/github.svg","hash":"f2355900fe0ec5ed2f4e6d4cb271bda5feb90f06","modified":1599038817503},{"_id":"themes/concise/source/svg/more.svg","hash":"d4aa97cd29baaaac750a60ce6e7b6b00fc573101","modified":1599038817503},{"_id":"themes/concise/source/svg/twitter.svg","hash":"05ad5df10a4495e85ae417e241186e5205af930d","modified":1599038817503},{"_id":"themes/concise/source/svg/weibo.svg","hash":"af69ed38f353ebcf22a059cf6cf029dcfc2aee1a","modified":1599038817504},{"_id":"themes/concise/source/images/avatar.jpg","hash":"ec460a2d789b9bba4db99a359b483dc899ad5790","modified":1599038817502},{"_id":"source/_posts/daily/paper/paper-search.md","hash":"51b0999ad21a3d0901ab31e96d7677fb18da09b6","modified":1615174695908},{"_id":"source/_posts/daily/paper/.DS_Store","hash":"dcc7fc2cdbe3aea18afa2bc9553a2863c32467ed","modified":1615170810315},{"_id":"source/_posts/daily/paper/paper-tool.md","hash":"a98f3b0c3e7f7f77684094259ebe820e186382db","modified":1599038817486},{"_id":"source/_posts/font-end/2019/flex_layout.md","hash":"0639a0d9e49553a4460c0dee2196c740b19f3eff","modified":1615181720268},{"_id":"source/_posts/font-end/2019/js_type.md","hash":"7935b474fbe4023e71d7b2510369d86535456a85","modified":1615181512903},{"_id":"source/_posts/font-end/2019/map_set.md","hash":"0fb1465223716c33c7a2009add80b23ecfcf48f7","modified":1615174446492},{"_id":"source/_posts/language/bash-zsh-shell/bash-zsh-shell.md","hash":"8b836762e737c3dffc4e6f2c9cf5c92d881436a7","modified":1615174211262},{"_id":"source/_posts/language/how_to_add_cli/how_to_add_cli.md","hash":"25f106af2f0ba64f8766b73c00657db056ac1840","modified":1615174127906},{"_id":"themes/concise/layout/_partial/post/date.ejs","hash":"b3bae800ec3a8bcf7e419fbb6d50f8db4b76118a","modified":1599038817496},{"_id":"themes/concise/layout/_partial/post/tags.ejs","hash":"24abef606b55a9dda97dca79bb8ab46968919423","modified":1599038817496},{"_id":"source/_posts/daily/2020-04-16-bit/bbjy.png","hash":"dd27ca8212b3d6be79015740ba7f98c47a2b5d33","modified":1599038817482},{"_id":"source/_posts/daily/2020-04-16-bit/deal.jpeg","hash":"e10374b3db0ec69c03c3478be900d99d3b0e8216","modified":1599038817484},{"_id":"source/_posts/daily/paper/paper-search/fudan_data.png","hash":"3d0b25c38956d53149e65ef2570f2df5e20f4477","modified":1599038817486},{"_id":"source/_posts/language/program_language/translate.png","hash":"d295691c21ffa04c3255d919302e5fa8ffdd4b43","modified":1599038817491},{"_id":"source/_posts/language/program_language/machine_language.png","hash":"eeb2e1175669ed088c736fb971ec6153b40fb60b","modified":1599038817489},{"_id":"public/about/index.html","hash":"975f1e2cd856076e4025f4c1cef894b49a87e7ba","modified":1615181998239},{"_id":"public/tags/index.html","hash":"09f02c95412d00e938bce2038903a8ed9c5cf279","modified":1615181998239},{"_id":"public/2020/09/02/language/how_to_add_cli/how_to_add_cli/index.html","hash":"ed53cec84b1c8ad7a38f191d6eb706649ef0b968","modified":1615181998239},{"_id":"public/2020/05/10/daily/paper/paper-tool/index.html","hash":"6551f082f2977a8e0fddb1acdff6ef6dd4884800","modified":1615181998239},{"_id":"public/2020/05/09/daily/paper/paper-search/index.html","hash":"097fdea60c572b4a6405852f61e3727f34aca937","modified":1615181998239},{"_id":"public/2020/04/16/daily/2020-04-16-bit/index.html","hash":"75ebd7381c6a2fe96c3489331c8e2e5c0f3750d4","modified":1615181998239},{"_id":"public/2019/03/03/font-end/2019/flex_layout/index.html","hash":"776777288694a233ef0d1c181bf18ad379345523","modified":1615181998239},{"_id":"public/2016/07/01/back-end/nginx/index.html","hash":"e359d6ef4d0bae4b00b9d772ddbbc14a6d893fb3","modified":1615181998239},{"_id":"public/archives/page/2/index.html","hash":"80edf5571d708176b52376ea65515ae6ade69c30","modified":1615181998239},{"_id":"public/archives/2016/index.html","hash":"c0f49c852da7e449f13d47d292f39b34e368d49f","modified":1615181998239},{"_id":"public/archives/2016/07/index.html","hash":"a9f0e53355b27d104fc2d9940ca7bdc6fa8d1d9e","modified":1615181998239},{"_id":"public/archives/2016/09/index.html","hash":"dd7667985b3422bc66de159b0d6bc0e32cb96d44","modified":1615181998239},{"_id":"public/archives/2019/index.html","hash":"4f9db195e8a558847b46b3190b88938bcff5d919","modified":1615181998239},{"_id":"public/archives/2019/03/index.html","hash":"a6efd9016f3b9149fecb3e8fbd7acf930095724b","modified":1615181998239},{"_id":"public/archives/2019/09/index.html","hash":"e4b87205b525f7291936618da669246f344c9bc1","modified":1615181998239},{"_id":"public/archives/2019/10/index.html","hash":"2f5bf43bc99c1da72b52aa6a1b4409bd484111dc","modified":1615181998239},{"_id":"public/archives/2020/index.html","hash":"2bd6b513f2b0f03f661c3eb48d4f9583be294e39","modified":1615181998239},{"_id":"public/archives/2020/04/index.html","hash":"f4a18de4379a966a0d402225698c7fb62dba6059","modified":1615181998239},{"_id":"public/archives/2020/05/index.html","hash":"b8d861412f064e385a5c8724aca176a4d4a0726f","modified":1615181998239},{"_id":"public/archives/2020/09/index.html","hash":"671b2e93e1a5da01a13c56d022555e8c143ecd62","modified":1615181998239},{"_id":"public/archives/2021/index.html","hash":"a5349fbcb5984a03be62b939bfbca94e38358377","modified":1615181998239},{"_id":"public/archives/2021/01/index.html","hash":"05c64523b7f5aa198adff72d6ecace86eaceb7d6","modified":1615181998239},{"_id":"public/categories/back-end/index.html","hash":"80f4459fb641a1a4f3da2e6a380ac177da400fa4","modified":1615181998239},{"_id":"public/categories/paper/index.html","hash":"053aacaf932e0a2615f82994d8770055a875f1a6","modified":1615181998239},{"_id":"public/page/2/index.html","hash":"933ada519bcfcb9fa38f7c2fe6c35538bb1155dc","modified":1615181998239},{"_id":"public/tags/hexo/index.html","hash":"0e0606d166a408aeec204cabf61392d8ba7fedaf","modified":1615181998239},{"_id":"public/tags/理财/index.html","hash":"1c8ada7f92e008ffaf3209a0bebfced095baedf4","modified":1615181998239},{"_id":"public/tags/比特币/index.html","hash":"c4e8ad907b89794eff1d6bbbb88719105728d539","modified":1615181998239},{"_id":"public/tags/火币/index.html","hash":"b84860481ace3820b18e634e3be2a362e6916675","modified":1615181998239},{"_id":"public/tags/计算机通识/index.html","hash":"5872cee9d2b5f8e2de810db75275d988493cc701","modified":1615181998239},{"_id":"public/tags/服务器配置/index.html","hash":"4abe6eb3594266cee1b9758c2eb965d1276b9a0a","modified":1615181998239},{"_id":"public/tags/nginx/index.html","hash":"7363c431ac0126113e9527053bae2b334ac477e7","modified":1615181998239},{"_id":"public/tags/paper/index.html","hash":"afb0f08475c5d1fb932beab3fcefd4c262bafd8e","modified":1615181998239},{"_id":"public/tags/前端智能化/index.html","hash":"37266b3c0539316fc0f414483120539fc572fccd","modified":1615181998239},{"_id":"public/tags/前端/index.html","hash":"cda8e2852e1d8a19d9d1993c3b624690d1fdc57a","modified":1615181998239},{"_id":"public/tags/布局/index.html","hash":"473a4067029273e18dfe03e6e6d67775fe9a0734","modified":1615181998239},{"_id":"public/tags/效率/index.html","hash":"4f3973f51722c987c2b681bb6547108e5e3d2852","modified":1615181998239},{"_id":"public/tags/前端-数据结构/index.html","hash":"1770baf747192f885da413ae049244c1bd336ed2","modified":1615181998239},{"_id":"public/2021/01/05/language/IEEE754/index.html","hash":"6d54b7358025d26cee7e954ff0236b20f2059e07","modified":1615181998239},{"_id":"public/2020/09/01/language/bash-zsh-shell/bash-zsh-shell/index.html","hash":"be6c426dbcd37d533cd39c6751cbaafabd70abdb","modified":1615181998239},{"_id":"public/2020/04/21/language/program_language/index.html","hash":"6c1d9db59a092e856b9078f20454f5ee01cee3ae","modified":1615181998239},{"_id":"public/2020/04/21/language/charset/index.html","hash":"213eb14c93e52d9b715692171704c1e301915e29","modified":1615181998239},{"_id":"public/2019/10/23/font-end/2019/js_type/index.html","hash":"633b36e0da4f10601f2b9734cd150e43b55ebbb4","modified":1615181998239},{"_id":"public/2019/09/21/font-end/2019/map_set/index.html","hash":"b814b5e45527400a8e933391f235ef8a18f36986","modified":1615181998239},{"_id":"public/2016/09/21/hello-world/index.html","hash":"49b57ebf143a32ea28ca0b0f0daa29bf201d5b92","modified":1615181998239},{"_id":"public/archives/index.html","hash":"68c2a168eb5868e6eb138810c227c2d9b31c2a90","modified":1615181998239},{"_id":"public/categories/front-end/index.html","hash":"a1a466a04163317b53192753db351a4abb10d1fd","modified":1615181998239},{"_id":"public/categories/language/index.html","hash":"ca653e9fd8616e499e2a498cd1ad6cac510c1d4a","modified":1615181998239},{"_id":"public/index.html","hash":"fad3b086f0811c0703828678cefdc106cc93dab1","modified":1615181998239},{"_id":"public/CNAME","hash":"330eb9aa056345f9fa921250b104af352fe4b7d5","modified":1615181998239},{"_id":"public/images/favicon.ico","hash":"491d07d9a67349261e4daccd4d2c18a9ebcd71c3","modified":1615181998239},{"_id":"public/fonts/icomoon.svg","hash":"53a7893b9b630440f7381b156d3b7c9566c47523","modified":1615181998239},{"_id":"public/fonts/icomoon.eot","hash":"8300564edcd12262c6b8b97ba225bc00b72f5984","modified":1615181998239},{"_id":"public/fonts/icomoon.ttf","hash":"6b577c657ccb5de7c321e51942a52922a4e95ec1","modified":1615181998239},{"_id":"public/fonts/icomoon.woff","hash":"5a3b86fa1122f78d9b285fbd390bf142721c51ed","modified":1615181998239},{"_id":"public/svg/github.svg","hash":"f2355900fe0ec5ed2f4e6d4cb271bda5feb90f06","modified":1615181998239},{"_id":"public/svg/more.svg","hash":"d4aa97cd29baaaac750a60ce6e7b6b00fc573101","modified":1615181998239},{"_id":"public/svg/twitter.svg","hash":"05ad5df10a4495e85ae417e241186e5205af930d","modified":1615181998239},{"_id":"public/svg/weibo.svg","hash":"af69ed38f353ebcf22a059cf6cf029dcfc2aee1a","modified":1615181998239},{"_id":"public/images/avatar.jpg","hash":"ec460a2d789b9bba4db99a359b483dc899ad5790","modified":1615181998239},{"_id":"public/2020/04/16/daily/2020-04-16-bit/bbjy.png","hash":"dd27ca8212b3d6be79015740ba7f98c47a2b5d33","modified":1615181998239},{"_id":"public/js/scrollspy.min.js","hash":"076f7db44c3a05147144f736cae159baf1612f72","modified":1615181998239},{"_id":"public/css/comments.css","hash":"2062c75b2efb9ea2e02a78a4f8b747818069350b","modified":1615181998239},{"_id":"public/css/icons.css","hash":"f6f65380db33567cc61afada447f2df642308f13","modified":1615181998239},{"_id":"public/css/markdown.css","hash":"a4e3f0c4fbee1de1f3f9d7e07f52983c927fde99","modified":1615181998239},{"_id":"public/css/mixin.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1615181998239},{"_id":"public/css/vars.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1615181998239},{"_id":"public/css/monokai-sublime.css","hash":"7aa6de22e305c9195f555dab91f52aa3c6364383","modified":1615181998239},{"_id":"public/2020/04/16/daily/2020-04-16-bit/deal.jpeg","hash":"e10374b3db0ec69c03c3478be900d99d3b0e8216","modified":1615181998239},{"_id":"public/2020/05/09/daily/paper/paper-search/fudan_data.png","hash":"3d0b25c38956d53149e65ef2570f2df5e20f4477","modified":1615181998239},{"_id":"public/2020/04/21/language/program_language/translate.png","hash":"d295691c21ffa04c3255d919302e5fa8ffdd4b43","modified":1615181998239},{"_id":"public/css/app.css","hash":"dd3be9525fdc90fc4fd8718be18b6c45168a2a2a","modified":1615181998239},{"_id":"public/css/aside.css","hash":"c44cab3a442add8ccc8e6cbccf8e0c8663236a2f","modified":1615181998239},{"_id":"public/css/archive.css","hash":"ff13ff5b6a2f3d793a58aadef53c57cb3016d530","modified":1615181998239},{"_id":"public/css/category.css","hash":"b6059959855d73fc8eac634939be5322927589b1","modified":1615181998239},{"_id":"public/css/article.css","hash":"ef84ebea409d1691459f20a4eb79389ae9fe71cd","modified":1615181998239},{"_id":"public/css/footer.css","hash":"9a6bff22188abf683f36d1409f0a10ded38c909e","modified":1615181998239},{"_id":"public/css/nav.css","hash":"36ee72a7ccefd42018ca965d5fe1d584bb5d961a","modified":1615181998239},{"_id":"public/css/page.css","hash":"60250269bdfb9422745ca465edefce74f08e7613","modified":1615181998239},{"_id":"public/css/reset.css","hash":"646902895a78120543446c735f9adc81beab92a6","modified":1615181998239},{"_id":"public/css/tags.css","hash":"6f1c8f8e345d60bf42c8240a8788bf5d5748a400","modified":1615181998239},{"_id":"public/css/widget.css","hash":"0becbaab3f03488d4bfe57d0f4c759592b241bc0","modified":1615181998239},{"_id":"public/2020/04/21/language/program_language/machine_language.png","hash":"eeb2e1175669ed088c736fb971ec6153b40fb60b","modified":1615181998239},{"_id":"public/css/style.css","hash":"1da7704eb9d8a9bc0728363c545a8be67f535261","modified":1615181998239}],"Category":[{"name":"front-end","_id":"ckm05nqde00032cl2f29w98a7"},{"name":"language","_id":"ckm05nqdv000b2cl24ewnb4xb"},{"name":"back-end","_id":"ckm05nqdz000f2cl231bo4x3p"},{"name":"paper","_id":"ckm05nqeg00112cl2haix65do"}],"Data":[],"Page":[{"title":"about","date":"2020-04-13T15:25:37.000Z","comments":0,"_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2020-04-13 23:25:37\ncomments: false\n---\n","updated":"2020-09-02T09:26:57.491Z","path":"about/index.html","layout":"page","_id":"ckm05nqda00012cl207a60r6t","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2020-04-13T15:23:35.000Z","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2020-04-13 23:23:35\nlayout: tags\n---\n","updated":"2020-09-02T09:26:57.492Z","path":"tags/index.html","comments":1,"_id":"ckm05nqdd00022cl27sib7ol4","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"通过hexo搭建个人博客","date":"2016-09-21T02:00:05.000Z","_content":"\n## 新建一个hexo博客\n\n### 安装hexo\n\n```bash\n$ npm install -g hexo\n```\n\n### 初始化\n\n```bash\n$ cd yourblogfold\n$ hexo init\n\n```\n<!-- more -->\n## 常用命令\n\n### 生成一个新文章\n\n``` bash\n\n// [layout] 为布局，可选项为 `post`、`page`、`draft`，这将决定文章所在文件路径。\n// <title> 为文章标题\n\n$ hexo new [] \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### 启动服务器\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### 生成静态文件\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### 部署\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n\n\n## 配合github page\n\n1. 在github新建一个仓库，仓库名必须为`<user-name>.github.io`。`user-name`是github的昵称。\n\n2. 修改 _config.yml 配置\n\n```bash\n    # Deployment\n    ## Docs: https://hexo.io/docs/deployment.html\n    deploy:\n        type: git\n        repo: <你的仓库地址> # https://github.com/<user-name>/<user-name>.github.io\n        branch: master\n```\n\n3. 部署代码\n\n``` bash\n$ hexo deploy\n```\n\n4. 查看效果\n\n## 更换主题\n\n```bash\n# 下载到themes文件夹下\n$ git clone https://github.com/KevinOfNeu/hexo-theme-yourtheme yourtheme\n\n# 修改 _config.yml 配置\n$ theme: yourtheme\n\n```\n\n## 绑定自己的域名\n\n1. 修改GitHub Pages中的Custom domain选择\n\n  > Setting=>  GitHub Pages => Custom domain\n\n2. 在`/source`下添加名为`CNAME`的文件，无后缀。将你自己的域名放入文件内\n\n```bash\n    www.<yoursite>.name\n```\n\n3. 添加域名解析\n\n在你的域名管理后台（eg:万网），修改你的域名解析记录。  \n添加两个A记录，用得到的IP，一个主机记录为：“www”，一个为“@”，这样通过[yoursitename].com和www.[yoursitename].com都能访问到你的博客了。\n\n详见(github官方配置文档)[https://help.github.com/en/github/working-with-github-pages/configuring-a-custom-domain-for-your-github-pages-site]\n\n## 添加https\n\n自 2018 年 5 月 1 日，Github 支持自定义域名的 HTTPS 请求了。\n\n配置也相当简单：\n\n1. 更新 DNS 配置里的 A 记录，将其指向以下4个 IP 地址中的至少一个。\n\n    - 185.199.108.153\n    - 185.199.109.153\n    - 185.199.110.153\n    - 185.199.111.153\n\n2. GiHub Pages仓库的设置里勾选 'Enforce HTTPS'。\n  \n  > Setting=>  GitHub Pages => Custom domain\n\n## 添加评论\n\n  可以使用gitalk插件，[传送门](https://github.com/gitalk/gitalk)。具体配置就不写在这里了。  \n  推荐已经集成好的主题，[concise](https://github.com/sanonz/hexo-theme-concise)\n\n## 最佳实践\n\n  - 路径名包括文章的文件名，最好不要用中文\n  - 丰富文档样式，除了基础的markdown语法外，还可以使用hexo自己的[语法](https://hexo.io/zh-cn/docs/tag-plugins.html)","source":"_posts/hello-world.md","raw":"---\ntitle: 通过hexo搭建个人博客\ntags: hexo\ndate: 2016-09-21 10:00:05\ncategories: front-end\n---\n\n## 新建一个hexo博客\n\n### 安装hexo\n\n```bash\n$ npm install -g hexo\n```\n\n### 初始化\n\n```bash\n$ cd yourblogfold\n$ hexo init\n\n```\n<!-- more -->\n## 常用命令\n\n### 生成一个新文章\n\n``` bash\n\n// [layout] 为布局，可选项为 `post`、`page`、`draft`，这将决定文章所在文件路径。\n// <title> 为文章标题\n\n$ hexo new [] \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### 启动服务器\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### 生成静态文件\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### 部署\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n\n\n## 配合github page\n\n1. 在github新建一个仓库，仓库名必须为`<user-name>.github.io`。`user-name`是github的昵称。\n\n2. 修改 _config.yml 配置\n\n```bash\n    # Deployment\n    ## Docs: https://hexo.io/docs/deployment.html\n    deploy:\n        type: git\n        repo: <你的仓库地址> # https://github.com/<user-name>/<user-name>.github.io\n        branch: master\n```\n\n3. 部署代码\n\n``` bash\n$ hexo deploy\n```\n\n4. 查看效果\n\n## 更换主题\n\n```bash\n# 下载到themes文件夹下\n$ git clone https://github.com/KevinOfNeu/hexo-theme-yourtheme yourtheme\n\n# 修改 _config.yml 配置\n$ theme: yourtheme\n\n```\n\n## 绑定自己的域名\n\n1. 修改GitHub Pages中的Custom domain选择\n\n  > Setting=>  GitHub Pages => Custom domain\n\n2. 在`/source`下添加名为`CNAME`的文件，无后缀。将你自己的域名放入文件内\n\n```bash\n    www.<yoursite>.name\n```\n\n3. 添加域名解析\n\n在你的域名管理后台（eg:万网），修改你的域名解析记录。  \n添加两个A记录，用得到的IP，一个主机记录为：“www”，一个为“@”，这样通过[yoursitename].com和www.[yoursitename].com都能访问到你的博客了。\n\n详见(github官方配置文档)[https://help.github.com/en/github/working-with-github-pages/configuring-a-custom-domain-for-your-github-pages-site]\n\n## 添加https\n\n自 2018 年 5 月 1 日，Github 支持自定义域名的 HTTPS 请求了。\n\n配置也相当简单：\n\n1. 更新 DNS 配置里的 A 记录，将其指向以下4个 IP 地址中的至少一个。\n\n    - 185.199.108.153\n    - 185.199.109.153\n    - 185.199.110.153\n    - 185.199.111.153\n\n2. GiHub Pages仓库的设置里勾选 'Enforce HTTPS'。\n  \n  > Setting=>  GitHub Pages => Custom domain\n\n## 添加评论\n\n  可以使用gitalk插件，[传送门](https://github.com/gitalk/gitalk)。具体配置就不写在这里了。  \n  推荐已经集成好的主题，[concise](https://github.com/sanonz/hexo-theme-concise)\n\n## 最佳实践\n\n  - 路径名包括文章的文件名，最好不要用中文\n  - 丰富文档样式，除了基础的markdown语法外，还可以使用hexo自己的[语法](https://hexo.io/zh-cn/docs/tag-plugins.html)","slug":"hello-world","published":1,"updated":"2021-03-08T05:05:27.620Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm05nqd500002cl255lffyd9","content":"<h2 id=\"新建一个hexo博客\"><a href=\"#新建一个hexo博客\" class=\"headerlink\" title=\"新建一个hexo博客\"></a>新建一个hexo博客</h2><h3 id=\"安装hexo\"><a href=\"#安装hexo\" class=\"headerlink\" title=\"安装hexo\"></a>安装hexo</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> yourblogfold</span><br><span class=\"line\">$ hexo init</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h2 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h2><h3 id=\"生成一个新文章\"><a href=\"#生成一个新文章\" class=\"headerlink\" title=\"生成一个新文章\"></a>生成一个新文章</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">// [layout] 为布局，可选项为 `post`、`page`、`draft`，这将决定文章所在文件路径。</span><br><span class=\"line\">// &lt;title&gt; 为文章标题</span><br><span class=\"line\"></span><br><span class=\"line\">$ hexo new [] <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"启动服务器\"><a href=\"#启动服务器\" class=\"headerlink\" title=\"启动服务器\"></a>启动服务器</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"生成静态文件\"><a href=\"#生成静态文件\" class=\"headerlink\" title=\"生成静态文件\"></a>生成静态文件</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n<h2 id=\"配合github-page\"><a href=\"#配合github-page\" class=\"headerlink\" title=\"配合github page\"></a>配合github page</h2><ol>\n<li><p>在github新建一个仓库，仓库名必须为<code>&lt;user-name&gt;.github.io</code>。<code>user-name</code>是github的昵称。</p>\n</li>\n<li><p>修改 _config.yml 配置</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Deployment</span></span><br><span class=\"line\"><span class=\"comment\">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class=\"line\">deploy:</span><br><span class=\"line\">    <span class=\"built_in\">type</span>: git</span><br><span class=\"line\">    repo: &lt;你的仓库地址&gt; <span class=\"comment\"># https://github.com/&lt;user-name&gt;/&lt;user-name&gt;.github.io</span></span><br><span class=\"line\">    branch: master</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>部署代码</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>查看效果</li>\n</ol>\n<h2 id=\"更换主题\"><a href=\"#更换主题\" class=\"headerlink\" title=\"更换主题\"></a>更换主题</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下载到themes文件夹下</span></span><br><span class=\"line\">$ git <span class=\"built_in\">clone</span> https://github.com/KevinOfNeu/hexo-theme-yourtheme yourtheme</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 修改 _config.yml 配置</span></span><br><span class=\"line\">$ theme: yourtheme</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"绑定自己的域名\"><a href=\"#绑定自己的域名\" class=\"headerlink\" title=\"绑定自己的域名\"></a>绑定自己的域名</h2><ol>\n<li><p>修改GitHub Pages中的Custom domain选择</p>\n<blockquote>\n<p>Setting=&gt;  GitHub Pages =&gt; Custom domain</p>\n</blockquote>\n</li>\n<li><p>在<code>/source</code>下添加名为<code>CNAME</code>的文件，无后缀。将你自己的域名放入文件内</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">www.&lt;yoursite&gt;.name</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>添加域名解析</li>\n</ol>\n<p>在你的域名管理后台（eg:万网），修改你的域名解析记录。<br>添加两个A记录，用得到的IP，一个主机记录为：“www”，一个为“@”，这样通过[yoursitename].com和www.[yoursitename].com都能访问到你的博客了。</p>\n<p>详见(github官方配置文档)[<a href=\"https://help.github.com/en/github/working-with-github-pages/configuring-a-custom-domain-for-your-github-pages-site]\" target=\"_blank\" rel=\"noopener\">https://help.github.com/en/github/working-with-github-pages/configuring-a-custom-domain-for-your-github-pages-site]</a></p>\n<h2 id=\"添加https\"><a href=\"#添加https\" class=\"headerlink\" title=\"添加https\"></a>添加https</h2><p>自 2018 年 5 月 1 日，Github 支持自定义域名的 HTTPS 请求了。</p>\n<p>配置也相当简单：</p>\n<ol>\n<li><p>更新 DNS 配置里的 A 记录，将其指向以下4个 IP 地址中的至少一个。</p>\n<ul>\n<li>185.199.108.153</li>\n<li>185.199.109.153</li>\n<li>185.199.110.153</li>\n<li>185.199.111.153</li>\n</ul>\n</li>\n<li><p>GiHub Pages仓库的设置里勾选 ‘Enforce HTTPS’。</p>\n<blockquote>\n<p>Setting=&gt;  GitHub Pages =&gt; Custom domain</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"添加评论\"><a href=\"#添加评论\" class=\"headerlink\" title=\"添加评论\"></a>添加评论</h2><p>  可以使用gitalk插件，<a href=\"https://github.com/gitalk/gitalk\" target=\"_blank\" rel=\"noopener\">传送门</a>。具体配置就不写在这里了。<br>  推荐已经集成好的主题，<a href=\"https://github.com/sanonz/hexo-theme-concise\" target=\"_blank\" rel=\"noopener\">concise</a></p>\n<h2 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h2><ul>\n<li>路径名包括文章的文件名，最好不要用中文</li>\n<li>丰富文档样式，除了基础的markdown语法外，还可以使用hexo自己的<a href=\"https://hexo.io/zh-cn/docs/tag-plugins.html\" target=\"_blank\" rel=\"noopener\">语法</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"新建一个hexo博客\"><a href=\"#新建一个hexo博客\" class=\"headerlink\" title=\"新建一个hexo博客\"></a>新建一个hexo博客</h2><h3 id=\"安装hexo\"><a href=\"#安装hexo\" class=\"headerlink\" title=\"安装hexo\"></a>安装hexo</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> yourblogfold</span><br><span class=\"line\">$ hexo init</span><br></pre></td></tr></table></figure>","more":"<h2 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h2><h3 id=\"生成一个新文章\"><a href=\"#生成一个新文章\" class=\"headerlink\" title=\"生成一个新文章\"></a>生成一个新文章</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">// [layout] 为布局，可选项为 `post`、`page`、`draft`，这将决定文章所在文件路径。</span><br><span class=\"line\">// &lt;title&gt; 为文章标题</span><br><span class=\"line\"></span><br><span class=\"line\">$ hexo new [] <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"启动服务器\"><a href=\"#启动服务器\" class=\"headerlink\" title=\"启动服务器\"></a>启动服务器</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"生成静态文件\"><a href=\"#生成静态文件\" class=\"headerlink\" title=\"生成静态文件\"></a>生成静态文件</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n<h2 id=\"配合github-page\"><a href=\"#配合github-page\" class=\"headerlink\" title=\"配合github page\"></a>配合github page</h2><ol>\n<li><p>在github新建一个仓库，仓库名必须为<code>&lt;user-name&gt;.github.io</code>。<code>user-name</code>是github的昵称。</p>\n</li>\n<li><p>修改 _config.yml 配置</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Deployment</span></span><br><span class=\"line\"><span class=\"comment\">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class=\"line\">deploy:</span><br><span class=\"line\">    <span class=\"built_in\">type</span>: git</span><br><span class=\"line\">    repo: &lt;你的仓库地址&gt; <span class=\"comment\"># https://github.com/&lt;user-name&gt;/&lt;user-name&gt;.github.io</span></span><br><span class=\"line\">    branch: master</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>部署代码</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>查看效果</li>\n</ol>\n<h2 id=\"更换主题\"><a href=\"#更换主题\" class=\"headerlink\" title=\"更换主题\"></a>更换主题</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下载到themes文件夹下</span></span><br><span class=\"line\">$ git <span class=\"built_in\">clone</span> https://github.com/KevinOfNeu/hexo-theme-yourtheme yourtheme</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 修改 _config.yml 配置</span></span><br><span class=\"line\">$ theme: yourtheme</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"绑定自己的域名\"><a href=\"#绑定自己的域名\" class=\"headerlink\" title=\"绑定自己的域名\"></a>绑定自己的域名</h2><ol>\n<li><p>修改GitHub Pages中的Custom domain选择</p>\n<blockquote>\n<p>Setting=&gt;  GitHub Pages =&gt; Custom domain</p>\n</blockquote>\n</li>\n<li><p>在<code>/source</code>下添加名为<code>CNAME</code>的文件，无后缀。将你自己的域名放入文件内</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">www.&lt;yoursite&gt;.name</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>添加域名解析</li>\n</ol>\n<p>在你的域名管理后台（eg:万网），修改你的域名解析记录。<br>添加两个A记录，用得到的IP，一个主机记录为：“www”，一个为“@”，这样通过[yoursitename].com和www.[yoursitename].com都能访问到你的博客了。</p>\n<p>详见(github官方配置文档)[<a href=\"https://help.github.com/en/github/working-with-github-pages/configuring-a-custom-domain-for-your-github-pages-site]\" target=\"_blank\" rel=\"noopener\">https://help.github.com/en/github/working-with-github-pages/configuring-a-custom-domain-for-your-github-pages-site]</a></p>\n<h2 id=\"添加https\"><a href=\"#添加https\" class=\"headerlink\" title=\"添加https\"></a>添加https</h2><p>自 2018 年 5 月 1 日，Github 支持自定义域名的 HTTPS 请求了。</p>\n<p>配置也相当简单：</p>\n<ol>\n<li><p>更新 DNS 配置里的 A 记录，将其指向以下4个 IP 地址中的至少一个。</p>\n<ul>\n<li>185.199.108.153</li>\n<li>185.199.109.153</li>\n<li>185.199.110.153</li>\n<li>185.199.111.153</li>\n</ul>\n</li>\n<li><p>GiHub Pages仓库的设置里勾选 ‘Enforce HTTPS’。</p>\n<blockquote>\n<p>Setting=&gt;  GitHub Pages =&gt; Custom domain</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"添加评论\"><a href=\"#添加评论\" class=\"headerlink\" title=\"添加评论\"></a>添加评论</h2><p>  可以使用gitalk插件，<a href=\"https://github.com/gitalk/gitalk\" target=\"_blank\" rel=\"noopener\">传送门</a>。具体配置就不写在这里了。<br>  推荐已经集成好的主题，<a href=\"https://github.com/sanonz/hexo-theme-concise\" target=\"_blank\" rel=\"noopener\">concise</a></p>\n<h2 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h2><ul>\n<li>路径名包括文章的文件名，最好不要用中文</li>\n<li>丰富文档样式，除了基础的markdown语法外，还可以使用hexo自己的<a href=\"https://hexo.io/zh-cn/docs/tag-plugins.html\" target=\"_blank\" rel=\"noopener\">语法</a></li>\n</ul>"},{"title":"火币平台比特币交易","date":"2020-04-16T05:13:56.000Z","_content":"\n## 如何购买\n\n1. 点击右上角“登录”， 输入注册手机号码、登录密码，点击“登录”后拖动滑块至最右登陆。\n2. 登陆后选择左上角法币交易。\n3. 选择你想要的币种（这里以购买BTC为例），考虑价格、支付方式选择广告，点击“购买BTC”。\n<!-- more -->\n![bbjy](bbjy.png)\n4. 输入想购买的金额/数量，点击“下单”。(这里的价格并不是实时价格，是卖主根据实时价格所定的主观价格。)\n5. 在订单详情页，确认付款金额（总价）和付款方式 。 支持的交易方式有：网银、手机银行、支付宝、微信或其他第三方支付平台，具体哪种由卖家决定。\n\n注意点：\n\n1. 涉及到人民币提现以及购买只能走法币。\n2. 币币操作类似于股市的低买高卖（如果你操作得当的话）。是及时的是虚拟交易。法币交易是真实的。是将数字币麦为人民币。\n3. 如买家取消3次当日将无法在购买，次日0点才可以\n  <img src=\"deal.jpeg\" width=\"500px\">\n4. BTC ETH  USDT  BCH  HUSD等等，这些是币的种类。 和账号种类没有关系。\n\n法币账户下可以有 BTC ETH  USDT  BCH  HUSD。\n币币账户下也可以有 BTC ETH  USDT  BCH  HUSD。\n\n相同币种可以通过“划转提现”进行转换。\nBTC ETH这两种币的价格波动比较大。USDT HUSD属于比较稳定的币，HUDT和美元基本挂钩。\n\n## 如何出售（提现）\n\n只有在法币才可以卖出成为人民币\n\n将账户币币转换成法币，如果您在火币币币交易区的数字资产不在法币交易区支持名单中，请先换成法币交易区支持的数字资产。先点击【资产】-【法币资产】-【划转提现】，把资产划转到法币账户中—点击【普通区/大宗区】，选择想要出售的币种，选择下方的广告进行下单—下单后请等待买家给您付款（支付宝/微信/银行卡），确认收款后，点击【确认放行】即可完成交易。\n\n## 几个概念\n\n### 币币账户\n\n- 币币交易是场内交易价格  实时的价格\n- 币币是做低买高卖的交易的\n- 币币和法币的价格都是有波动的\n\n### 法币账户\n\n- 法币交易是点对点交易场外交易\n- 价格由广告商家（买主）设定的\n- 法币最小交易是50人民币\n\n### BTC · 比特币\n\n比特币（Bitcoin，简称BTC）是目前使用最为广泛的一种数字货币，它诞生于2009年1月3日，是一种点对点（P2P）传输的数字加密货币，总量2100万枚。比特币网络每10分钟释放出一定数量币，预计在2140年达到极限。比特币被投资者称为“数字黄金”。比特币依据特定算法，通过大量的计算产生，不依靠特定货币机构发行，其使用整个P2P网络中众多节点构成的分布式数据库来确认并记录所有的交易行为，并使用密码学设计确保货币流通各个环节安全性，可确保无法通过大量制造比特币来人为操控币值。基于密码学的设计可以使比特币只能被真实拥有者转移、支付及兑现。同样确保了货币所有权与流通交易的匿名性。\n\n### USDT · Tether\n\nUSDT是Tether公司推出的基于稳定价值货币美元（USD）的代币Tether USD（下称USDT），1USDT=1美元，用户可以随时使用USDT与USD进行1:1兑换。Tether公司严格遵守1:1准备金保证，即每发行1个 USDT 代币，其银行账户都会有1美元的资金保障。用户可以在 Tether 平台进行资金查询，以保障透明度。用户可以通过SWIFT电汇美元至Tether公司提供的银行帐户，或通过交易所换取USDT。赎回美元时，反向操作即可。用户也可在交易所用比特币换取USDT。\n\n## HUSD (HUSD)\n\nHUSD是由Stable公司和Paxos TRUST LLC合作发行的美元稳定币。HUSD与美元1:1锚定，由第三方审计公司监督并审计。\n\n## Reference\n\n[数字资产介绍](https://www.huobi.io/zh-cn/assetintro/)\n","source":"_posts/daily/2020-04-16-bit.md","raw":"---\ntitle: 火币平台比特币交易\ndate: 2020-04-16 13:13:56\ntags: \n- 理财 \n- 比特币\n- 火币\n---\n\n## 如何购买\n\n1. 点击右上角“登录”， 输入注册手机号码、登录密码，点击“登录”后拖动滑块至最右登陆。\n2. 登陆后选择左上角法币交易。\n3. 选择你想要的币种（这里以购买BTC为例），考虑价格、支付方式选择广告，点击“购买BTC”。\n<!-- more -->\n![bbjy](bbjy.png)\n4. 输入想购买的金额/数量，点击“下单”。(这里的价格并不是实时价格，是卖主根据实时价格所定的主观价格。)\n5. 在订单详情页，确认付款金额（总价）和付款方式 。 支持的交易方式有：网银、手机银行、支付宝、微信或其他第三方支付平台，具体哪种由卖家决定。\n\n注意点：\n\n1. 涉及到人民币提现以及购买只能走法币。\n2. 币币操作类似于股市的低买高卖（如果你操作得当的话）。是及时的是虚拟交易。法币交易是真实的。是将数字币麦为人民币。\n3. 如买家取消3次当日将无法在购买，次日0点才可以\n  <img src=\"deal.jpeg\" width=\"500px\">\n4. BTC ETH  USDT  BCH  HUSD等等，这些是币的种类。 和账号种类没有关系。\n\n法币账户下可以有 BTC ETH  USDT  BCH  HUSD。\n币币账户下也可以有 BTC ETH  USDT  BCH  HUSD。\n\n相同币种可以通过“划转提现”进行转换。\nBTC ETH这两种币的价格波动比较大。USDT HUSD属于比较稳定的币，HUDT和美元基本挂钩。\n\n## 如何出售（提现）\n\n只有在法币才可以卖出成为人民币\n\n将账户币币转换成法币，如果您在火币币币交易区的数字资产不在法币交易区支持名单中，请先换成法币交易区支持的数字资产。先点击【资产】-【法币资产】-【划转提现】，把资产划转到法币账户中—点击【普通区/大宗区】，选择想要出售的币种，选择下方的广告进行下单—下单后请等待买家给您付款（支付宝/微信/银行卡），确认收款后，点击【确认放行】即可完成交易。\n\n## 几个概念\n\n### 币币账户\n\n- 币币交易是场内交易价格  实时的价格\n- 币币是做低买高卖的交易的\n- 币币和法币的价格都是有波动的\n\n### 法币账户\n\n- 法币交易是点对点交易场外交易\n- 价格由广告商家（买主）设定的\n- 法币最小交易是50人民币\n\n### BTC · 比特币\n\n比特币（Bitcoin，简称BTC）是目前使用最为广泛的一种数字货币，它诞生于2009年1月3日，是一种点对点（P2P）传输的数字加密货币，总量2100万枚。比特币网络每10分钟释放出一定数量币，预计在2140年达到极限。比特币被投资者称为“数字黄金”。比特币依据特定算法，通过大量的计算产生，不依靠特定货币机构发行，其使用整个P2P网络中众多节点构成的分布式数据库来确认并记录所有的交易行为，并使用密码学设计确保货币流通各个环节安全性，可确保无法通过大量制造比特币来人为操控币值。基于密码学的设计可以使比特币只能被真实拥有者转移、支付及兑现。同样确保了货币所有权与流通交易的匿名性。\n\n### USDT · Tether\n\nUSDT是Tether公司推出的基于稳定价值货币美元（USD）的代币Tether USD（下称USDT），1USDT=1美元，用户可以随时使用USDT与USD进行1:1兑换。Tether公司严格遵守1:1准备金保证，即每发行1个 USDT 代币，其银行账户都会有1美元的资金保障。用户可以在 Tether 平台进行资金查询，以保障透明度。用户可以通过SWIFT电汇美元至Tether公司提供的银行帐户，或通过交易所换取USDT。赎回美元时，反向操作即可。用户也可在交易所用比特币换取USDT。\n\n## HUSD (HUSD)\n\nHUSD是由Stable公司和Paxos TRUST LLC合作发行的美元稳定币。HUSD与美元1:1锚定，由第三方审计公司监督并审计。\n\n## Reference\n\n[数字资产介绍](https://www.huobi.io/zh-cn/assetintro/)\n","slug":"daily/2020-04-16-bit","published":1,"updated":"2021-03-08T03:34:10.741Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm05nqdr00072cl2gcey3yjd","content":"<h2 id=\"如何购买\"><a href=\"#如何购买\" class=\"headerlink\" title=\"如何购买\"></a>如何购买</h2><ol>\n<li>点击右上角“登录”， 输入注册手机号码、登录密码，点击“登录”后拖动滑块至最右登陆。</li>\n<li>登陆后选择左上角法币交易。</li>\n<li>选择你想要的币种（这里以购买BTC为例），考虑价格、支付方式选择广告，点击“购买BTC”。<a id=\"more\"></a>\n<img src=\"bbjy.png\" alt=\"bbjy\"></li>\n<li>输入想购买的金额/数量，点击“下单”。(这里的价格并不是实时价格，是卖主根据实时价格所定的主观价格。)</li>\n<li>在订单详情页，确认付款金额（总价）和付款方式 。 支持的交易方式有：网银、手机银行、支付宝、微信或其他第三方支付平台，具体哪种由卖家决定。</li>\n</ol>\n<p>注意点：</p>\n<ol>\n<li>涉及到人民币提现以及购买只能走法币。</li>\n<li>币币操作类似于股市的低买高卖（如果你操作得当的话）。是及时的是虚拟交易。法币交易是真实的。是将数字币麦为人民币。</li>\n<li>如买家取消3次当日将无法在购买，次日0点才可以<img src=\"deal.jpeg\" width=\"500px\"></li>\n<li>BTC ETH  USDT  BCH  HUSD等等，这些是币的种类。 和账号种类没有关系。</li>\n</ol>\n<p>法币账户下可以有 BTC ETH  USDT  BCH  HUSD。<br>币币账户下也可以有 BTC ETH  USDT  BCH  HUSD。</p>\n<p>相同币种可以通过“划转提现”进行转换。<br>BTC ETH这两种币的价格波动比较大。USDT HUSD属于比较稳定的币，HUDT和美元基本挂钩。</p>\n<h2 id=\"如何出售（提现）\"><a href=\"#如何出售（提现）\" class=\"headerlink\" title=\"如何出售（提现）\"></a>如何出售（提现）</h2><p>只有在法币才可以卖出成为人民币</p>\n<p>将账户币币转换成法币，如果您在火币币币交易区的数字资产不在法币交易区支持名单中，请先换成法币交易区支持的数字资产。先点击【资产】-【法币资产】-【划转提现】，把资产划转到法币账户中—点击【普通区/大宗区】，选择想要出售的币种，选择下方的广告进行下单—下单后请等待买家给您付款（支付宝/微信/银行卡），确认收款后，点击【确认放行】即可完成交易。</p>\n<h2 id=\"几个概念\"><a href=\"#几个概念\" class=\"headerlink\" title=\"几个概念\"></a>几个概念</h2><h3 id=\"币币账户\"><a href=\"#币币账户\" class=\"headerlink\" title=\"币币账户\"></a>币币账户</h3><ul>\n<li>币币交易是场内交易价格  实时的价格</li>\n<li>币币是做低买高卖的交易的</li>\n<li>币币和法币的价格都是有波动的</li>\n</ul>\n<h3 id=\"法币账户\"><a href=\"#法币账户\" class=\"headerlink\" title=\"法币账户\"></a>法币账户</h3><ul>\n<li>法币交易是点对点交易场外交易</li>\n<li>价格由广告商家（买主）设定的</li>\n<li>法币最小交易是50人民币</li>\n</ul>\n<h3 id=\"BTC-·-比特币\"><a href=\"#BTC-·-比特币\" class=\"headerlink\" title=\"BTC · 比特币\"></a>BTC · 比特币</h3><p>比特币（Bitcoin，简称BTC）是目前使用最为广泛的一种数字货币，它诞生于2009年1月3日，是一种点对点（P2P）传输的数字加密货币，总量2100万枚。比特币网络每10分钟释放出一定数量币，预计在2140年达到极限。比特币被投资者称为“数字黄金”。比特币依据特定算法，通过大量的计算产生，不依靠特定货币机构发行，其使用整个P2P网络中众多节点构成的分布式数据库来确认并记录所有的交易行为，并使用密码学设计确保货币流通各个环节安全性，可确保无法通过大量制造比特币来人为操控币值。基于密码学的设计可以使比特币只能被真实拥有者转移、支付及兑现。同样确保了货币所有权与流通交易的匿名性。</p>\n<h3 id=\"USDT-·-Tether\"><a href=\"#USDT-·-Tether\" class=\"headerlink\" title=\"USDT · Tether\"></a>USDT · Tether</h3><p>USDT是Tether公司推出的基于稳定价值货币美元（USD）的代币Tether USD（下称USDT），1USDT=1美元，用户可以随时使用USDT与USD进行1:1兑换。Tether公司严格遵守1:1准备金保证，即每发行1个 USDT 代币，其银行账户都会有1美元的资金保障。用户可以在 Tether 平台进行资金查询，以保障透明度。用户可以通过SWIFT电汇美元至Tether公司提供的银行帐户，或通过交易所换取USDT。赎回美元时，反向操作即可。用户也可在交易所用比特币换取USDT。</p>\n<h2 id=\"HUSD-HUSD\"><a href=\"#HUSD-HUSD\" class=\"headerlink\" title=\"HUSD (HUSD)\"></a>HUSD (HUSD)</h2><p>HUSD是由Stable公司和Paxos TRUST LLC合作发行的美元稳定币。HUSD与美元1:1锚定，由第三方审计公司监督并审计。</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://www.huobi.io/zh-cn/assetintro/\" target=\"_blank\" rel=\"noopener\">数字资产介绍</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"如何购买\"><a href=\"#如何购买\" class=\"headerlink\" title=\"如何购买\"></a>如何购买</h2><ol>\n<li>点击右上角“登录”， 输入注册手机号码、登录密码，点击“登录”后拖动滑块至最右登陆。</li>\n<li>登陆后选择左上角法币交易。</li>\n<li>选择你想要的币种（这里以购买BTC为例），考虑价格、支付方式选择广告，点击“购买BTC”。","more":"<img src=\"bbjy.png\" alt=\"bbjy\"></li>\n<li>输入想购买的金额/数量，点击“下单”。(这里的价格并不是实时价格，是卖主根据实时价格所定的主观价格。)</li>\n<li>在订单详情页，确认付款金额（总价）和付款方式 。 支持的交易方式有：网银、手机银行、支付宝、微信或其他第三方支付平台，具体哪种由卖家决定。</li>\n</ol>\n<p>注意点：</p>\n<ol>\n<li>涉及到人民币提现以及购买只能走法币。</li>\n<li>币币操作类似于股市的低买高卖（如果你操作得当的话）。是及时的是虚拟交易。法币交易是真实的。是将数字币麦为人民币。</li>\n<li>如买家取消3次当日将无法在购买，次日0点才可以<img src=\"deal.jpeg\" width=\"500px\"></li>\n<li>BTC ETH  USDT  BCH  HUSD等等，这些是币的种类。 和账号种类没有关系。</li>\n</ol>\n<p>法币账户下可以有 BTC ETH  USDT  BCH  HUSD。<br>币币账户下也可以有 BTC ETH  USDT  BCH  HUSD。</p>\n<p>相同币种可以通过“划转提现”进行转换。<br>BTC ETH这两种币的价格波动比较大。USDT HUSD属于比较稳定的币，HUDT和美元基本挂钩。</p>\n<h2 id=\"如何出售（提现）\"><a href=\"#如何出售（提现）\" class=\"headerlink\" title=\"如何出售（提现）\"></a>如何出售（提现）</h2><p>只有在法币才可以卖出成为人民币</p>\n<p>将账户币币转换成法币，如果您在火币币币交易区的数字资产不在法币交易区支持名单中，请先换成法币交易区支持的数字资产。先点击【资产】-【法币资产】-【划转提现】，把资产划转到法币账户中—点击【普通区/大宗区】，选择想要出售的币种，选择下方的广告进行下单—下单后请等待买家给您付款（支付宝/微信/银行卡），确认收款后，点击【确认放行】即可完成交易。</p>\n<h2 id=\"几个概念\"><a href=\"#几个概念\" class=\"headerlink\" title=\"几个概念\"></a>几个概念</h2><h3 id=\"币币账户\"><a href=\"#币币账户\" class=\"headerlink\" title=\"币币账户\"></a>币币账户</h3><ul>\n<li>币币交易是场内交易价格  实时的价格</li>\n<li>币币是做低买高卖的交易的</li>\n<li>币币和法币的价格都是有波动的</li>\n</ul>\n<h3 id=\"法币账户\"><a href=\"#法币账户\" class=\"headerlink\" title=\"法币账户\"></a>法币账户</h3><ul>\n<li>法币交易是点对点交易场外交易</li>\n<li>价格由广告商家（买主）设定的</li>\n<li>法币最小交易是50人民币</li>\n</ul>\n<h3 id=\"BTC-·-比特币\"><a href=\"#BTC-·-比特币\" class=\"headerlink\" title=\"BTC · 比特币\"></a>BTC · 比特币</h3><p>比特币（Bitcoin，简称BTC）是目前使用最为广泛的一种数字货币，它诞生于2009年1月3日，是一种点对点（P2P）传输的数字加密货币，总量2100万枚。比特币网络每10分钟释放出一定数量币，预计在2140年达到极限。比特币被投资者称为“数字黄金”。比特币依据特定算法，通过大量的计算产生，不依靠特定货币机构发行，其使用整个P2P网络中众多节点构成的分布式数据库来确认并记录所有的交易行为，并使用密码学设计确保货币流通各个环节安全性，可确保无法通过大量制造比特币来人为操控币值。基于密码学的设计可以使比特币只能被真实拥有者转移、支付及兑现。同样确保了货币所有权与流通交易的匿名性。</p>\n<h3 id=\"USDT-·-Tether\"><a href=\"#USDT-·-Tether\" class=\"headerlink\" title=\"USDT · Tether\"></a>USDT · Tether</h3><p>USDT是Tether公司推出的基于稳定价值货币美元（USD）的代币Tether USD（下称USDT），1USDT=1美元，用户可以随时使用USDT与USD进行1:1兑换。Tether公司严格遵守1:1准备金保证，即每发行1个 USDT 代币，其银行账户都会有1美元的资金保障。用户可以在 Tether 平台进行资金查询，以保障透明度。用户可以通过SWIFT电汇美元至Tether公司提供的银行帐户，或通过交易所换取USDT。赎回美元时，反向操作即可。用户也可在交易所用比特币换取USDT。</p>\n<h2 id=\"HUSD-HUSD\"><a href=\"#HUSD-HUSD\" class=\"headerlink\" title=\"HUSD (HUSD)\"></a>HUSD (HUSD)</h2><p>HUSD是由Stable公司和Paxos TRUST LLC合作发行的美元稳定币。HUSD与美元1:1锚定，由第三方审计公司监督并审计。</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://www.huobi.io/zh-cn/assetintro/\" target=\"_blank\" rel=\"noopener\">数字资产介绍</a></p>"},{"title":"0.1+0.2≠0.3的问题","date":"2021-01-05T06:00:12.000Z","_content":"这个问题应该是在浮点数运算里比较常见的问题了，\n<!-- more -->\n这次就送三个方面来分析一下这个问题：\n - 解决方案\n - 为什么会有这个问题\n - 一个表示浮点数的工具\n\n## 常用解决方案\n- 将浮点数扩大$10^n$变成整数，进行整数运算\n- if判断操作时使用`Number.EPSILON`可表示(representable)数之间的最小间隔\n```js\n   0.1 + 0.2 == 0.3  //false\n   0.1 + 0.2 - 0.3 < Number.EPSILON\n```\n\n## 为什么会有这个问题\nECMAScript7种常见类型中，Number应该是最令人关注的数据类型了，这种类型使用IEEE754格式来表示整数和浮点数。所以浮点数计算会产生舍入误差的问题，是IEEE754数值的浮点问题，不仅仅存在于javaScript中，也存在于任何一个使用IEEE754标准的语言中。\n由于计算机存储和计算都是基于二进制，但是我们平时日常使用和编程使用的大都是十进制表示。所以这就存在一个二进制转十进制的问题。0.1+0.2≠0.3的问题就是来源于此。\n具体来说，在二进制表示十进制整数时并没有什么问题，但是在表示浮点数时，便会出现精度问题。\njavaScript采用IEEE754标准的双精度64位二进制的形式(单精度采用1+8+23位的二进制表示)。\n\n\n### IEEE754\n基于 IEEE 754 标准的双精度 64 位二进制格式的值（-($2^{63}$ -1) 到 $2^{63}$ -1）。它并没有为整数给出一种特定的类型。除了能够表示浮点数外，还有一些带符号的值：+Infinity，-Infinity 和 NaN (非数值，Not-a-Number)。\n![5e108fa71c8bb159294b8a7e2187518c.png](evernotecid://84FC037D-AE68-4F05-8F7D-A0E8EE6858BD/appyinxiangcom/4074438/ENResource/p596)\n\n\n||S|Exp|\tFraction|\n|-|-|-|-|\n|长度|1|\t11|\t52位长|\n|位数|63|62至52|偏正值（实际的指数大小+1023）\t51至0位编号（从右边开始为0）|\n $1.fraction^{exponent}$\n- 第0位记录符号位 \n    - 1 负数\n    - 0 正数\n- 第1-11位记录指数偏移值(exponent)\n  - 为了兼容正负数，采用移码中的阶码的方式表示(详见2.5.4)\n    \n- 第12-63位存储有效位（fraction）\n\n\n### 转换步骤\n1. 将十进制转为二进制表示（误差来自于这个步骤）\n2. 将二进制转换为指数科学计数法 \n3. 将科学计数法采用IEEE754的方式存储于计算机\n\n\n举例来说,为了方便说明，我们这里选择 77.1875其小数部分是可以用有限位表示的\n  \n 1. 将十进制转换为二进制\n    77 => 1001101\n    0.1875 => 0.0011\n    77.1875 => 1001101.0011\n    \n 2. 将二进制转化为指数科学计数法\n    1001101.0011 => 1.0011010011*$2^6$\n 3. 将科学计数法采用IEEE754的方式存储于计算机\n     1. 符号位： + => 0\n     2. 指数偏移量 => 6+2047 => 110\n     3. 有效位：0011010011\n     4. 变为64位表示`0 00000000110 0000000000 0000000000 0000000000 0000000000 0000110100 11`\n\n在日常开发中，将小数部分转化为二进制，常常无法在有限位内转化，所以52位有效位的情况下，从小数点后第一个非0数字开始，之后最多可以保留52位（加上最左边被舍去的1，应该是53位）。\n\n### js里的最大整数和浮点数\n- Number.MAX_SAFE_INTEGER\n     - JavaScript 中最大的安全整数 ($2^{53}$ - 1)。\n     - 52位二进制表示的最大数就是$2^{53}$ - 1\n- Number.MAX_VALUE\n    - 能表示的最大正数。最小的负数是 -MAX_VALUE。\n- Number.MIN_SAFE_INTEGER\n    - JavaScript 中最小的安全整数 (-($2^{53}$ - 1)).\n- Number.MIN_VALUE\n    - 能表示的最小正数即最接近 0 的正数 (实际上不会变成 0)。最大的负数是 -MIN_VALUE。\n    - 二进制表示为 0.0000000000000......00001\n    - 根据IEEE754标准，小数点后最多可以出现$2^{11}$\n\n\n要检查值是否大于或小于 +/-Infinity，你可以使用常量 Number.MAX_VALUE 和 Number.MIN_VALUE。另外在 ECMAScript 6 中，你也可以通过 Number.isSafeInteger() 方法还有 Number.MAX_SAFE_INTEGER 和 Number.MIN_SAFE_INTEGER($2^{53}$-1) 来检查值是否在双精度浮点数的取值范围内。 超出这个范围，JavaScript 中的数字不再安全了，也就是只有 second mathematical interger 可以在 JavaScript 数字类型中正确表现。\n\n\n### js里常见的数据表示法\n - 二进制   \n    - 以0b开头\n    - 0b101  (十进制的5)\n - 八进制\n     - 以0o开头\n     - 0o101 (十进制的65)\n - 十进制\n     - 日常编码最常用的进制\n - 十六进制\n    - 以0x开头\n    - 0x101 (十进制257)\n\n### 补码的方式\n\n![521ab6715750440309c4ac2b9b15ec1f.png](evernotecid://84FC037D-AE68-4F05-8F7D-A0E8EE6858BD/appyinxiangcom/4074438/ENResource/p597)\n\n\n负数补码表示的范围比原码稍宽，多一种数码组合。对于定点数，若为纯小数，表示范围为：\n-1 ~ $1-2^n$。若为纯整数，表示范围为：$-2^n$ ~ $2^n-1$（原码：$-2^n+1$ ~ $2^n-1$）\n\n#### 原码转换补码\n(以8位二进制为例)\n- 正整数的补码是其二进制表示，与原码相同 \n    - 9 => `0000 1001`\n- 负整数的补码，将其原码除符号位外的所有位取反（0变1，1变0，符号位为1不变）后加1\n    - 原码 -9 =>`1000 1001`\n    - 取反 `1000 1001` => `1111 0110`\n    - 加一 `1111 0110` => `1111 0111`\n- 数0的补码表示是唯一的 \n    - 原码会有`+0`、`-0`的问题\n    - `0000 0000`\n    \n#### 补码转为原码\n- 如果补码的符号位为“0”，表示是一个正数，其原码就是补码。\n- 如果补码的符号位为“1”，表示是一个负数，求这个补码的补码就是原码。\n    - 取反 `1111 0111` => `1000 1000`\n    - 加一 `1000 1000` => `1000 1001`\n    - 原码 `1000 1001` => `-9`\n- 0是唯一的 `0000 0000`\n    - 原码的-0 => `1000 0000`表示的是什么？来看一下\n    1. 取反 `1000 0000` => `1111 1111`\n    2. 加一 `1111 1111` => `1000 0000`\n    3. 原码 `1000 0000` => `-128` (符号位也代表了数值)\n\n#### 补码的意义\n- 解决了符号的表示的问题；\n- 可以将减法运算转化为补码的加法运算来实现，克服了原码加减法运算繁杂的弊端，可有效简化运算器的设计；\n    这里需要展开一下，以八位二进制来说，\n    - 6 和 6 + 128 ($2^8$)的表示是一样的 `0000 0110`\n    - 利用上述的特点就可以将减法操作变为加法操作\n    - 9-3 => 9-3+128 => 9+125\n    - 所以将-3转化为125可以简化运算\n    - 这个转化关系就是补码 取反加一\n- 在计算机中，利用电子器件的特点实现补码和真值、原码之间的相互转换，非常容易；\n- 补码表示统一了符号位和数值位，使得符号位可以和数值位一起直接参与运算，这也为后面设计乘法器除法器等运算器件提供了极大的方便。\n\n总之，补码概念的引入和当时运算器设计的背景不无关系，从设计者角度，既要考虑表示的数的类型(小数、整数、实数和复数)、数值范围和精确度，又要考虑数据存储和处理所需要的硬件代价。因此，使用补码来表示机器数并得到广泛的应用，也就不难理解了\n\n\n#### 阶码\n\n在IEEE274中，指数部分采用的移码方式是阶码，而不是传统的补码，阶码的规则更加简单，就是用 $2^{n-1}-1$ + 实际值就是最终的结果。\n比如，一个8位的二进制($2^{n-1}-1$ = 127)，表示的数是 39\n\n实际转码就是 127+39 = 166；\n\n表示的数是 -56；\n实际转码就是 127-56 = 71；\n\n## 一个表示浮点数的工具\n\n如代码无法运行请点击[这里](https://codepen.io/woowyl/pen/JjbpKzy)\n\n{% iframe https://codepen.io/woowyl/embed/JjbpKzy?height=265&theme-id=light&default-tab=js,result 100% 400 %}","source":"_posts/language/IEEE754.md","raw":"---\ntitle: 0.1+0.2≠0.3的问题\ndate: 2021-01-05 14:00:12\ncategories: language\ntags: \n- 计算机通识\n---\n这个问题应该是在浮点数运算里比较常见的问题了，\n<!-- more -->\n这次就送三个方面来分析一下这个问题：\n - 解决方案\n - 为什么会有这个问题\n - 一个表示浮点数的工具\n\n## 常用解决方案\n- 将浮点数扩大$10^n$变成整数，进行整数运算\n- if判断操作时使用`Number.EPSILON`可表示(representable)数之间的最小间隔\n```js\n   0.1 + 0.2 == 0.3  //false\n   0.1 + 0.2 - 0.3 < Number.EPSILON\n```\n\n## 为什么会有这个问题\nECMAScript7种常见类型中，Number应该是最令人关注的数据类型了，这种类型使用IEEE754格式来表示整数和浮点数。所以浮点数计算会产生舍入误差的问题，是IEEE754数值的浮点问题，不仅仅存在于javaScript中，也存在于任何一个使用IEEE754标准的语言中。\n由于计算机存储和计算都是基于二进制，但是我们平时日常使用和编程使用的大都是十进制表示。所以这就存在一个二进制转十进制的问题。0.1+0.2≠0.3的问题就是来源于此。\n具体来说，在二进制表示十进制整数时并没有什么问题，但是在表示浮点数时，便会出现精度问题。\njavaScript采用IEEE754标准的双精度64位二进制的形式(单精度采用1+8+23位的二进制表示)。\n\n\n### IEEE754\n基于 IEEE 754 标准的双精度 64 位二进制格式的值（-($2^{63}$ -1) 到 $2^{63}$ -1）。它并没有为整数给出一种特定的类型。除了能够表示浮点数外，还有一些带符号的值：+Infinity，-Infinity 和 NaN (非数值，Not-a-Number)。\n![5e108fa71c8bb159294b8a7e2187518c.png](evernotecid://84FC037D-AE68-4F05-8F7D-A0E8EE6858BD/appyinxiangcom/4074438/ENResource/p596)\n\n\n||S|Exp|\tFraction|\n|-|-|-|-|\n|长度|1|\t11|\t52位长|\n|位数|63|62至52|偏正值（实际的指数大小+1023）\t51至0位编号（从右边开始为0）|\n $1.fraction^{exponent}$\n- 第0位记录符号位 \n    - 1 负数\n    - 0 正数\n- 第1-11位记录指数偏移值(exponent)\n  - 为了兼容正负数，采用移码中的阶码的方式表示(详见2.5.4)\n    \n- 第12-63位存储有效位（fraction）\n\n\n### 转换步骤\n1. 将十进制转为二进制表示（误差来自于这个步骤）\n2. 将二进制转换为指数科学计数法 \n3. 将科学计数法采用IEEE754的方式存储于计算机\n\n\n举例来说,为了方便说明，我们这里选择 77.1875其小数部分是可以用有限位表示的\n  \n 1. 将十进制转换为二进制\n    77 => 1001101\n    0.1875 => 0.0011\n    77.1875 => 1001101.0011\n    \n 2. 将二进制转化为指数科学计数法\n    1001101.0011 => 1.0011010011*$2^6$\n 3. 将科学计数法采用IEEE754的方式存储于计算机\n     1. 符号位： + => 0\n     2. 指数偏移量 => 6+2047 => 110\n     3. 有效位：0011010011\n     4. 变为64位表示`0 00000000110 0000000000 0000000000 0000000000 0000000000 0000110100 11`\n\n在日常开发中，将小数部分转化为二进制，常常无法在有限位内转化，所以52位有效位的情况下，从小数点后第一个非0数字开始，之后最多可以保留52位（加上最左边被舍去的1，应该是53位）。\n\n### js里的最大整数和浮点数\n- Number.MAX_SAFE_INTEGER\n     - JavaScript 中最大的安全整数 ($2^{53}$ - 1)。\n     - 52位二进制表示的最大数就是$2^{53}$ - 1\n- Number.MAX_VALUE\n    - 能表示的最大正数。最小的负数是 -MAX_VALUE。\n- Number.MIN_SAFE_INTEGER\n    - JavaScript 中最小的安全整数 (-($2^{53}$ - 1)).\n- Number.MIN_VALUE\n    - 能表示的最小正数即最接近 0 的正数 (实际上不会变成 0)。最大的负数是 -MIN_VALUE。\n    - 二进制表示为 0.0000000000000......00001\n    - 根据IEEE754标准，小数点后最多可以出现$2^{11}$\n\n\n要检查值是否大于或小于 +/-Infinity，你可以使用常量 Number.MAX_VALUE 和 Number.MIN_VALUE。另外在 ECMAScript 6 中，你也可以通过 Number.isSafeInteger() 方法还有 Number.MAX_SAFE_INTEGER 和 Number.MIN_SAFE_INTEGER($2^{53}$-1) 来检查值是否在双精度浮点数的取值范围内。 超出这个范围，JavaScript 中的数字不再安全了，也就是只有 second mathematical interger 可以在 JavaScript 数字类型中正确表现。\n\n\n### js里常见的数据表示法\n - 二进制   \n    - 以0b开头\n    - 0b101  (十进制的5)\n - 八进制\n     - 以0o开头\n     - 0o101 (十进制的65)\n - 十进制\n     - 日常编码最常用的进制\n - 十六进制\n    - 以0x开头\n    - 0x101 (十进制257)\n\n### 补码的方式\n\n![521ab6715750440309c4ac2b9b15ec1f.png](evernotecid://84FC037D-AE68-4F05-8F7D-A0E8EE6858BD/appyinxiangcom/4074438/ENResource/p597)\n\n\n负数补码表示的范围比原码稍宽，多一种数码组合。对于定点数，若为纯小数，表示范围为：\n-1 ~ $1-2^n$。若为纯整数，表示范围为：$-2^n$ ~ $2^n-1$（原码：$-2^n+1$ ~ $2^n-1$）\n\n#### 原码转换补码\n(以8位二进制为例)\n- 正整数的补码是其二进制表示，与原码相同 \n    - 9 => `0000 1001`\n- 负整数的补码，将其原码除符号位外的所有位取反（0变1，1变0，符号位为1不变）后加1\n    - 原码 -9 =>`1000 1001`\n    - 取反 `1000 1001` => `1111 0110`\n    - 加一 `1111 0110` => `1111 0111`\n- 数0的补码表示是唯一的 \n    - 原码会有`+0`、`-0`的问题\n    - `0000 0000`\n    \n#### 补码转为原码\n- 如果补码的符号位为“0”，表示是一个正数，其原码就是补码。\n- 如果补码的符号位为“1”，表示是一个负数，求这个补码的补码就是原码。\n    - 取反 `1111 0111` => `1000 1000`\n    - 加一 `1000 1000` => `1000 1001`\n    - 原码 `1000 1001` => `-9`\n- 0是唯一的 `0000 0000`\n    - 原码的-0 => `1000 0000`表示的是什么？来看一下\n    1. 取反 `1000 0000` => `1111 1111`\n    2. 加一 `1111 1111` => `1000 0000`\n    3. 原码 `1000 0000` => `-128` (符号位也代表了数值)\n\n#### 补码的意义\n- 解决了符号的表示的问题；\n- 可以将减法运算转化为补码的加法运算来实现，克服了原码加减法运算繁杂的弊端，可有效简化运算器的设计；\n    这里需要展开一下，以八位二进制来说，\n    - 6 和 6 + 128 ($2^8$)的表示是一样的 `0000 0110`\n    - 利用上述的特点就可以将减法操作变为加法操作\n    - 9-3 => 9-3+128 => 9+125\n    - 所以将-3转化为125可以简化运算\n    - 这个转化关系就是补码 取反加一\n- 在计算机中，利用电子器件的特点实现补码和真值、原码之间的相互转换，非常容易；\n- 补码表示统一了符号位和数值位，使得符号位可以和数值位一起直接参与运算，这也为后面设计乘法器除法器等运算器件提供了极大的方便。\n\n总之，补码概念的引入和当时运算器设计的背景不无关系，从设计者角度，既要考虑表示的数的类型(小数、整数、实数和复数)、数值范围和精确度，又要考虑数据存储和处理所需要的硬件代价。因此，使用补码来表示机器数并得到广泛的应用，也就不难理解了\n\n\n#### 阶码\n\n在IEEE274中，指数部分采用的移码方式是阶码，而不是传统的补码，阶码的规则更加简单，就是用 $2^{n-1}-1$ + 实际值就是最终的结果。\n比如，一个8位的二进制($2^{n-1}-1$ = 127)，表示的数是 39\n\n实际转码就是 127+39 = 166；\n\n表示的数是 -56；\n实际转码就是 127-56 = 71；\n\n## 一个表示浮点数的工具\n\n如代码无法运行请点击[这里](https://codepen.io/woowyl/pen/JjbpKzy)\n\n{% iframe https://codepen.io/woowyl/embed/JjbpKzy?height=265&theme-id=light&default-tab=js,result 100% 400 %}","slug":"language/IEEE754","published":1,"updated":"2021-03-08T05:39:47.287Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm05nqdt00082cl295f456p7","content":"<p>这个问题应该是在浮点数运算里比较常见的问题了，</p>\n<a id=\"more\"></a>\n<p>这次就送三个方面来分析一下这个问题：</p>\n<ul>\n<li>解决方案</li>\n<li>为什么会有这个问题</li>\n<li>一个表示浮点数的工具</li>\n</ul>\n<h2 id=\"常用解决方案\"><a href=\"#常用解决方案\" class=\"headerlink\" title=\"常用解决方案\"></a>常用解决方案</h2><ul>\n<li>将浮点数扩大$10^n$变成整数，进行整数运算</li>\n<li>if判断操作时使用<code>Number.EPSILON</code>可表示(representable)数之间的最小间隔<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0.1</span> + <span class=\"number\">0.2</span> == <span class=\"number\">0.3</span>  <span class=\"comment\">//false</span></span><br><span class=\"line\"><span class=\"number\">0.1</span> + <span class=\"number\">0.2</span> - <span class=\"number\">0.3</span> &lt; <span class=\"built_in\">Number</span>.EPSILON</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"为什么会有这个问题\"><a href=\"#为什么会有这个问题\" class=\"headerlink\" title=\"为什么会有这个问题\"></a>为什么会有这个问题</h2><p>ECMAScript7种常见类型中，Number应该是最令人关注的数据类型了，这种类型使用IEEE754格式来表示整数和浮点数。所以浮点数计算会产生舍入误差的问题，是IEEE754数值的浮点问题，不仅仅存在于javaScript中，也存在于任何一个使用IEEE754标准的语言中。<br>由于计算机存储和计算都是基于二进制，但是我们平时日常使用和编程使用的大都是十进制表示。所以这就存在一个二进制转十进制的问题。0.1+0.2≠0.3的问题就是来源于此。<br>具体来说，在二进制表示十进制整数时并没有什么问题，但是在表示浮点数时，便会出现精度问题。<br>javaScript采用IEEE754标准的双精度64位二进制的形式(单精度采用1+8+23位的二进制表示)。</p>\n<h3 id=\"IEEE754\"><a href=\"#IEEE754\" class=\"headerlink\" title=\"IEEE754\"></a>IEEE754</h3><p>基于 IEEE 754 标准的双精度 64 位二进制格式的值（-($2^{63}$ -1) 到 $2^{63}$ -1）。它并没有为整数给出一种特定的类型。除了能够表示浮点数外，还有一些带符号的值：+Infinity，-Infinity 和 NaN (非数值，Not-a-Number)。<br><img src=\"evernotecid://84FC037D-AE68-4F05-8F7D-A0E8EE6858BD/appyinxiangcom/4074438/ENResource/p596\" alt=\"5e108fa71c8bb159294b8a7e2187518c.png\"></p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>S</th>\n<th>Exp</th>\n<th>Fraction</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>长度</td>\n<td>1</td>\n<td>11</td>\n<td>52位长</td>\n</tr>\n<tr>\n<td>位数</td>\n<td>63</td>\n<td>62至52</td>\n<td>偏正值（实际的指数大小+1023）    51至0位编号（从右边开始为0）</td>\n</tr>\n<tr>\n<td>$1.fraction^{exponent}$</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>- 第0位记录符号位</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>- 1 负数</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>- 0 正数</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>- 第1-11位记录指数偏移值(exponent)</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>- 为了兼容正负数，采用移码中的阶码的方式表示(详见2.5.4)</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<ul>\n<li>第12-63位存储有效位（fraction）</li>\n</ul>\n<h3 id=\"转换步骤\"><a href=\"#转换步骤\" class=\"headerlink\" title=\"转换步骤\"></a>转换步骤</h3><ol>\n<li>将十进制转为二进制表示（误差来自于这个步骤）</li>\n<li>将二进制转换为指数科学计数法 </li>\n<li>将科学计数法采用IEEE754的方式存储于计算机</li>\n</ol>\n<p>举例来说,为了方便说明，我们这里选择 77.1875其小数部分是可以用有限位表示的</p>\n<ol>\n<li><p>将十进制转换为二进制<br>77 =&gt; 1001101<br>0.1875 =&gt; 0.0011<br>77.1875 =&gt; 1001101.0011</p>\n</li>\n<li><p>将二进制转化为指数科学计数法<br>1001101.0011 =&gt; 1.0011010011*$2^6$</p>\n</li>\n<li><p>将科学计数法采用IEEE754的方式存储于计算机</p>\n<ol>\n<li>符号位： + =&gt; 0</li>\n<li>指数偏移量 =&gt; 6+2047 =&gt; 110</li>\n<li>有效位：0011010011</li>\n<li>变为64位表示<code>0 00000000110 0000000000 0000000000 0000000000 0000000000 0000110100 11</code></li>\n</ol>\n</li>\n</ol>\n<p>在日常开发中，将小数部分转化为二进制，常常无法在有限位内转化，所以52位有效位的情况下，从小数点后第一个非0数字开始，之后最多可以保留52位（加上最左边被舍去的1，应该是53位）。</p>\n<h3 id=\"js里的最大整数和浮点数\"><a href=\"#js里的最大整数和浮点数\" class=\"headerlink\" title=\"js里的最大整数和浮点数\"></a>js里的最大整数和浮点数</h3><ul>\n<li>Number.MAX_SAFE_INTEGER<ul>\n<li>JavaScript 中最大的安全整数 ($2^{53}$ - 1)。</li>\n<li>52位二进制表示的最大数就是$2^{53}$ - 1</li>\n</ul>\n</li>\n<li>Number.MAX_VALUE<ul>\n<li>能表示的最大正数。最小的负数是 -MAX_VALUE。</li>\n</ul>\n</li>\n<li>Number.MIN_SAFE_INTEGER<ul>\n<li>JavaScript 中最小的安全整数 (-($2^{53}$ - 1)).</li>\n</ul>\n</li>\n<li>Number.MIN_VALUE<ul>\n<li>能表示的最小正数即最接近 0 的正数 (实际上不会变成 0)。最大的负数是 -MIN_VALUE。</li>\n<li>二进制表示为 0.0000000000000……00001</li>\n<li>根据IEEE754标准，小数点后最多可以出现$2^{11}$</li>\n</ul>\n</li>\n</ul>\n<p>要检查值是否大于或小于 +/-Infinity，你可以使用常量 Number.MAX_VALUE 和 Number.MIN_VALUE。另外在 ECMAScript 6 中，你也可以通过 Number.isSafeInteger() 方法还有 Number.MAX_SAFE_INTEGER 和 Number.MIN_SAFE_INTEGER($2^{53}$-1) 来检查值是否在双精度浮点数的取值范围内。 超出这个范围，JavaScript 中的数字不再安全了，也就是只有 second mathematical interger 可以在 JavaScript 数字类型中正确表现。</p>\n<h3 id=\"js里常见的数据表示法\"><a href=\"#js里常见的数据表示法\" class=\"headerlink\" title=\"js里常见的数据表示法\"></a>js里常见的数据表示法</h3><ul>\n<li>二进制   <ul>\n<li>以0b开头</li>\n<li>0b101  (十进制的5)</li>\n</ul>\n</li>\n<li>八进制<ul>\n<li>以0o开头</li>\n<li>0o101 (十进制的65)</li>\n</ul>\n</li>\n<li>十进制<ul>\n<li>日常编码最常用的进制</li>\n</ul>\n</li>\n<li>十六进制<ul>\n<li>以0x开头</li>\n<li>0x101 (十进制257)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"补码的方式\"><a href=\"#补码的方式\" class=\"headerlink\" title=\"补码的方式\"></a>补码的方式</h3><p><img src=\"evernotecid://84FC037D-AE68-4F05-8F7D-A0E8EE6858BD/appyinxiangcom/4074438/ENResource/p597\" alt=\"521ab6715750440309c4ac2b9b15ec1f.png\"></p>\n<p>负数补码表示的范围比原码稍宽，多一种数码组合。对于定点数，若为纯小数，表示范围为：<br>-1 ~ $1-2^n$。若为纯整数，表示范围为：$-2^n$ ~ $2^n-1$（原码：$-2^n+1$ ~ $2^n-1$）</p>\n<h4 id=\"原码转换补码\"><a href=\"#原码转换补码\" class=\"headerlink\" title=\"原码转换补码\"></a>原码转换补码</h4><p>(以8位二进制为例)</p>\n<ul>\n<li>正整数的补码是其二进制表示，与原码相同 <ul>\n<li>9 =&gt; <code>0000 1001</code></li>\n</ul>\n</li>\n<li>负整数的补码，将其原码除符号位外的所有位取反（0变1，1变0，符号位为1不变）后加1<ul>\n<li>原码 -9 =&gt;<code>1000 1001</code></li>\n<li>取反 <code>1000 1001</code> =&gt; <code>1111 0110</code></li>\n<li>加一 <code>1111 0110</code> =&gt; <code>1111 0111</code></li>\n</ul>\n</li>\n<li>数0的补码表示是唯一的 <ul>\n<li>原码会有<code>+0</code>、<code>-0</code>的问题</li>\n<li><code>0000 0000</code></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"补码转为原码\"><a href=\"#补码转为原码\" class=\"headerlink\" title=\"补码转为原码\"></a>补码转为原码</h4><ul>\n<li>如果补码的符号位为“0”，表示是一个正数，其原码就是补码。</li>\n<li>如果补码的符号位为“1”，表示是一个负数，求这个补码的补码就是原码。<ul>\n<li>取反 <code>1111 0111</code> =&gt; <code>1000 1000</code></li>\n<li>加一 <code>1000 1000</code> =&gt; <code>1000 1001</code></li>\n<li>原码 <code>1000 1001</code> =&gt; <code>-9</code></li>\n</ul>\n</li>\n<li>0是唯一的 <code>0000 0000</code><ul>\n<li>原码的-0 =&gt; <code>1000 0000</code>表示的是什么？来看一下</li>\n</ul>\n<ol>\n<li>取反 <code>1000 0000</code> =&gt; <code>1111 1111</code></li>\n<li>加一 <code>1111 1111</code> =&gt; <code>1000 0000</code></li>\n<li>原码 <code>1000 0000</code> =&gt; <code>-128</code> (符号位也代表了数值)</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"补码的意义\"><a href=\"#补码的意义\" class=\"headerlink\" title=\"补码的意义\"></a>补码的意义</h4><ul>\n<li>解决了符号的表示的问题；</li>\n<li>可以将减法运算转化为补码的加法运算来实现，克服了原码加减法运算繁杂的弊端，可有效简化运算器的设计；<br>  这里需要展开一下，以八位二进制来说，<ul>\n<li>6 和 6 + 128 ($2^8$)的表示是一样的 <code>0000 0110</code></li>\n<li>利用上述的特点就可以将减法操作变为加法操作</li>\n<li>9-3 =&gt; 9-3+128 =&gt; 9+125</li>\n<li>所以将-3转化为125可以简化运算</li>\n<li>这个转化关系就是补码 取反加一</li>\n</ul>\n</li>\n<li>在计算机中，利用电子器件的特点实现补码和真值、原码之间的相互转换，非常容易；</li>\n<li>补码表示统一了符号位和数值位，使得符号位可以和数值位一起直接参与运算，这也为后面设计乘法器除法器等运算器件提供了极大的方便。</li>\n</ul>\n<p>总之，补码概念的引入和当时运算器设计的背景不无关系，从设计者角度，既要考虑表示的数的类型(小数、整数、实数和复数)、数值范围和精确度，又要考虑数据存储和处理所需要的硬件代价。因此，使用补码来表示机器数并得到广泛的应用，也就不难理解了</p>\n<h4 id=\"阶码\"><a href=\"#阶码\" class=\"headerlink\" title=\"阶码\"></a>阶码</h4><p>在IEEE274中，指数部分采用的移码方式是阶码，而不是传统的补码，阶码的规则更加简单，就是用 $2^{n-1}-1$ + 实际值就是最终的结果。<br>比如，一个8位的二进制($2^{n-1}-1$ = 127)，表示的数是 39</p>\n<p>实际转码就是 127+39 = 166；</p>\n<p>表示的数是 -56；<br>实际转码就是 127-56 = 71；</p>\n<h2 id=\"一个表示浮点数的工具\"><a href=\"#一个表示浮点数的工具\" class=\"headerlink\" title=\"一个表示浮点数的工具\"></a>一个表示浮点数的工具</h2><p>如代码无法运行请点击<a href=\"https://codepen.io/woowyl/pen/JjbpKzy\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<iframe src=\"https://codepen.io/woowyl/embed/JjbpKzy?height=265&theme-id=light&default-tab=js,result\" width=\"100%\" height=\"400\" frameborder=\"0\" loading=\"lazy\" allowfullscreen></iframe>","site":{"data":{}},"excerpt":"<p>这个问题应该是在浮点数运算里比较常见的问题了，</p>","more":"<p>这次就送三个方面来分析一下这个问题：</p>\n<ul>\n<li>解决方案</li>\n<li>为什么会有这个问题</li>\n<li>一个表示浮点数的工具</li>\n</ul>\n<h2 id=\"常用解决方案\"><a href=\"#常用解决方案\" class=\"headerlink\" title=\"常用解决方案\"></a>常用解决方案</h2><ul>\n<li>将浮点数扩大$10^n$变成整数，进行整数运算</li>\n<li>if判断操作时使用<code>Number.EPSILON</code>可表示(representable)数之间的最小间隔<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0.1</span> + <span class=\"number\">0.2</span> == <span class=\"number\">0.3</span>  <span class=\"comment\">//false</span></span><br><span class=\"line\"><span class=\"number\">0.1</span> + <span class=\"number\">0.2</span> - <span class=\"number\">0.3</span> &lt; <span class=\"built_in\">Number</span>.EPSILON</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"为什么会有这个问题\"><a href=\"#为什么会有这个问题\" class=\"headerlink\" title=\"为什么会有这个问题\"></a>为什么会有这个问题</h2><p>ECMAScript7种常见类型中，Number应该是最令人关注的数据类型了，这种类型使用IEEE754格式来表示整数和浮点数。所以浮点数计算会产生舍入误差的问题，是IEEE754数值的浮点问题，不仅仅存在于javaScript中，也存在于任何一个使用IEEE754标准的语言中。<br>由于计算机存储和计算都是基于二进制，但是我们平时日常使用和编程使用的大都是十进制表示。所以这就存在一个二进制转十进制的问题。0.1+0.2≠0.3的问题就是来源于此。<br>具体来说，在二进制表示十进制整数时并没有什么问题，但是在表示浮点数时，便会出现精度问题。<br>javaScript采用IEEE754标准的双精度64位二进制的形式(单精度采用1+8+23位的二进制表示)。</p>\n<h3 id=\"IEEE754\"><a href=\"#IEEE754\" class=\"headerlink\" title=\"IEEE754\"></a>IEEE754</h3><p>基于 IEEE 754 标准的双精度 64 位二进制格式的值（-($2^{63}$ -1) 到 $2^{63}$ -1）。它并没有为整数给出一种特定的类型。除了能够表示浮点数外，还有一些带符号的值：+Infinity，-Infinity 和 NaN (非数值，Not-a-Number)。<br><img src=\"evernotecid://84FC037D-AE68-4F05-8F7D-A0E8EE6858BD/appyinxiangcom/4074438/ENResource/p596\" alt=\"5e108fa71c8bb159294b8a7e2187518c.png\"></p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>S</th>\n<th>Exp</th>\n<th>Fraction</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>长度</td>\n<td>1</td>\n<td>11</td>\n<td>52位长</td>\n</tr>\n<tr>\n<td>位数</td>\n<td>63</td>\n<td>62至52</td>\n<td>偏正值（实际的指数大小+1023）    51至0位编号（从右边开始为0）</td>\n</tr>\n<tr>\n<td>$1.fraction^{exponent}$</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>- 第0位记录符号位</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>- 1 负数</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>- 0 正数</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>- 第1-11位记录指数偏移值(exponent)</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>- 为了兼容正负数，采用移码中的阶码的方式表示(详见2.5.4)</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<ul>\n<li>第12-63位存储有效位（fraction）</li>\n</ul>\n<h3 id=\"转换步骤\"><a href=\"#转换步骤\" class=\"headerlink\" title=\"转换步骤\"></a>转换步骤</h3><ol>\n<li>将十进制转为二进制表示（误差来自于这个步骤）</li>\n<li>将二进制转换为指数科学计数法 </li>\n<li>将科学计数法采用IEEE754的方式存储于计算机</li>\n</ol>\n<p>举例来说,为了方便说明，我们这里选择 77.1875其小数部分是可以用有限位表示的</p>\n<ol>\n<li><p>将十进制转换为二进制<br>77 =&gt; 1001101<br>0.1875 =&gt; 0.0011<br>77.1875 =&gt; 1001101.0011</p>\n</li>\n<li><p>将二进制转化为指数科学计数法<br>1001101.0011 =&gt; 1.0011010011*$2^6$</p>\n</li>\n<li><p>将科学计数法采用IEEE754的方式存储于计算机</p>\n<ol>\n<li>符号位： + =&gt; 0</li>\n<li>指数偏移量 =&gt; 6+2047 =&gt; 110</li>\n<li>有效位：0011010011</li>\n<li>变为64位表示<code>0 00000000110 0000000000 0000000000 0000000000 0000000000 0000110100 11</code></li>\n</ol>\n</li>\n</ol>\n<p>在日常开发中，将小数部分转化为二进制，常常无法在有限位内转化，所以52位有效位的情况下，从小数点后第一个非0数字开始，之后最多可以保留52位（加上最左边被舍去的1，应该是53位）。</p>\n<h3 id=\"js里的最大整数和浮点数\"><a href=\"#js里的最大整数和浮点数\" class=\"headerlink\" title=\"js里的最大整数和浮点数\"></a>js里的最大整数和浮点数</h3><ul>\n<li>Number.MAX_SAFE_INTEGER<ul>\n<li>JavaScript 中最大的安全整数 ($2^{53}$ - 1)。</li>\n<li>52位二进制表示的最大数就是$2^{53}$ - 1</li>\n</ul>\n</li>\n<li>Number.MAX_VALUE<ul>\n<li>能表示的最大正数。最小的负数是 -MAX_VALUE。</li>\n</ul>\n</li>\n<li>Number.MIN_SAFE_INTEGER<ul>\n<li>JavaScript 中最小的安全整数 (-($2^{53}$ - 1)).</li>\n</ul>\n</li>\n<li>Number.MIN_VALUE<ul>\n<li>能表示的最小正数即最接近 0 的正数 (实际上不会变成 0)。最大的负数是 -MIN_VALUE。</li>\n<li>二进制表示为 0.0000000000000……00001</li>\n<li>根据IEEE754标准，小数点后最多可以出现$2^{11}$</li>\n</ul>\n</li>\n</ul>\n<p>要检查值是否大于或小于 +/-Infinity，你可以使用常量 Number.MAX_VALUE 和 Number.MIN_VALUE。另外在 ECMAScript 6 中，你也可以通过 Number.isSafeInteger() 方法还有 Number.MAX_SAFE_INTEGER 和 Number.MIN_SAFE_INTEGER($2^{53}$-1) 来检查值是否在双精度浮点数的取值范围内。 超出这个范围，JavaScript 中的数字不再安全了，也就是只有 second mathematical interger 可以在 JavaScript 数字类型中正确表现。</p>\n<h3 id=\"js里常见的数据表示法\"><a href=\"#js里常见的数据表示法\" class=\"headerlink\" title=\"js里常见的数据表示法\"></a>js里常见的数据表示法</h3><ul>\n<li>二进制   <ul>\n<li>以0b开头</li>\n<li>0b101  (十进制的5)</li>\n</ul>\n</li>\n<li>八进制<ul>\n<li>以0o开头</li>\n<li>0o101 (十进制的65)</li>\n</ul>\n</li>\n<li>十进制<ul>\n<li>日常编码最常用的进制</li>\n</ul>\n</li>\n<li>十六进制<ul>\n<li>以0x开头</li>\n<li>0x101 (十进制257)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"补码的方式\"><a href=\"#补码的方式\" class=\"headerlink\" title=\"补码的方式\"></a>补码的方式</h3><p><img src=\"evernotecid://84FC037D-AE68-4F05-8F7D-A0E8EE6858BD/appyinxiangcom/4074438/ENResource/p597\" alt=\"521ab6715750440309c4ac2b9b15ec1f.png\"></p>\n<p>负数补码表示的范围比原码稍宽，多一种数码组合。对于定点数，若为纯小数，表示范围为：<br>-1 ~ $1-2^n$。若为纯整数，表示范围为：$-2^n$ ~ $2^n-1$（原码：$-2^n+1$ ~ $2^n-1$）</p>\n<h4 id=\"原码转换补码\"><a href=\"#原码转换补码\" class=\"headerlink\" title=\"原码转换补码\"></a>原码转换补码</h4><p>(以8位二进制为例)</p>\n<ul>\n<li>正整数的补码是其二进制表示，与原码相同 <ul>\n<li>9 =&gt; <code>0000 1001</code></li>\n</ul>\n</li>\n<li>负整数的补码，将其原码除符号位外的所有位取反（0变1，1变0，符号位为1不变）后加1<ul>\n<li>原码 -9 =&gt;<code>1000 1001</code></li>\n<li>取反 <code>1000 1001</code> =&gt; <code>1111 0110</code></li>\n<li>加一 <code>1111 0110</code> =&gt; <code>1111 0111</code></li>\n</ul>\n</li>\n<li>数0的补码表示是唯一的 <ul>\n<li>原码会有<code>+0</code>、<code>-0</code>的问题</li>\n<li><code>0000 0000</code></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"补码转为原码\"><a href=\"#补码转为原码\" class=\"headerlink\" title=\"补码转为原码\"></a>补码转为原码</h4><ul>\n<li>如果补码的符号位为“0”，表示是一个正数，其原码就是补码。</li>\n<li>如果补码的符号位为“1”，表示是一个负数，求这个补码的补码就是原码。<ul>\n<li>取反 <code>1111 0111</code> =&gt; <code>1000 1000</code></li>\n<li>加一 <code>1000 1000</code> =&gt; <code>1000 1001</code></li>\n<li>原码 <code>1000 1001</code> =&gt; <code>-9</code></li>\n</ul>\n</li>\n<li>0是唯一的 <code>0000 0000</code><ul>\n<li>原码的-0 =&gt; <code>1000 0000</code>表示的是什么？来看一下</li>\n</ul>\n<ol>\n<li>取反 <code>1000 0000</code> =&gt; <code>1111 1111</code></li>\n<li>加一 <code>1111 1111</code> =&gt; <code>1000 0000</code></li>\n<li>原码 <code>1000 0000</code> =&gt; <code>-128</code> (符号位也代表了数值)</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"补码的意义\"><a href=\"#补码的意义\" class=\"headerlink\" title=\"补码的意义\"></a>补码的意义</h4><ul>\n<li>解决了符号的表示的问题；</li>\n<li>可以将减法运算转化为补码的加法运算来实现，克服了原码加减法运算繁杂的弊端，可有效简化运算器的设计；<br>  这里需要展开一下，以八位二进制来说，<ul>\n<li>6 和 6 + 128 ($2^8$)的表示是一样的 <code>0000 0110</code></li>\n<li>利用上述的特点就可以将减法操作变为加法操作</li>\n<li>9-3 =&gt; 9-3+128 =&gt; 9+125</li>\n<li>所以将-3转化为125可以简化运算</li>\n<li>这个转化关系就是补码 取反加一</li>\n</ul>\n</li>\n<li>在计算机中，利用电子器件的特点实现补码和真值、原码之间的相互转换，非常容易；</li>\n<li>补码表示统一了符号位和数值位，使得符号位可以和数值位一起直接参与运算，这也为后面设计乘法器除法器等运算器件提供了极大的方便。</li>\n</ul>\n<p>总之，补码概念的引入和当时运算器设计的背景不无关系，从设计者角度，既要考虑表示的数的类型(小数、整数、实数和复数)、数值范围和精确度，又要考虑数据存储和处理所需要的硬件代价。因此，使用补码来表示机器数并得到广泛的应用，也就不难理解了</p>\n<h4 id=\"阶码\"><a href=\"#阶码\" class=\"headerlink\" title=\"阶码\"></a>阶码</h4><p>在IEEE274中，指数部分采用的移码方式是阶码，而不是传统的补码，阶码的规则更加简单，就是用 $2^{n-1}-1$ + 实际值就是最终的结果。<br>比如，一个8位的二进制($2^{n-1}-1$ = 127)，表示的数是 39</p>\n<p>实际转码就是 127+39 = 166；</p>\n<p>表示的数是 -56；<br>实际转码就是 127-56 = 71；</p>\n<h2 id=\"一个表示浮点数的工具\"><a href=\"#一个表示浮点数的工具\" class=\"headerlink\" title=\"一个表示浮点数的工具\"></a>一个表示浮点数的工具</h2><p>如代码无法运行请点击<a href=\"https://codepen.io/woowyl/pen/JjbpKzy\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<iframe src=\"https://codepen.io/woowyl/embed/JjbpKzy?height=265&theme-id=light&default-tab=js,result\" width=\"100%\" height=\"400\" frameborder=\"0\" loading=\"lazy\" allowfullscreen></iframe>"},{"title":"通过hexo搭建个人博客","date":"2016-07-01T04:00:13.000Z","_content":"<!-- more -->\n## 创建一个自己的服务器\n\n### 安装\n\n\n## 常用命令\n","source":"_posts/back-end/nginx.md","raw":"---\ntitle: 通过hexo搭建个人博客\ndate: 2016-07-1 12:00:13\ncategories: back-end\ntags: \n- 服务器配置\n- nginx\n---\n<!-- more -->\n## 创建一个自己的服务器\n\n### 安装\n\n\n## 常用命令\n","slug":"back-end/nginx","published":1,"updated":"2021-03-08T05:25:54.217Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm05nqdu000a2cl29iya8idk","content":"<a id=\"more\"></a>\n<h2 id=\"创建一个自己的服务器\"><a href=\"#创建一个自己的服务器\" class=\"headerlink\" title=\"创建一个自己的服务器\"></a>创建一个自己的服务器</h2><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><h2 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"创建一个自己的服务器\"><a href=\"#创建一个自己的服务器\" class=\"headerlink\" title=\"创建一个自己的服务器\"></a>创建一个自己的服务器</h2><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><h2 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h2>"},{"title":"计算机通用语言","date":"2020-04-21T02:46:09.000Z","_content":"\n## 如何让计算机理解代码\n\n>从最基本的角度看，一种编程语言就是：把一组特定的**词汇**，按照一组特定的**语法**规则组合到一起，形成计算机可以通过某种方式“**理解**”的东西，可以让计算机据此执行特定的**动作**。\n\n这不是一个很容易解释的话题。相比人类，计算机是一个没有感情的机器。没有感情有好也有坏。好处就是你定义好规则，它就会按照你的规则办事。如何制定这个规则，也就是如何设计一门语言。人类有English，中文，日本人，Espanol，عربي， 한국어...。每个语言都有自己的表达规则，计算机语言也不例外。那么如何从无到有设计一套语言呢？在开始设计之前，我们先来理解几个基础词汇。\n\n- 文法 （Grammar）\n- 语法  (Syntax)\n- 词法 （Lexical）\n<!-- more -->\n以人工英汉翻译为例\n![](translate.png)\n\n首先是解析的过程： \n\n当拿到一个句子，我们首先理解了每一个词（词组）的意思（词法分析），然后理解词组组合后的短语（语法分析）。最后将短语组合翻译，变成一个句子的语义（语义分析）。这个语义是中间表示，独立于具体的语言。拿到语义之后你就可以生成目标语言。人类翻译的目标语言可以是“中文”，“韩文”，“法文”等等。具体是哪个形式，由接受人决定，你翻译给谁听，就译成ta理解的形式。而对计算机而言，目标语言就是机器语言。\n\n![](machine_language.png)\n\n知道了这个过程之后，我们就可以继续思考一下，如何取制定一套语言的文法规则。\n\n## 如何设计一套计算机语言\n\n根据我们上面的分析，要想让计算机“读”懂我们的代码，就要有一套固定的语义，语法和词法体系。那么现在我们常用的语言是按照什么规则制定的呢？\n\n### 语法部分\n\n#### 非形式语法\n\n- 中文 英文\n\n#### 形式语法（乔姆斯基谱系）\n\n- O型  无限制文法\n  - `?::=?`\n- 1型  上下文相关文法\n  - `?<A>?::=?<B>`\n- 2型  上下文无关文法\n  - `<A>::=?`\n- 3型  正则文法\n  - `<A>::=<A>？`\n\n其中 **上下文无关语言**为大多数**程序设计语言**的语法提供了理论基础。\n\n在这个理论基础上，有了一些具体的实践。 以BNF为例，BNF是比较常见的一种形式。\n\n### 产生式 巴科斯诺尔范式 (Backus Normal Form —— BNF)\n\n- 用尖括号括起来的名称来表示语法结构名\n- 语法结构分成基础结构和需要用其他语法结构定义的复合结构\n  - 基础结构称终结符\n  - 复合结构称非终结符\n- 引号和中间的字符表示终结符\n- 可以有括号\n- `*` 表示重复多次\n- `|` 表示或\n- `+` 表示至少一次\n\n一个四则运算的BNF凡是\n\n```bash\n<Number> ::= \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | ... | \"9\"\n\n<DecimalNumber> ::= \"0\" | ((\"1\" | \"2\" | \"3\" | \"4\" | ... | \"9\")<Number>*)\n\n<PrimaryExpression> ::= <DecimalNumber> | \"(\" <LogicalExpression> \")\"\n\n<Multiplicative> ::= <PrimaryExpression> |\n                   <Multiplicative> \"*\" <PrimaryExpression> |\n                   <Multiplicative> \"/\" <PrimaryExpression>\n\n<AddtiveExpression> ::= <Multiplicative> |\n                      <AddtiveExpression> \"+\" <Multiplicative> |\n                      <AddtiveExpression> \"-\" <Multiplicative>\n\n\n<logicalExpression> ::= <AddtiveExpression> |\n                      <logicalExpression> \"||\" <AddtiveExpression> |\n                      <logicalExpression> \"&&\" <AddtiveExpression>\n```\n\n### 常见的语言分析\n\n#### JavaScript\n\nJavaScript语法多是上下文无关文法为主。但是也有特殊的情况，比如:\n\n```javascript\n    {\n        get a {return 1},  //在这里get是一个关键字\n        get: 1             //而在这里就是一个变量名\n    }\n```\n\n表达式部分多在3型，正则文法。但也有特殊的情况，\n\n```js\n    2**1**2\n```\n\nJavascript中，`/`可能是除号，也可能是正则表达式开头，处理方式类似VB，字符串模板中也需要特殊处理，还有自动插入分号规则。\n\n#### C++\n\nC++是非形式化语言，C++中，`*`坑你表示乘号或者指针，具体是哪个，取决于星号前面的标识符是否被声明为类型\n\n#### VB\n\nVB基本上是1型。`<`可能是小于号，也可能是XML直接量的开始，取决于当前位置是否可以接受XML直接量。\n\n### Python\n\n行首的Tab符和空格会根据上一行的行首空白以一定规则被处处理成虚拟终结符indent或者dedent\n\n### 其他语言\n\nLisp, C, PHP, JAVA, SQL\n\n## reference\n\n[怎样设计一套程序设计语言？](https://www.zhihu.com/question/19756886)\n[编译原理（哈工大）—— bilibili](https://www.bilibili.com/video/BV1zW411t7YE?from=search&seid=1590568849937040326)","source":"_posts/language/program_language.md","raw":"---\ntitle: 计算机通用语言\ndate: 2020-04-21 10:46:09\ntags: 计算机通识\ncategories: language\n---\n\n## 如何让计算机理解代码\n\n>从最基本的角度看，一种编程语言就是：把一组特定的**词汇**，按照一组特定的**语法**规则组合到一起，形成计算机可以通过某种方式“**理解**”的东西，可以让计算机据此执行特定的**动作**。\n\n这不是一个很容易解释的话题。相比人类，计算机是一个没有感情的机器。没有感情有好也有坏。好处就是你定义好规则，它就会按照你的规则办事。如何制定这个规则，也就是如何设计一门语言。人类有English，中文，日本人，Espanol，عربي， 한국어...。每个语言都有自己的表达规则，计算机语言也不例外。那么如何从无到有设计一套语言呢？在开始设计之前，我们先来理解几个基础词汇。\n\n- 文法 （Grammar）\n- 语法  (Syntax)\n- 词法 （Lexical）\n<!-- more -->\n以人工英汉翻译为例\n![](translate.png)\n\n首先是解析的过程： \n\n当拿到一个句子，我们首先理解了每一个词（词组）的意思（词法分析），然后理解词组组合后的短语（语法分析）。最后将短语组合翻译，变成一个句子的语义（语义分析）。这个语义是中间表示，独立于具体的语言。拿到语义之后你就可以生成目标语言。人类翻译的目标语言可以是“中文”，“韩文”，“法文”等等。具体是哪个形式，由接受人决定，你翻译给谁听，就译成ta理解的形式。而对计算机而言，目标语言就是机器语言。\n\n![](machine_language.png)\n\n知道了这个过程之后，我们就可以继续思考一下，如何取制定一套语言的文法规则。\n\n## 如何设计一套计算机语言\n\n根据我们上面的分析，要想让计算机“读”懂我们的代码，就要有一套固定的语义，语法和词法体系。那么现在我们常用的语言是按照什么规则制定的呢？\n\n### 语法部分\n\n#### 非形式语法\n\n- 中文 英文\n\n#### 形式语法（乔姆斯基谱系）\n\n- O型  无限制文法\n  - `?::=?`\n- 1型  上下文相关文法\n  - `?<A>?::=?<B>`\n- 2型  上下文无关文法\n  - `<A>::=?`\n- 3型  正则文法\n  - `<A>::=<A>？`\n\n其中 **上下文无关语言**为大多数**程序设计语言**的语法提供了理论基础。\n\n在这个理论基础上，有了一些具体的实践。 以BNF为例，BNF是比较常见的一种形式。\n\n### 产生式 巴科斯诺尔范式 (Backus Normal Form —— BNF)\n\n- 用尖括号括起来的名称来表示语法结构名\n- 语法结构分成基础结构和需要用其他语法结构定义的复合结构\n  - 基础结构称终结符\n  - 复合结构称非终结符\n- 引号和中间的字符表示终结符\n- 可以有括号\n- `*` 表示重复多次\n- `|` 表示或\n- `+` 表示至少一次\n\n一个四则运算的BNF凡是\n\n```bash\n<Number> ::= \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | ... | \"9\"\n\n<DecimalNumber> ::= \"0\" | ((\"1\" | \"2\" | \"3\" | \"4\" | ... | \"9\")<Number>*)\n\n<PrimaryExpression> ::= <DecimalNumber> | \"(\" <LogicalExpression> \")\"\n\n<Multiplicative> ::= <PrimaryExpression> |\n                   <Multiplicative> \"*\" <PrimaryExpression> |\n                   <Multiplicative> \"/\" <PrimaryExpression>\n\n<AddtiveExpression> ::= <Multiplicative> |\n                      <AddtiveExpression> \"+\" <Multiplicative> |\n                      <AddtiveExpression> \"-\" <Multiplicative>\n\n\n<logicalExpression> ::= <AddtiveExpression> |\n                      <logicalExpression> \"||\" <AddtiveExpression> |\n                      <logicalExpression> \"&&\" <AddtiveExpression>\n```\n\n### 常见的语言分析\n\n#### JavaScript\n\nJavaScript语法多是上下文无关文法为主。但是也有特殊的情况，比如:\n\n```javascript\n    {\n        get a {return 1},  //在这里get是一个关键字\n        get: 1             //而在这里就是一个变量名\n    }\n```\n\n表达式部分多在3型，正则文法。但也有特殊的情况，\n\n```js\n    2**1**2\n```\n\nJavascript中，`/`可能是除号，也可能是正则表达式开头，处理方式类似VB，字符串模板中也需要特殊处理，还有自动插入分号规则。\n\n#### C++\n\nC++是非形式化语言，C++中，`*`坑你表示乘号或者指针，具体是哪个，取决于星号前面的标识符是否被声明为类型\n\n#### VB\n\nVB基本上是1型。`<`可能是小于号，也可能是XML直接量的开始，取决于当前位置是否可以接受XML直接量。\n\n### Python\n\n行首的Tab符和空格会根据上一行的行首空白以一定规则被处处理成虚拟终结符indent或者dedent\n\n### 其他语言\n\nLisp, C, PHP, JAVA, SQL\n\n## reference\n\n[怎样设计一套程序设计语言？](https://www.zhihu.com/question/19756886)\n[编译原理（哈工大）—— bilibili](https://www.bilibili.com/video/BV1zW411t7YE?from=search&seid=1590568849937040326)","slug":"language/program_language","published":1,"updated":"2021-03-08T03:28:26.555Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm05nqdw000c2cl2bcu76h1c","content":"<h2 id=\"如何让计算机理解代码\"><a href=\"#如何让计算机理解代码\" class=\"headerlink\" title=\"如何让计算机理解代码\"></a>如何让计算机理解代码</h2><blockquote>\n<p>从最基本的角度看，一种编程语言就是：把一组特定的<strong>词汇</strong>，按照一组特定的<strong>语法</strong>规则组合到一起，形成计算机可以通过某种方式“<strong>理解</strong>”的东西，可以让计算机据此执行特定的<strong>动作</strong>。</p>\n</blockquote>\n<p>这不是一个很容易解释的话题。相比人类，计算机是一个没有感情的机器。没有感情有好也有坏。好处就是你定义好规则，它就会按照你的规则办事。如何制定这个规则，也就是如何设计一门语言。人类有English，中文，日本人，Espanol，عربي， 한국어…。每个语言都有自己的表达规则，计算机语言也不例外。那么如何从无到有设计一套语言呢？在开始设计之前，我们先来理解几个基础词汇。</p>\n<ul>\n<li>文法 （Grammar）</li>\n<li>语法  (Syntax)</li>\n<li>词法 （Lexical）<a id=\"more\"></a>\n以人工英汉翻译为例<br><img src=\"translate.png\" alt=\"\"></li>\n</ul>\n<p>首先是解析的过程： </p>\n<p>当拿到一个句子，我们首先理解了每一个词（词组）的意思（词法分析），然后理解词组组合后的短语（语法分析）。最后将短语组合翻译，变成一个句子的语义（语义分析）。这个语义是中间表示，独立于具体的语言。拿到语义之后你就可以生成目标语言。人类翻译的目标语言可以是“中文”，“韩文”，“法文”等等。具体是哪个形式，由接受人决定，你翻译给谁听，就译成ta理解的形式。而对计算机而言，目标语言就是机器语言。</p>\n<p><img src=\"machine_language.png\" alt=\"\"></p>\n<p>知道了这个过程之后，我们就可以继续思考一下，如何取制定一套语言的文法规则。</p>\n<h2 id=\"如何设计一套计算机语言\"><a href=\"#如何设计一套计算机语言\" class=\"headerlink\" title=\"如何设计一套计算机语言\"></a>如何设计一套计算机语言</h2><p>根据我们上面的分析，要想让计算机“读”懂我们的代码，就要有一套固定的语义，语法和词法体系。那么现在我们常用的语言是按照什么规则制定的呢？</p>\n<h3 id=\"语法部分\"><a href=\"#语法部分\" class=\"headerlink\" title=\"语法部分\"></a>语法部分</h3><h4 id=\"非形式语法\"><a href=\"#非形式语法\" class=\"headerlink\" title=\"非形式语法\"></a>非形式语法</h4><ul>\n<li>中文 英文</li>\n</ul>\n<h4 id=\"形式语法（乔姆斯基谱系）\"><a href=\"#形式语法（乔姆斯基谱系）\" class=\"headerlink\" title=\"形式语法（乔姆斯基谱系）\"></a>形式语法（乔姆斯基谱系）</h4><ul>\n<li>O型  无限制文法<ul>\n<li><code>?::=?</code></li>\n</ul>\n</li>\n<li>1型  上下文相关文法<ul>\n<li><code>?&lt;A&gt;?::=?&lt;B&gt;</code></li>\n</ul>\n</li>\n<li>2型  上下文无关文法<ul>\n<li><code>&lt;A&gt;::=?</code></li>\n</ul>\n</li>\n<li>3型  正则文法<ul>\n<li><code>&lt;A&gt;::=&lt;A&gt;？</code></li>\n</ul>\n</li>\n</ul>\n<p>其中 <strong>上下文无关语言</strong>为大多数<strong>程序设计语言</strong>的语法提供了理论基础。</p>\n<p>在这个理论基础上，有了一些具体的实践。 以BNF为例，BNF是比较常见的一种形式。</p>\n<h3 id=\"产生式-巴科斯诺尔范式-Backus-Normal-Form-——-BNF\"><a href=\"#产生式-巴科斯诺尔范式-Backus-Normal-Form-——-BNF\" class=\"headerlink\" title=\"产生式 巴科斯诺尔范式 (Backus Normal Form —— BNF)\"></a>产生式 巴科斯诺尔范式 (Backus Normal Form —— BNF)</h3><ul>\n<li>用尖括号括起来的名称来表示语法结构名</li>\n<li>语法结构分成基础结构和需要用其他语法结构定义的复合结构<ul>\n<li>基础结构称终结符</li>\n<li>复合结构称非终结符</li>\n</ul>\n</li>\n<li>引号和中间的字符表示终结符</li>\n<li>可以有括号</li>\n<li><code>*</code> 表示重复多次</li>\n<li><code>|</code> 表示或</li>\n<li><code>+</code> 表示至少一次</li>\n</ul>\n<p>一个四则运算的BNF凡是</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Number&gt; ::= <span class=\"string\">\"0\"</span> | <span class=\"string\">\"1\"</span> | <span class=\"string\">\"2\"</span> | <span class=\"string\">\"3\"</span> | <span class=\"string\">\"4\"</span> | ... | <span class=\"string\">\"9\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;DecimalNumber&gt; ::= <span class=\"string\">\"0\"</span> | ((<span class=\"string\">\"1\"</span> | <span class=\"string\">\"2\"</span> | <span class=\"string\">\"3\"</span> | <span class=\"string\">\"4\"</span> | ... | <span class=\"string\">\"9\"</span>)&lt;Number&gt;*)</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;PrimaryExpression&gt; ::= &lt;DecimalNumber&gt; | <span class=\"string\">\"(\"</span> &lt;LogicalExpression&gt; <span class=\"string\">\")\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;Multiplicative&gt; ::= &lt;PrimaryExpression&gt; |</span><br><span class=\"line\">                   &lt;Multiplicative&gt; <span class=\"string\">\"*\"</span> &lt;PrimaryExpression&gt; |</span><br><span class=\"line\">                   &lt;Multiplicative&gt; <span class=\"string\">\"/\"</span> &lt;PrimaryExpression&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;AddtiveExpression&gt; ::= &lt;Multiplicative&gt; |</span><br><span class=\"line\">                      &lt;AddtiveExpression&gt; <span class=\"string\">\"+\"</span> &lt;Multiplicative&gt; |</span><br><span class=\"line\">                      &lt;AddtiveExpression&gt; <span class=\"string\">\"-\"</span> &lt;Multiplicative&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;logicalExpression&gt; ::= &lt;AddtiveExpression&gt; |</span><br><span class=\"line\">                      &lt;logicalExpression&gt; <span class=\"string\">\"||\"</span> &lt;AddtiveExpression&gt; |</span><br><span class=\"line\">                      &lt;logicalExpression&gt; <span class=\"string\">\"&amp;&amp;\"</span> &lt;AddtiveExpression&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"常见的语言分析\"><a href=\"#常见的语言分析\" class=\"headerlink\" title=\"常见的语言分析\"></a>常见的语言分析</h3><h4 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h4><p>JavaScript语法多是上下文无关文法为主。但是也有特殊的情况，比如:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> a &#123;<span class=\"keyword\">return</span> <span class=\"number\">1</span>&#125;,  <span class=\"comment\">//在这里get是一个关键字</span></span><br><span class=\"line\">    <span class=\"keyword\">get</span>: 1             //而在这里就是一个变量名</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>表达式部分多在3型，正则文法。但也有特殊的情况，</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2</span>**<span class=\"number\">1</span>**<span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<p>Javascript中，<code>/</code>可能是除号，也可能是正则表达式开头，处理方式类似VB，字符串模板中也需要特殊处理，还有自动插入分号规则。</p>\n<h4 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C++\"></a>C++</h4><p>C++是非形式化语言，C++中，<code>*</code>坑你表示乘号或者指针，具体是哪个，取决于星号前面的标识符是否被声明为类型</p>\n<h4 id=\"VB\"><a href=\"#VB\" class=\"headerlink\" title=\"VB\"></a>VB</h4><p>VB基本上是1型。<code>&lt;</code>可能是小于号，也可能是XML直接量的开始，取决于当前位置是否可以接受XML直接量。</p>\n<h3 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h3><p>行首的Tab符和空格会根据上一行的行首空白以一定规则被处处理成虚拟终结符indent或者dedent</p>\n<h3 id=\"其他语言\"><a href=\"#其他语言\" class=\"headerlink\" title=\"其他语言\"></a>其他语言</h3><p>Lisp, C, PHP, JAVA, SQL</p>\n<h2 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h2><p><a href=\"https://www.zhihu.com/question/19756886\" target=\"_blank\" rel=\"noopener\">怎样设计一套程序设计语言？</a><br><a href=\"https://www.bilibili.com/video/BV1zW411t7YE?from=search&seid=1590568849937040326\" target=\"_blank\" rel=\"noopener\">编译原理（哈工大）—— bilibili</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"如何让计算机理解代码\"><a href=\"#如何让计算机理解代码\" class=\"headerlink\" title=\"如何让计算机理解代码\"></a>如何让计算机理解代码</h2><blockquote>\n<p>从最基本的角度看，一种编程语言就是：把一组特定的<strong>词汇</strong>，按照一组特定的<strong>语法</strong>规则组合到一起，形成计算机可以通过某种方式“<strong>理解</strong>”的东西，可以让计算机据此执行特定的<strong>动作</strong>。</p>\n</blockquote>\n<p>这不是一个很容易解释的话题。相比人类，计算机是一个没有感情的机器。没有感情有好也有坏。好处就是你定义好规则，它就会按照你的规则办事。如何制定这个规则，也就是如何设计一门语言。人类有English，中文，日本人，Espanol，عربي， 한국어…。每个语言都有自己的表达规则，计算机语言也不例外。那么如何从无到有设计一套语言呢？在开始设计之前，我们先来理解几个基础词汇。</p>\n<ul>\n<li>文法 （Grammar）</li>\n<li>语法  (Syntax)</li>\n<li>词法 （Lexical）","more":"以人工英汉翻译为例<br><img src=\"translate.png\" alt=\"\"></li>\n</ul>\n<p>首先是解析的过程： </p>\n<p>当拿到一个句子，我们首先理解了每一个词（词组）的意思（词法分析），然后理解词组组合后的短语（语法分析）。最后将短语组合翻译，变成一个句子的语义（语义分析）。这个语义是中间表示，独立于具体的语言。拿到语义之后你就可以生成目标语言。人类翻译的目标语言可以是“中文”，“韩文”，“法文”等等。具体是哪个形式，由接受人决定，你翻译给谁听，就译成ta理解的形式。而对计算机而言，目标语言就是机器语言。</p>\n<p><img src=\"machine_language.png\" alt=\"\"></p>\n<p>知道了这个过程之后，我们就可以继续思考一下，如何取制定一套语言的文法规则。</p>\n<h2 id=\"如何设计一套计算机语言\"><a href=\"#如何设计一套计算机语言\" class=\"headerlink\" title=\"如何设计一套计算机语言\"></a>如何设计一套计算机语言</h2><p>根据我们上面的分析，要想让计算机“读”懂我们的代码，就要有一套固定的语义，语法和词法体系。那么现在我们常用的语言是按照什么规则制定的呢？</p>\n<h3 id=\"语法部分\"><a href=\"#语法部分\" class=\"headerlink\" title=\"语法部分\"></a>语法部分</h3><h4 id=\"非形式语法\"><a href=\"#非形式语法\" class=\"headerlink\" title=\"非形式语法\"></a>非形式语法</h4><ul>\n<li>中文 英文</li>\n</ul>\n<h4 id=\"形式语法（乔姆斯基谱系）\"><a href=\"#形式语法（乔姆斯基谱系）\" class=\"headerlink\" title=\"形式语法（乔姆斯基谱系）\"></a>形式语法（乔姆斯基谱系）</h4><ul>\n<li>O型  无限制文法<ul>\n<li><code>?::=?</code></li>\n</ul>\n</li>\n<li>1型  上下文相关文法<ul>\n<li><code>?&lt;A&gt;?::=?&lt;B&gt;</code></li>\n</ul>\n</li>\n<li>2型  上下文无关文法<ul>\n<li><code>&lt;A&gt;::=?</code></li>\n</ul>\n</li>\n<li>3型  正则文法<ul>\n<li><code>&lt;A&gt;::=&lt;A&gt;？</code></li>\n</ul>\n</li>\n</ul>\n<p>其中 <strong>上下文无关语言</strong>为大多数<strong>程序设计语言</strong>的语法提供了理论基础。</p>\n<p>在这个理论基础上，有了一些具体的实践。 以BNF为例，BNF是比较常见的一种形式。</p>\n<h3 id=\"产生式-巴科斯诺尔范式-Backus-Normal-Form-——-BNF\"><a href=\"#产生式-巴科斯诺尔范式-Backus-Normal-Form-——-BNF\" class=\"headerlink\" title=\"产生式 巴科斯诺尔范式 (Backus Normal Form —— BNF)\"></a>产生式 巴科斯诺尔范式 (Backus Normal Form —— BNF)</h3><ul>\n<li>用尖括号括起来的名称来表示语法结构名</li>\n<li>语法结构分成基础结构和需要用其他语法结构定义的复合结构<ul>\n<li>基础结构称终结符</li>\n<li>复合结构称非终结符</li>\n</ul>\n</li>\n<li>引号和中间的字符表示终结符</li>\n<li>可以有括号</li>\n<li><code>*</code> 表示重复多次</li>\n<li><code>|</code> 表示或</li>\n<li><code>+</code> 表示至少一次</li>\n</ul>\n<p>一个四则运算的BNF凡是</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Number&gt; ::= <span class=\"string\">\"0\"</span> | <span class=\"string\">\"1\"</span> | <span class=\"string\">\"2\"</span> | <span class=\"string\">\"3\"</span> | <span class=\"string\">\"4\"</span> | ... | <span class=\"string\">\"9\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;DecimalNumber&gt; ::= <span class=\"string\">\"0\"</span> | ((<span class=\"string\">\"1\"</span> | <span class=\"string\">\"2\"</span> | <span class=\"string\">\"3\"</span> | <span class=\"string\">\"4\"</span> | ... | <span class=\"string\">\"9\"</span>)&lt;Number&gt;*)</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;PrimaryExpression&gt; ::= &lt;DecimalNumber&gt; | <span class=\"string\">\"(\"</span> &lt;LogicalExpression&gt; <span class=\"string\">\")\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;Multiplicative&gt; ::= &lt;PrimaryExpression&gt; |</span><br><span class=\"line\">                   &lt;Multiplicative&gt; <span class=\"string\">\"*\"</span> &lt;PrimaryExpression&gt; |</span><br><span class=\"line\">                   &lt;Multiplicative&gt; <span class=\"string\">\"/\"</span> &lt;PrimaryExpression&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;AddtiveExpression&gt; ::= &lt;Multiplicative&gt; |</span><br><span class=\"line\">                      &lt;AddtiveExpression&gt; <span class=\"string\">\"+\"</span> &lt;Multiplicative&gt; |</span><br><span class=\"line\">                      &lt;AddtiveExpression&gt; <span class=\"string\">\"-\"</span> &lt;Multiplicative&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;logicalExpression&gt; ::= &lt;AddtiveExpression&gt; |</span><br><span class=\"line\">                      &lt;logicalExpression&gt; <span class=\"string\">\"||\"</span> &lt;AddtiveExpression&gt; |</span><br><span class=\"line\">                      &lt;logicalExpression&gt; <span class=\"string\">\"&amp;&amp;\"</span> &lt;AddtiveExpression&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"常见的语言分析\"><a href=\"#常见的语言分析\" class=\"headerlink\" title=\"常见的语言分析\"></a>常见的语言分析</h3><h4 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h4><p>JavaScript语法多是上下文无关文法为主。但是也有特殊的情况，比如:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> a &#123;<span class=\"keyword\">return</span> <span class=\"number\">1</span>&#125;,  <span class=\"comment\">//在这里get是一个关键字</span></span><br><span class=\"line\">    <span class=\"keyword\">get</span>: 1             //而在这里就是一个变量名</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>表达式部分多在3型，正则文法。但也有特殊的情况，</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2</span>**<span class=\"number\">1</span>**<span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<p>Javascript中，<code>/</code>可能是除号，也可能是正则表达式开头，处理方式类似VB，字符串模板中也需要特殊处理，还有自动插入分号规则。</p>\n<h4 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C++\"></a>C++</h4><p>C++是非形式化语言，C++中，<code>*</code>坑你表示乘号或者指针，具体是哪个，取决于星号前面的标识符是否被声明为类型</p>\n<h4 id=\"VB\"><a href=\"#VB\" class=\"headerlink\" title=\"VB\"></a>VB</h4><p>VB基本上是1型。<code>&lt;</code>可能是小于号，也可能是XML直接量的开始，取决于当前位置是否可以接受XML直接量。</p>\n<h3 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h3><p>行首的Tab符和空格会根据上一行的行首空白以一定规则被处处理成虚拟终结符indent或者dedent</p>\n<h3 id=\"其他语言\"><a href=\"#其他语言\" class=\"headerlink\" title=\"其他语言\"></a>其他语言</h3><p>Lisp, C, PHP, JAVA, SQL</p>\n<h2 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h2><p><a href=\"https://www.zhihu.com/question/19756886\" target=\"_blank\" rel=\"noopener\">怎样设计一套程序设计语言？</a><br><a href=\"https://www.bilibili.com/video/BV1zW411t7YE?from=search&seid=1590568849937040326\" target=\"_blank\" rel=\"noopener\">编译原理（哈工大）—— bilibili</a></p>"},{"title":"计算机编码","date":"2020-04-21T02:00:05.000Z","_content":"\n\n## 编码\n\n我们计算机只能读懂01这两个字符，这和我们人类平时对文字的使用很不相同。如何在计算机里存储和表示文字，就涉及到了编码的知识。\n\n计算机有哪些编码方式呢？\n\n## ASCII 码\n\n我们知道，计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从00000000到11111111。\n<!-- more -->\n\n上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。\n\nASCII 码一共规定了128个字符的编码，比如空格SPACE是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为0。\n\n这种编码方式完成了基础的编码，但是随着计算机的普及，我们需要在计算机里表示除了英文之外的内容，这128个字符显然是不够的。比如现在的这篇博客，里面的中文字符是如何表示的呢？除了中文，还有其他各国的语言字符，法文、希腊文、西班牙文...等等这些语言，需要大量的编码位置。\n\n## Unicode\n\n正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。\n\n可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是 Unicode，就像它的名字都表示的，这是一种所有符号的编码。\n\nUnicode 当然是一个很大的集合，现在的规模可以容纳100多万个符号。Unicode定义了我们所能想到字符的二进制表示，可以说是很全面了。但是如何存储存储这些二进制呢？\n\n直接存储？这是简单暴力的做法，因为在Unicode编码里`a`对应的码点是`97`，Unicode编码是`U+0061`，二进制表示为`1100001`， 中文`远`字的码点是`36828`，Unicode编码为`U+8FDC`,二进制表示为`1000111111011100`。`a`只需要7个bit位，而`远`却需要16个bit位。如果只用一个字节（8bit）显然是无法表示汉字`远`的，但是如果用两个字节（16bit）那么在表示`a`的时候前面要多出9个0，这无疑造成了空间上很大的浪费。\n\n有了Unicode编码方式之后，还要想一个规则去保存这些字符。`UTF-8`、`UTF-16`、`UTF-32`便是我们最常见的规则。\n\nUnicode只是一个符号集，而`UTF-8`、`UTF-16`、`UTF-32`是Unicode在计算机中的具体实现。不过在互联网中最最常用的还是`UTF-8`。\n\nUnicode的学名是\"Universal Multiple-Octet Coded Character Set\"，简称为UCS。UCS可以看作是\"Unicode Character Set\"的缩写。\n\nUTF是“UCS Transformation Format”的缩写。‘8’是指用8位的bit块去表示一个字符。表示一个字符所需的字符块从1-4不等。\n\n### UTF-8\n\nUTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。\n\nUTF-8 的编码规则很简单，只有二条：\n\n1. 对于单字节的符号且小于7位的编码，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。\n\n2. 对于大于7bit的编码，n字节的符号1字节按2字节来算（n > 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。\n\n|1st byte|2nd byte|3rd byte|4th byte| 可用于表示字符的bit位个数|最大表示的Unicode 编码值|\n|:---:|:---:|:---|:---|:---|:---|\n|0xxx xxxx|         |         |         |    7       |007F hex(127)        |\n|110x xxxx|10xx xxxx|         |         |(5+6)=11    |07FF hex(2047)       |\n|1110 xxxx|10xx xxxx|10xx xxxx|         |(4+6+6)=16  |FFFF hex(65535)      |\n|1111 0xxx|10xx xxxx|10xx xxxx|10xx xxxx|(3+6+6+6)=21|10FFFF hex(1,114,111)|\n\n注：目前Unicode的编码最大为10FFFF。\n\n这个规则已经定义好，如何根据Unicode编码，得出对应的UTF-8编码呢，来写一个JavaScript的程序来实现一下吧！\n\n### Unicode 与 UTF-8 之间的转换\n\n如代码无法运行请点击[这里](https://codepen.io/woowyl/pen/oNjdNxz)\n\n{% iframe https://codepen.io/woowyl/embed/oNjdNxz?height=807&theme-id=dark&default-tab=js,result 100% 400 %}\n\n### BMP （Basic Multilingual Plane）\n\nUnicode 从`U+0000`到`U+FFFF`这个范围称为BMP,我们日常编码应该让代码保持在这个范围内。\n\n## 其他编码方式\n\n除了上述两种我们最最常接触的编码方式外，还有其他好多编码方式：\n早期的计算机使用7位的ASCII编码，为了处理汉字，程序员设计了用于简体中文的GB2312和用于繁体中文的big5。\n\n- GB2312  \n    GB2312(1980年)一共收录了7445个字符，包括6763个汉字和682个其它符号。汉字区的内码范围高字节从B0-F7，低字节从A1-FE，占用的码位是72*94=6768。其中有5个空位是D7FA-D7FE。\n\n    GB2312支持的汉字太少。1995年的汉字扩展规范GBK1.0收录了21886个符号，它分为汉字区和图形符号区。汉字区包括21003个字符。\n- GBK\n\n\n## Reference\n\n[unicode官网](https://home.unicode.org/)  \n[unicode format](https://www.fileformat.info/info/unicode/)  \n[UTF-8 的规则](https://www.fileformat.info/info/unicode/utf8.htm)  \n[字符编码笔记：ASCII，Unicode 和 UTF-8](http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)","source":"_posts/language/charset.md","raw":"---\ntitle: 计算机编码\ndate: 2020-04-21 10:00:05\ntags: 计算机通识\ncategories: language\n---\n\n\n## 编码\n\n我们计算机只能读懂01这两个字符，这和我们人类平时对文字的使用很不相同。如何在计算机里存储和表示文字，就涉及到了编码的知识。\n\n计算机有哪些编码方式呢？\n\n## ASCII 码\n\n我们知道，计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从00000000到11111111。\n<!-- more -->\n\n上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。\n\nASCII 码一共规定了128个字符的编码，比如空格SPACE是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为0。\n\n这种编码方式完成了基础的编码，但是随着计算机的普及，我们需要在计算机里表示除了英文之外的内容，这128个字符显然是不够的。比如现在的这篇博客，里面的中文字符是如何表示的呢？除了中文，还有其他各国的语言字符，法文、希腊文、西班牙文...等等这些语言，需要大量的编码位置。\n\n## Unicode\n\n正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。\n\n可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是 Unicode，就像它的名字都表示的，这是一种所有符号的编码。\n\nUnicode 当然是一个很大的集合，现在的规模可以容纳100多万个符号。Unicode定义了我们所能想到字符的二进制表示，可以说是很全面了。但是如何存储存储这些二进制呢？\n\n直接存储？这是简单暴力的做法，因为在Unicode编码里`a`对应的码点是`97`，Unicode编码是`U+0061`，二进制表示为`1100001`， 中文`远`字的码点是`36828`，Unicode编码为`U+8FDC`,二进制表示为`1000111111011100`。`a`只需要7个bit位，而`远`却需要16个bit位。如果只用一个字节（8bit）显然是无法表示汉字`远`的，但是如果用两个字节（16bit）那么在表示`a`的时候前面要多出9个0，这无疑造成了空间上很大的浪费。\n\n有了Unicode编码方式之后，还要想一个规则去保存这些字符。`UTF-8`、`UTF-16`、`UTF-32`便是我们最常见的规则。\n\nUnicode只是一个符号集，而`UTF-8`、`UTF-16`、`UTF-32`是Unicode在计算机中的具体实现。不过在互联网中最最常用的还是`UTF-8`。\n\nUnicode的学名是\"Universal Multiple-Octet Coded Character Set\"，简称为UCS。UCS可以看作是\"Unicode Character Set\"的缩写。\n\nUTF是“UCS Transformation Format”的缩写。‘8’是指用8位的bit块去表示一个字符。表示一个字符所需的字符块从1-4不等。\n\n### UTF-8\n\nUTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。\n\nUTF-8 的编码规则很简单，只有二条：\n\n1. 对于单字节的符号且小于7位的编码，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。\n\n2. 对于大于7bit的编码，n字节的符号1字节按2字节来算（n > 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。\n\n|1st byte|2nd byte|3rd byte|4th byte| 可用于表示字符的bit位个数|最大表示的Unicode 编码值|\n|:---:|:---:|:---|:---|:---|:---|\n|0xxx xxxx|         |         |         |    7       |007F hex(127)        |\n|110x xxxx|10xx xxxx|         |         |(5+6)=11    |07FF hex(2047)       |\n|1110 xxxx|10xx xxxx|10xx xxxx|         |(4+6+6)=16  |FFFF hex(65535)      |\n|1111 0xxx|10xx xxxx|10xx xxxx|10xx xxxx|(3+6+6+6)=21|10FFFF hex(1,114,111)|\n\n注：目前Unicode的编码最大为10FFFF。\n\n这个规则已经定义好，如何根据Unicode编码，得出对应的UTF-8编码呢，来写一个JavaScript的程序来实现一下吧！\n\n### Unicode 与 UTF-8 之间的转换\n\n如代码无法运行请点击[这里](https://codepen.io/woowyl/pen/oNjdNxz)\n\n{% iframe https://codepen.io/woowyl/embed/oNjdNxz?height=807&theme-id=dark&default-tab=js,result 100% 400 %}\n\n### BMP （Basic Multilingual Plane）\n\nUnicode 从`U+0000`到`U+FFFF`这个范围称为BMP,我们日常编码应该让代码保持在这个范围内。\n\n## 其他编码方式\n\n除了上述两种我们最最常接触的编码方式外，还有其他好多编码方式：\n早期的计算机使用7位的ASCII编码，为了处理汉字，程序员设计了用于简体中文的GB2312和用于繁体中文的big5。\n\n- GB2312  \n    GB2312(1980年)一共收录了7445个字符，包括6763个汉字和682个其它符号。汉字区的内码范围高字节从B0-F7，低字节从A1-FE，占用的码位是72*94=6768。其中有5个空位是D7FA-D7FE。\n\n    GB2312支持的汉字太少。1995年的汉字扩展规范GBK1.0收录了21886个符号，它分为汉字区和图形符号区。汉字区包括21003个字符。\n- GBK\n\n\n## Reference\n\n[unicode官网](https://home.unicode.org/)  \n[unicode format](https://www.fileformat.info/info/unicode/)  \n[UTF-8 的规则](https://www.fileformat.info/info/unicode/utf8.htm)  \n[字符编码笔记：ASCII，Unicode 和 UTF-8](http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)","slug":"language/charset","published":1,"updated":"2021-03-08T03:29:43.706Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm05nqdy000d2cl2d2rq1n1l","content":"<h2 id=\"编码\"><a href=\"#编码\" class=\"headerlink\" title=\"编码\"></a>编码</h2><p>我们计算机只能读懂01这两个字符，这和我们人类平时对文字的使用很不相同。如何在计算机里存储和表示文字，就涉及到了编码的知识。</p>\n<p>计算机有哪些编码方式呢？</p>\n<h2 id=\"ASCII-码\"><a href=\"#ASCII-码\" class=\"headerlink\" title=\"ASCII 码\"></a>ASCII 码</h2><p>我们知道，计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从00000000到11111111。</p>\n<a id=\"more\"></a>\n\n<p>上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。</p>\n<p>ASCII 码一共规定了128个字符的编码，比如空格SPACE是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为0。</p>\n<p>这种编码方式完成了基础的编码，但是随着计算机的普及，我们需要在计算机里表示除了英文之外的内容，这128个字符显然是不够的。比如现在的这篇博客，里面的中文字符是如何表示的呢？除了中文，还有其他各国的语言字符，法文、希腊文、西班牙文…等等这些语言，需要大量的编码位置。</p>\n<h2 id=\"Unicode\"><a href=\"#Unicode\" class=\"headerlink\" title=\"Unicode\"></a>Unicode</h2><p>正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。</p>\n<p>可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是 Unicode，就像它的名字都表示的，这是一种所有符号的编码。</p>\n<p>Unicode 当然是一个很大的集合，现在的规模可以容纳100多万个符号。Unicode定义了我们所能想到字符的二进制表示，可以说是很全面了。但是如何存储存储这些二进制呢？</p>\n<p>直接存储？这是简单暴力的做法，因为在Unicode编码里<code>a</code>对应的码点是<code>97</code>，Unicode编码是<code>U+0061</code>，二进制表示为<code>1100001</code>， 中文<code>远</code>字的码点是<code>36828</code>，Unicode编码为<code>U+8FDC</code>,二进制表示为<code>1000111111011100</code>。<code>a</code>只需要7个bit位，而<code>远</code>却需要16个bit位。如果只用一个字节（8bit）显然是无法表示汉字<code>远</code>的，但是如果用两个字节（16bit）那么在表示<code>a</code>的时候前面要多出9个0，这无疑造成了空间上很大的浪费。</p>\n<p>有了Unicode编码方式之后，还要想一个规则去保存这些字符。<code>UTF-8</code>、<code>UTF-16</code>、<code>UTF-32</code>便是我们最常见的规则。</p>\n<p>Unicode只是一个符号集，而<code>UTF-8</code>、<code>UTF-16</code>、<code>UTF-32</code>是Unicode在计算机中的具体实现。不过在互联网中最最常用的还是<code>UTF-8</code>。</p>\n<p>Unicode的学名是”Universal Multiple-Octet Coded Character Set”，简称为UCS。UCS可以看作是”Unicode Character Set”的缩写。</p>\n<p>UTF是“UCS Transformation Format”的缩写。‘8’是指用8位的bit块去表示一个字符。表示一个字符所需的字符块从1-4不等。</p>\n<h3 id=\"UTF-8\"><a href=\"#UTF-8\" class=\"headerlink\" title=\"UTF-8\"></a>UTF-8</h3><p>UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</p>\n<p>UTF-8 的编码规则很简单，只有二条：</p>\n<ol>\n<li><p>对于单字节的符号且小于7位的编码，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。</p>\n</li>\n<li><p>对于大于7bit的编码，n字节的符号1字节按2字节来算（n &gt; 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"center\">1st byte</th>\n<th align=\"center\">2nd byte</th>\n<th align=\"left\">3rd byte</th>\n<th align=\"left\">4th byte</th>\n<th align=\"left\">可用于表示字符的bit位个数</th>\n<th align=\"left\">最大表示的Unicode 编码值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">0xxx xxxx</td>\n<td align=\"center\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">7</td>\n<td align=\"left\">007F hex(127)</td>\n</tr>\n<tr>\n<td align=\"center\">110x xxxx</td>\n<td align=\"center\">10xx xxxx</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">(5+6)=11</td>\n<td align=\"left\">07FF hex(2047)</td>\n</tr>\n<tr>\n<td align=\"center\">1110 xxxx</td>\n<td align=\"center\">10xx xxxx</td>\n<td align=\"left\">10xx xxxx</td>\n<td align=\"left\"></td>\n<td align=\"left\">(4+6+6)=16</td>\n<td align=\"left\">FFFF hex(65535)</td>\n</tr>\n<tr>\n<td align=\"center\">1111 0xxx</td>\n<td align=\"center\">10xx xxxx</td>\n<td align=\"left\">10xx xxxx</td>\n<td align=\"left\">10xx xxxx</td>\n<td align=\"left\">(3+6+6+6)=21</td>\n<td align=\"left\">10FFFF hex(1,114,111)</td>\n</tr>\n</tbody></table>\n<p>注：目前Unicode的编码最大为10FFFF。</p>\n<p>这个规则已经定义好，如何根据Unicode编码，得出对应的UTF-8编码呢，来写一个JavaScript的程序来实现一下吧！</p>\n<h3 id=\"Unicode-与-UTF-8-之间的转换\"><a href=\"#Unicode-与-UTF-8-之间的转换\" class=\"headerlink\" title=\"Unicode 与 UTF-8 之间的转换\"></a>Unicode 与 UTF-8 之间的转换</h3><p>如代码无法运行请点击<a href=\"https://codepen.io/woowyl/pen/oNjdNxz\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<iframe src=\"https://codepen.io/woowyl/embed/oNjdNxz?height=807&theme-id=dark&default-tab=js,result\" width=\"100%\" height=\"400\" frameborder=\"0\" loading=\"lazy\" allowfullscreen></iframe>\n\n<h3 id=\"BMP-（Basic-Multilingual-Plane）\"><a href=\"#BMP-（Basic-Multilingual-Plane）\" class=\"headerlink\" title=\"BMP （Basic Multilingual Plane）\"></a>BMP （Basic Multilingual Plane）</h3><p>Unicode 从<code>U+0000</code>到<code>U+FFFF</code>这个范围称为BMP,我们日常编码应该让代码保持在这个范围内。</p>\n<h2 id=\"其他编码方式\"><a href=\"#其他编码方式\" class=\"headerlink\" title=\"其他编码方式\"></a>其他编码方式</h2><p>除了上述两种我们最最常接触的编码方式外，还有其他好多编码方式：<br>早期的计算机使用7位的ASCII编码，为了处理汉字，程序员设计了用于简体中文的GB2312和用于繁体中文的big5。</p>\n<ul>\n<li><p>GB2312<br>  GB2312(1980年)一共收录了7445个字符，包括6763个汉字和682个其它符号。汉字区的内码范围高字节从B0-F7，低字节从A1-FE，占用的码位是72*94=6768。其中有5个空位是D7FA-D7FE。</p>\n<p>  GB2312支持的汉字太少。1995年的汉字扩展规范GBK1.0收录了21886个符号，它分为汉字区和图形符号区。汉字区包括21003个字符。</p>\n</li>\n<li><p>GBK</p>\n</li>\n</ul>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://home.unicode.org/\" target=\"_blank\" rel=\"noopener\">unicode官网</a><br><a href=\"https://www.fileformat.info/info/unicode/\" target=\"_blank\" rel=\"noopener\">unicode format</a><br><a href=\"https://www.fileformat.info/info/unicode/utf8.htm\" target=\"_blank\" rel=\"noopener\">UTF-8 的规则</a><br><a href=\"http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html\" target=\"_blank\" rel=\"noopener\">字符编码笔记：ASCII，Unicode 和 UTF-8</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"编码\"><a href=\"#编码\" class=\"headerlink\" title=\"编码\"></a>编码</h2><p>我们计算机只能读懂01这两个字符，这和我们人类平时对文字的使用很不相同。如何在计算机里存储和表示文字，就涉及到了编码的知识。</p>\n<p>计算机有哪些编码方式呢？</p>\n<h2 id=\"ASCII-码\"><a href=\"#ASCII-码\" class=\"headerlink\" title=\"ASCII 码\"></a>ASCII 码</h2><p>我们知道，计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从00000000到11111111。</p>","more":"<p>上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。</p>\n<p>ASCII 码一共规定了128个字符的编码，比如空格SPACE是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为0。</p>\n<p>这种编码方式完成了基础的编码，但是随着计算机的普及，我们需要在计算机里表示除了英文之外的内容，这128个字符显然是不够的。比如现在的这篇博客，里面的中文字符是如何表示的呢？除了中文，还有其他各国的语言字符，法文、希腊文、西班牙文…等等这些语言，需要大量的编码位置。</p>\n<h2 id=\"Unicode\"><a href=\"#Unicode\" class=\"headerlink\" title=\"Unicode\"></a>Unicode</h2><p>正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。</p>\n<p>可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是 Unicode，就像它的名字都表示的，这是一种所有符号的编码。</p>\n<p>Unicode 当然是一个很大的集合，现在的规模可以容纳100多万个符号。Unicode定义了我们所能想到字符的二进制表示，可以说是很全面了。但是如何存储存储这些二进制呢？</p>\n<p>直接存储？这是简单暴力的做法，因为在Unicode编码里<code>a</code>对应的码点是<code>97</code>，Unicode编码是<code>U+0061</code>，二进制表示为<code>1100001</code>， 中文<code>远</code>字的码点是<code>36828</code>，Unicode编码为<code>U+8FDC</code>,二进制表示为<code>1000111111011100</code>。<code>a</code>只需要7个bit位，而<code>远</code>却需要16个bit位。如果只用一个字节（8bit）显然是无法表示汉字<code>远</code>的，但是如果用两个字节（16bit）那么在表示<code>a</code>的时候前面要多出9个0，这无疑造成了空间上很大的浪费。</p>\n<p>有了Unicode编码方式之后，还要想一个规则去保存这些字符。<code>UTF-8</code>、<code>UTF-16</code>、<code>UTF-32</code>便是我们最常见的规则。</p>\n<p>Unicode只是一个符号集，而<code>UTF-8</code>、<code>UTF-16</code>、<code>UTF-32</code>是Unicode在计算机中的具体实现。不过在互联网中最最常用的还是<code>UTF-8</code>。</p>\n<p>Unicode的学名是”Universal Multiple-Octet Coded Character Set”，简称为UCS。UCS可以看作是”Unicode Character Set”的缩写。</p>\n<p>UTF是“UCS Transformation Format”的缩写。‘8’是指用8位的bit块去表示一个字符。表示一个字符所需的字符块从1-4不等。</p>\n<h3 id=\"UTF-8\"><a href=\"#UTF-8\" class=\"headerlink\" title=\"UTF-8\"></a>UTF-8</h3><p>UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</p>\n<p>UTF-8 的编码规则很简单，只有二条：</p>\n<ol>\n<li><p>对于单字节的符号且小于7位的编码，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。</p>\n</li>\n<li><p>对于大于7bit的编码，n字节的符号1字节按2字节来算（n &gt; 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"center\">1st byte</th>\n<th align=\"center\">2nd byte</th>\n<th align=\"left\">3rd byte</th>\n<th align=\"left\">4th byte</th>\n<th align=\"left\">可用于表示字符的bit位个数</th>\n<th align=\"left\">最大表示的Unicode 编码值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">0xxx xxxx</td>\n<td align=\"center\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">7</td>\n<td align=\"left\">007F hex(127)</td>\n</tr>\n<tr>\n<td align=\"center\">110x xxxx</td>\n<td align=\"center\">10xx xxxx</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">(5+6)=11</td>\n<td align=\"left\">07FF hex(2047)</td>\n</tr>\n<tr>\n<td align=\"center\">1110 xxxx</td>\n<td align=\"center\">10xx xxxx</td>\n<td align=\"left\">10xx xxxx</td>\n<td align=\"left\"></td>\n<td align=\"left\">(4+6+6)=16</td>\n<td align=\"left\">FFFF hex(65535)</td>\n</tr>\n<tr>\n<td align=\"center\">1111 0xxx</td>\n<td align=\"center\">10xx xxxx</td>\n<td align=\"left\">10xx xxxx</td>\n<td align=\"left\">10xx xxxx</td>\n<td align=\"left\">(3+6+6+6)=21</td>\n<td align=\"left\">10FFFF hex(1,114,111)</td>\n</tr>\n</tbody></table>\n<p>注：目前Unicode的编码最大为10FFFF。</p>\n<p>这个规则已经定义好，如何根据Unicode编码，得出对应的UTF-8编码呢，来写一个JavaScript的程序来实现一下吧！</p>\n<h3 id=\"Unicode-与-UTF-8-之间的转换\"><a href=\"#Unicode-与-UTF-8-之间的转换\" class=\"headerlink\" title=\"Unicode 与 UTF-8 之间的转换\"></a>Unicode 与 UTF-8 之间的转换</h3><p>如代码无法运行请点击<a href=\"https://codepen.io/woowyl/pen/oNjdNxz\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<iframe src=\"https://codepen.io/woowyl/embed/oNjdNxz?height=807&theme-id=dark&default-tab=js,result\" width=\"100%\" height=\"400\" frameborder=\"0\" loading=\"lazy\" allowfullscreen></iframe>\n\n<h3 id=\"BMP-（Basic-Multilingual-Plane）\"><a href=\"#BMP-（Basic-Multilingual-Plane）\" class=\"headerlink\" title=\"BMP （Basic Multilingual Plane）\"></a>BMP （Basic Multilingual Plane）</h3><p>Unicode 从<code>U+0000</code>到<code>U+FFFF</code>这个范围称为BMP,我们日常编码应该让代码保持在这个范围内。</p>\n<h2 id=\"其他编码方式\"><a href=\"#其他编码方式\" class=\"headerlink\" title=\"其他编码方式\"></a>其他编码方式</h2><p>除了上述两种我们最最常接触的编码方式外，还有其他好多编码方式：<br>早期的计算机使用7位的ASCII编码，为了处理汉字，程序员设计了用于简体中文的GB2312和用于繁体中文的big5。</p>\n<ul>\n<li><p>GB2312<br>  GB2312(1980年)一共收录了7445个字符，包括6763个汉字和682个其它符号。汉字区的内码范围高字节从B0-F7，低字节从A1-FE，占用的码位是72*94=6768。其中有5个空位是D7FA-D7FE。</p>\n<p>  GB2312支持的汉字太少。1995年的汉字扩展规范GBK1.0收录了21886个符号，它分为汉字区和图形符号区。汉字区包括21003个字符。</p>\n</li>\n<li><p>GBK</p>\n</li>\n</ul>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://home.unicode.org/\" target=\"_blank\" rel=\"noopener\">unicode官网</a><br><a href=\"https://www.fileformat.info/info/unicode/\" target=\"_blank\" rel=\"noopener\">unicode format</a><br><a href=\"https://www.fileformat.info/info/unicode/utf8.htm\" target=\"_blank\" rel=\"noopener\">UTF-8 的规则</a><br><a href=\"http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html\" target=\"_blank\" rel=\"noopener\">字符编码笔记：ASCII，Unicode 和 UTF-8</a></p>"},{"title":"如何找论文文献","date":"2020-05-09T05:13:56.000Z","_content":"\n## 文献搜索网站\n\n### 中文文献搜索\n\n - 中国知网 \n - 万方数据\n\n### 英文文献搜索\n\n#### Google scholar\n 链接：https://scholar.google.com/\n 优点： 文献量大，全\n 缺点： 分类归纳不友好，通过简单的搜索关键字不能准确定位到想要的paper \n\n## 复旦大学图书馆\n其实对于大多数写毕业论文的学生来说，学校给出的这些数据库已经完全足够了。在外网好多论文是要收费的，学校已经买了好多数据库的版权，直接用学校网络或者通过vpn链接学校网络，下载完全免费，完全免费，完全免费啊同学们！这么好的资源不去下载简直对不起学费。\n这里列出复旦大学给出的资源\n\n<!-- more -->\n\n![fudan_data](fudan_data.png)\n\n\n## 如何搜索适合的文献\n\n1. 所在领域内的顶级国际会议和期刊杂志的文章，找影响因子高的\n  - [WWW大会](https://dl.acm.org/conference/www)\n2. 对文献进行排序，关键词相关度，相关时间，被引用次数\n3. 被引用次数多的文献里找引用这边文章前几名的文章（谷歌学术里会有被引用的次数，点击之后就是被引用的文章）\n4. 关注综述类文章（Survey）\n5. 积累英文关键词，搜索统一中文词对应的英文单词\n\n## 期刊\n\n在论文搜索中常遇到期刊的搜索项，什么是期刊呢？\n\n\n## Reference\n[bilibli在家如何写出优秀论文？？](https://www.bilibili.com/video/BV1L7411K7iH/?spm_id_from=trigger_reload)\n","source":"_posts/daily/paper/paper-search.md","raw":"---\ntitle: 如何找论文文献\ndate: 2020-05-09 13:13:56\ncategories: paper\ntags: \n  - paper\n  - 前端智能化\n---\n\n## 文献搜索网站\n\n### 中文文献搜索\n\n - 中国知网 \n - 万方数据\n\n### 英文文献搜索\n\n#### Google scholar\n 链接：https://scholar.google.com/\n 优点： 文献量大，全\n 缺点： 分类归纳不友好，通过简单的搜索关键字不能准确定位到想要的paper \n\n## 复旦大学图书馆\n其实对于大多数写毕业论文的学生来说，学校给出的这些数据库已经完全足够了。在外网好多论文是要收费的，学校已经买了好多数据库的版权，直接用学校网络或者通过vpn链接学校网络，下载完全免费，完全免费，完全免费啊同学们！这么好的资源不去下载简直对不起学费。\n这里列出复旦大学给出的资源\n\n<!-- more -->\n\n![fudan_data](fudan_data.png)\n\n\n## 如何搜索适合的文献\n\n1. 所在领域内的顶级国际会议和期刊杂志的文章，找影响因子高的\n  - [WWW大会](https://dl.acm.org/conference/www)\n2. 对文献进行排序，关键词相关度，相关时间，被引用次数\n3. 被引用次数多的文献里找引用这边文章前几名的文章（谷歌学术里会有被引用的次数，点击之后就是被引用的文章）\n4. 关注综述类文章（Survey）\n5. 积累英文关键词，搜索统一中文词对应的英文单词\n\n## 期刊\n\n在论文搜索中常遇到期刊的搜索项，什么是期刊呢？\n\n\n## Reference\n[bilibli在家如何写出优秀论文？？](https://www.bilibili.com/video/BV1L7411K7iH/?spm_id_from=trigger_reload)\n","slug":"daily/paper/paper-search","published":1,"updated":"2021-03-08T03:38:15.908Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm05nqee000z2cl27rzb5m9y","content":"<h2 id=\"文献搜索网站\"><a href=\"#文献搜索网站\" class=\"headerlink\" title=\"文献搜索网站\"></a>文献搜索网站</h2><h3 id=\"中文文献搜索\"><a href=\"#中文文献搜索\" class=\"headerlink\" title=\"中文文献搜索\"></a>中文文献搜索</h3><ul>\n<li>中国知网 </li>\n<li>万方数据</li>\n</ul>\n<h3 id=\"英文文献搜索\"><a href=\"#英文文献搜索\" class=\"headerlink\" title=\"英文文献搜索\"></a>英文文献搜索</h3><h4 id=\"Google-scholar\"><a href=\"#Google-scholar\" class=\"headerlink\" title=\"Google scholar\"></a>Google scholar</h4><p> 链接：<a href=\"https://scholar.google.com/\" target=\"_blank\" rel=\"noopener\">https://scholar.google.com/</a><br> 优点： 文献量大，全<br> 缺点： 分类归纳不友好，通过简单的搜索关键字不能准确定位到想要的paper </p>\n<h2 id=\"复旦大学图书馆\"><a href=\"#复旦大学图书馆\" class=\"headerlink\" title=\"复旦大学图书馆\"></a>复旦大学图书馆</h2><p>其实对于大多数写毕业论文的学生来说，学校给出的这些数据库已经完全足够了。在外网好多论文是要收费的，学校已经买了好多数据库的版权，直接用学校网络或者通过vpn链接学校网络，下载完全免费，完全免费，完全免费啊同学们！这么好的资源不去下载简直对不起学费。<br>这里列出复旦大学给出的资源</p>\n<a id=\"more\"></a>\n\n<p><img src=\"fudan_data.png\" alt=\"fudan_data\"></p>\n<h2 id=\"如何搜索适合的文献\"><a href=\"#如何搜索适合的文献\" class=\"headerlink\" title=\"如何搜索适合的文献\"></a>如何搜索适合的文献</h2><ol>\n<li>所在领域内的顶级国际会议和期刊杂志的文章，找影响因子高的<ul>\n<li><a href=\"https://dl.acm.org/conference/www\" target=\"_blank\" rel=\"noopener\">WWW大会</a></li>\n</ul>\n</li>\n<li>对文献进行排序，关键词相关度，相关时间，被引用次数</li>\n<li>被引用次数多的文献里找引用这边文章前几名的文章（谷歌学术里会有被引用的次数，点击之后就是被引用的文章）</li>\n<li>关注综述类文章（Survey）</li>\n<li>积累英文关键词，搜索统一中文词对应的英文单词</li>\n</ol>\n<h2 id=\"期刊\"><a href=\"#期刊\" class=\"headerlink\" title=\"期刊\"></a>期刊</h2><p>在论文搜索中常遇到期刊的搜索项，什么是期刊呢？</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://www.bilibili.com/video/BV1L7411K7iH/?spm_id_from=trigger_reload\" target=\"_blank\" rel=\"noopener\">bilibli在家如何写出优秀论文？？</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"文献搜索网站\"><a href=\"#文献搜索网站\" class=\"headerlink\" title=\"文献搜索网站\"></a>文献搜索网站</h2><h3 id=\"中文文献搜索\"><a href=\"#中文文献搜索\" class=\"headerlink\" title=\"中文文献搜索\"></a>中文文献搜索</h3><ul>\n<li>中国知网 </li>\n<li>万方数据</li>\n</ul>\n<h3 id=\"英文文献搜索\"><a href=\"#英文文献搜索\" class=\"headerlink\" title=\"英文文献搜索\"></a>英文文献搜索</h3><h4 id=\"Google-scholar\"><a href=\"#Google-scholar\" class=\"headerlink\" title=\"Google scholar\"></a>Google scholar</h4><p> 链接：<a href=\"https://scholar.google.com/\" target=\"_blank\" rel=\"noopener\">https://scholar.google.com/</a><br> 优点： 文献量大，全<br> 缺点： 分类归纳不友好，通过简单的搜索关键字不能准确定位到想要的paper </p>\n<h2 id=\"复旦大学图书馆\"><a href=\"#复旦大学图书馆\" class=\"headerlink\" title=\"复旦大学图书馆\"></a>复旦大学图书馆</h2><p>其实对于大多数写毕业论文的学生来说，学校给出的这些数据库已经完全足够了。在外网好多论文是要收费的，学校已经买了好多数据库的版权，直接用学校网络或者通过vpn链接学校网络，下载完全免费，完全免费，完全免费啊同学们！这么好的资源不去下载简直对不起学费。<br>这里列出复旦大学给出的资源</p>","more":"<p><img src=\"fudan_data.png\" alt=\"fudan_data\"></p>\n<h2 id=\"如何搜索适合的文献\"><a href=\"#如何搜索适合的文献\" class=\"headerlink\" title=\"如何搜索适合的文献\"></a>如何搜索适合的文献</h2><ol>\n<li>所在领域内的顶级国际会议和期刊杂志的文章，找影响因子高的<ul>\n<li><a href=\"https://dl.acm.org/conference/www\" target=\"_blank\" rel=\"noopener\">WWW大会</a></li>\n</ul>\n</li>\n<li>对文献进行排序，关键词相关度，相关时间，被引用次数</li>\n<li>被引用次数多的文献里找引用这边文章前几名的文章（谷歌学术里会有被引用的次数，点击之后就是被引用的文章）</li>\n<li>关注综述类文章（Survey）</li>\n<li>积累英文关键词，搜索统一中文词对应的英文单词</li>\n</ol>\n<h2 id=\"期刊\"><a href=\"#期刊\" class=\"headerlink\" title=\"期刊\"></a>期刊</h2><p>在论文搜索中常遇到期刊的搜索项，什么是期刊呢？</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://www.bilibili.com/video/BV1L7411K7iH/?spm_id_from=trigger_reload\" target=\"_blank\" rel=\"noopener\">bilibli在家如何写出优秀论文？？</a></p>"},{"title":"Flex","date":"2019-03-03T06:05:05.000Z","_content":"## 容器上的六个属性\n1. flex-direction\n2. flex-wrap\n   默认情况下，项目都排在一条线（又称\"轴线\"）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。\n<!-- more -->\n```css\n    .box {\n     flex-wrap: nowrap | wrap | wrap-reverse;\n     }\n```\n3. flex-flow\n   flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap\n4. just-content\n5. align-items\n6. align-content\n\n## 项目上的六个属性\n\n1. order\n  order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0\n2. flex-grow\n3. flex-shrink\n4. flex-basis\nflex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。\n5. flex\nflex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。\n\n6. align-self\n\n\n","source":"_posts/font-end/2019/flex_layout.md","raw":"---\ntitle: Flex\ndate: 2019-03-03 14:05:05\ncategories: front-end\ntags: \n- 前端\n- 布局\n---\n## 容器上的六个属性\n1. flex-direction\n2. flex-wrap\n   默认情况下，项目都排在一条线（又称\"轴线\"）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。\n<!-- more -->\n```css\n    .box {\n     flex-wrap: nowrap | wrap | wrap-reverse;\n     }\n```\n3. flex-flow\n   flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap\n4. just-content\n5. align-items\n6. align-content\n\n## 项目上的六个属性\n\n1. order\n  order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0\n2. flex-grow\n3. flex-shrink\n4. flex-basis\nflex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。\n5. flex\nflex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。\n\n6. align-self\n\n\n","slug":"font-end/2019/flex_layout","published":1,"updated":"2021-03-08T05:35:20.268Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm05nqef00102cl2b0v0fvyb","content":"<h2 id=\"容器上的六个属性\"><a href=\"#容器上的六个属性\" class=\"headerlink\" title=\"容器上的六个属性\"></a>容器上的六个属性</h2><ol>\n<li>flex-direction</li>\n<li>flex-wrap<br>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。<a id=\"more\"></a>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\"> <span class=\"attribute\">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></li>\n<li>flex-flow<br>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap</li>\n<li>just-content</li>\n<li>align-items</li>\n<li>align-content</li>\n</ol>\n<h2 id=\"项目上的六个属性\"><a href=\"#项目上的六个属性\" class=\"headerlink\" title=\"项目上的六个属性\"></a>项目上的六个属性</h2><ol>\n<li><p>order<br>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0</p>\n</li>\n<li><p>flex-grow</p>\n</li>\n<li><p>flex-shrink</p>\n</li>\n<li><p>flex-basis<br>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</p>\n</li>\n<li><p>flex<br>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</p>\n</li>\n<li><p>align-self</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"容器上的六个属性\"><a href=\"#容器上的六个属性\" class=\"headerlink\" title=\"容器上的六个属性\"></a>容器上的六个属性</h2><ol>\n<li>flex-direction</li>\n<li>flex-wrap<br>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。","more":"<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\"> <span class=\"attribute\">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></li>\n<li>flex-flow<br>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap</li>\n<li>just-content</li>\n<li>align-items</li>\n<li>align-content</li>\n</ol>\n<h2 id=\"项目上的六个属性\"><a href=\"#项目上的六个属性\" class=\"headerlink\" title=\"项目上的六个属性\"></a>项目上的六个属性</h2><ol>\n<li><p>order<br>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0</p>\n</li>\n<li><p>flex-grow</p>\n</li>\n<li><p>flex-shrink</p>\n</li>\n<li><p>flex-basis<br>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</p>\n</li>\n<li><p>flex<br>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</p>\n</li>\n<li><p>align-self</p>\n</li>\n</ol>"},{"title":"写论文里的小工具（基础配置版）","date":"2020-05-10T05:13:56.000Z","_content":"\n## 搜索\n  关于搜索我有专门的一篇文章，传送门[如何找论文文献](/2020/05/09/paper/paper-search/)\n\n## 阅读\n\n推荐[zotero](https://www.zotero.org/)\n在pad端我使用了PDF expert。papers使用的人也比较多。\n\n## 整理\n  世界上最悲哀的不是找不到相关论文，而是读完之后忘记了自己读了啥。为了不那么悲哀，需要采用一些论文的笔记工具。\n\n  图像化相关的首推 `x-mind`[下载链接](https://www.xmind.cn/);有了它做图用官网的话简直就是——思如泉涌 • 成竹在图。而且这个软件兼容性很好，在pad上查看完全无障碍。在mac上做图，在pad上随时查阅，简直不要太方便。\n  在线简单一点的工具有[Process](https://www.processon.com/)。\n  当然相似的脑图软件还有好多，其他的我还没有使用，暂时就不发表意见了。\n<!-- more -->\n  文字笔记的话，考虑到多端同步，我首推印象笔记。也是可以在手机、pad、电脑端即时同步的，不过要支持多端同步的话是要收费的。国内的有道云笔记好像也支持这个功能了。\n  看到好多前辈推荐使用onenote做笔记，也是一个不错的工具，关键是免费啊！值得一试。\n\n\n  ## 写论文\n\n  由于我还没开始写，所以，暂时还没有太好的经验，后续再补充吧。\n\n  ### 论文结构\n\n   - 封面，原创性声明\n   - 中英文摘要\n     1. 简单介绍背景\n     2. 目前存在的问题\n     3. 你的具体工作，有几点就写几段\n     4. 简单总结 \n     推荐语法检查网站（grammarly）\n   - 目录\n   - 绪论(综述)\n    1. 按时间顺序，阐述研究领域的研究现状\n    2. 对研究工作进行分类评述\n        - 经典文献详细说\n        - 过时观点简单说\n        - 争议焦点 罗列观点进行比较\n    3. 总结现有工作的优势和不足\n    4. 提出发展前景和工作必要性\n\n   - 正文\n     1. 提出一个模型\n     2. 对模型展开分析\n     3. 实验\n     4. 实验结果 讨论及叙述\n     5. 总结\n   - 总结和展望\n   - 参考文献\n     使用endnote管理逼得参考文献，学习官网可下载\n   - 附录\n   - 致谢\n\n## 查重\n\n### 不查重部分\n\n - 封面\n - 原创性声明\n - 目录 致谢\n - 文中图片\n - 文中代码及数学公式\n\n### 查重平台\n\n - 知网、万方、维普等\n - 其他学校官方合作机构\n - paperpass 等第三方平台\n\n ### 如何降重\n\n  - 善用国外资料 适当翻译国外文献中可用的内容\n  - 连续字词之间插入新文字或同义词转换，句式转换\n  - 文字改成图片 把一部分调查问卷等改成图片形式\n  - 自己重新复述把原句全部删掉\n\n\n  ## Reference\n[bilibli在家如何写出优秀论文？？](https://www.bilibili.com/video/BV1L7411K7iH/?spm_id_from=trigger_reload)\n","source":"_posts/daily/paper/paper-tool.md","raw":"---\ntitle: 写论文里的小工具（基础配置版）\ndate: 2020-05-10 13:13:56\ncategories: paper\ntags:\n  - paper\n  - 效率\n---\n\n## 搜索\n  关于搜索我有专门的一篇文章，传送门[如何找论文文献](/2020/05/09/paper/paper-search/)\n\n## 阅读\n\n推荐[zotero](https://www.zotero.org/)\n在pad端我使用了PDF expert。papers使用的人也比较多。\n\n## 整理\n  世界上最悲哀的不是找不到相关论文，而是读完之后忘记了自己读了啥。为了不那么悲哀，需要采用一些论文的笔记工具。\n\n  图像化相关的首推 `x-mind`[下载链接](https://www.xmind.cn/);有了它做图用官网的话简直就是——思如泉涌 • 成竹在图。而且这个软件兼容性很好，在pad上查看完全无障碍。在mac上做图，在pad上随时查阅，简直不要太方便。\n  在线简单一点的工具有[Process](https://www.processon.com/)。\n  当然相似的脑图软件还有好多，其他的我还没有使用，暂时就不发表意见了。\n<!-- more -->\n  文字笔记的话，考虑到多端同步，我首推印象笔记。也是可以在手机、pad、电脑端即时同步的，不过要支持多端同步的话是要收费的。国内的有道云笔记好像也支持这个功能了。\n  看到好多前辈推荐使用onenote做笔记，也是一个不错的工具，关键是免费啊！值得一试。\n\n\n  ## 写论文\n\n  由于我还没开始写，所以，暂时还没有太好的经验，后续再补充吧。\n\n  ### 论文结构\n\n   - 封面，原创性声明\n   - 中英文摘要\n     1. 简单介绍背景\n     2. 目前存在的问题\n     3. 你的具体工作，有几点就写几段\n     4. 简单总结 \n     推荐语法检查网站（grammarly）\n   - 目录\n   - 绪论(综述)\n    1. 按时间顺序，阐述研究领域的研究现状\n    2. 对研究工作进行分类评述\n        - 经典文献详细说\n        - 过时观点简单说\n        - 争议焦点 罗列观点进行比较\n    3. 总结现有工作的优势和不足\n    4. 提出发展前景和工作必要性\n\n   - 正文\n     1. 提出一个模型\n     2. 对模型展开分析\n     3. 实验\n     4. 实验结果 讨论及叙述\n     5. 总结\n   - 总结和展望\n   - 参考文献\n     使用endnote管理逼得参考文献，学习官网可下载\n   - 附录\n   - 致谢\n\n## 查重\n\n### 不查重部分\n\n - 封面\n - 原创性声明\n - 目录 致谢\n - 文中图片\n - 文中代码及数学公式\n\n### 查重平台\n\n - 知网、万方、维普等\n - 其他学校官方合作机构\n - paperpass 等第三方平台\n\n ### 如何降重\n\n  - 善用国外资料 适当翻译国外文献中可用的内容\n  - 连续字词之间插入新文字或同义词转换，句式转换\n  - 文字改成图片 把一部分调查问卷等改成图片形式\n  - 自己重新复述把原句全部删掉\n\n\n  ## Reference\n[bilibli在家如何写出优秀论文？？](https://www.bilibili.com/video/BV1L7411K7iH/?spm_id_from=trigger_reload)\n","slug":"daily/paper/paper-tool","published":1,"updated":"2020-09-02T09:26:57.486Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm05nqeg00132cl2h1ws5t0n","content":"<h2 id=\"搜索\"><a href=\"#搜索\" class=\"headerlink\" title=\"搜索\"></a>搜索</h2><p>  关于搜索我有专门的一篇文章，传送门<a href=\"/2020/05/09/paper/paper-search/\">如何找论文文献</a></p>\n<h2 id=\"阅读\"><a href=\"#阅读\" class=\"headerlink\" title=\"阅读\"></a>阅读</h2><p>推荐<a href=\"https://www.zotero.org/\" target=\"_blank\" rel=\"noopener\">zotero</a><br>在pad端我使用了PDF expert。papers使用的人也比较多。</p>\n<h2 id=\"整理\"><a href=\"#整理\" class=\"headerlink\" title=\"整理\"></a>整理</h2><p>  世界上最悲哀的不是找不到相关论文，而是读完之后忘记了自己读了啥。为了不那么悲哀，需要采用一些论文的笔记工具。</p>\n<p>  图像化相关的首推 <code>x-mind</code><a href=\"https://www.xmind.cn/\" target=\"_blank\" rel=\"noopener\">下载链接</a>;有了它做图用官网的话简直就是——思如泉涌 • 成竹在图。而且这个软件兼容性很好，在pad上查看完全无障碍。在mac上做图，在pad上随时查阅，简直不要太方便。<br>  在线简单一点的工具有<a href=\"https://www.processon.com/\" target=\"_blank\" rel=\"noopener\">Process</a>。<br>  当然相似的脑图软件还有好多，其他的我还没有使用，暂时就不发表意见了。</p>\n<a id=\"more\"></a>\n<p>  文字笔记的话，考虑到多端同步，我首推印象笔记。也是可以在手机、pad、电脑端即时同步的，不过要支持多端同步的话是要收费的。国内的有道云笔记好像也支持这个功能了。<br>  看到好多前辈推荐使用onenote做笔记，也是一个不错的工具，关键是免费啊！值得一试。</p>\n<h2 id=\"写论文\"><a href=\"#写论文\" class=\"headerlink\" title=\"写论文\"></a>写论文</h2><p>  由于我还没开始写，所以，暂时还没有太好的经验，后续再补充吧。</p>\n<h3 id=\"论文结构\"><a href=\"#论文结构\" class=\"headerlink\" title=\"论文结构\"></a>论文结构</h3><ul>\n<li><p>封面，原创性声明</p>\n</li>\n<li><p>中英文摘要</p>\n<ol>\n<li>简单介绍背景</li>\n<li>目前存在的问题</li>\n<li>你的具体工作，有几点就写几段</li>\n<li>简单总结<br>推荐语法检查网站（grammarly）</li>\n</ol>\n</li>\n<li><p>目录</p>\n</li>\n<li><p>绪论(综述)</p>\n<ol>\n<li>按时间顺序，阐述研究领域的研究现状</li>\n<li>对研究工作进行分类评述<ul>\n<li>经典文献详细说</li>\n<li>过时观点简单说</li>\n<li>争议焦点 罗列观点进行比较</li>\n</ul>\n</li>\n<li>总结现有工作的优势和不足</li>\n<li>提出发展前景和工作必要性</li>\n</ol>\n</li>\n<li><p>正文</p>\n<ol>\n<li>提出一个模型</li>\n<li>对模型展开分析</li>\n<li>实验</li>\n<li>实验结果 讨论及叙述</li>\n<li>总结</li>\n</ol>\n</li>\n<li><p>总结和展望</p>\n</li>\n<li><p>参考文献<br>使用endnote管理逼得参考文献，学习官网可下载</p>\n</li>\n<li><p>附录</p>\n</li>\n<li><p>致谢</p>\n</li>\n</ul>\n<h2 id=\"查重\"><a href=\"#查重\" class=\"headerlink\" title=\"查重\"></a>查重</h2><h3 id=\"不查重部分\"><a href=\"#不查重部分\" class=\"headerlink\" title=\"不查重部分\"></a>不查重部分</h3><ul>\n<li>封面</li>\n<li>原创性声明</li>\n<li>目录 致谢</li>\n<li>文中图片</li>\n<li>文中代码及数学公式</li>\n</ul>\n<h3 id=\"查重平台\"><a href=\"#查重平台\" class=\"headerlink\" title=\"查重平台\"></a>查重平台</h3><ul>\n<li><p>知网、万方、维普等</p>\n</li>\n<li><p>其他学校官方合作机构</p>\n</li>\n<li><p>paperpass 等第三方平台</p>\n<h3 id=\"如何降重\"><a href=\"#如何降重\" class=\"headerlink\" title=\"如何降重\"></a>如何降重</h3><ul>\n<li>善用国外资料 适当翻译国外文献中可用的内容</li>\n<li>连续字词之间插入新文字或同义词转换，句式转换</li>\n<li>文字改成图片 把一部分调查问卷等改成图片形式</li>\n<li>自己重新复述把原句全部删掉</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://www.bilibili.com/video/BV1L7411K7iH/?spm_id_from=trigger_reload\" target=\"_blank\" rel=\"noopener\">bilibli在家如何写出优秀论文？？</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"搜索\"><a href=\"#搜索\" class=\"headerlink\" title=\"搜索\"></a>搜索</h2><p>  关于搜索我有专门的一篇文章，传送门<a href=\"/2020/05/09/paper/paper-search/\">如何找论文文献</a></p>\n<h2 id=\"阅读\"><a href=\"#阅读\" class=\"headerlink\" title=\"阅读\"></a>阅读</h2><p>推荐<a href=\"https://www.zotero.org/\" target=\"_blank\" rel=\"noopener\">zotero</a><br>在pad端我使用了PDF expert。papers使用的人也比较多。</p>\n<h2 id=\"整理\"><a href=\"#整理\" class=\"headerlink\" title=\"整理\"></a>整理</h2><p>  世界上最悲哀的不是找不到相关论文，而是读完之后忘记了自己读了啥。为了不那么悲哀，需要采用一些论文的笔记工具。</p>\n<p>  图像化相关的首推 <code>x-mind</code><a href=\"https://www.xmind.cn/\" target=\"_blank\" rel=\"noopener\">下载链接</a>;有了它做图用官网的话简直就是——思如泉涌 • 成竹在图。而且这个软件兼容性很好，在pad上查看完全无障碍。在mac上做图，在pad上随时查阅，简直不要太方便。<br>  在线简单一点的工具有<a href=\"https://www.processon.com/\" target=\"_blank\" rel=\"noopener\">Process</a>。<br>  当然相似的脑图软件还有好多，其他的我还没有使用，暂时就不发表意见了。</p>","more":"<p>  文字笔记的话，考虑到多端同步，我首推印象笔记。也是可以在手机、pad、电脑端即时同步的，不过要支持多端同步的话是要收费的。国内的有道云笔记好像也支持这个功能了。<br>  看到好多前辈推荐使用onenote做笔记，也是一个不错的工具，关键是免费啊！值得一试。</p>\n<h2 id=\"写论文\"><a href=\"#写论文\" class=\"headerlink\" title=\"写论文\"></a>写论文</h2><p>  由于我还没开始写，所以，暂时还没有太好的经验，后续再补充吧。</p>\n<h3 id=\"论文结构\"><a href=\"#论文结构\" class=\"headerlink\" title=\"论文结构\"></a>论文结构</h3><ul>\n<li><p>封面，原创性声明</p>\n</li>\n<li><p>中英文摘要</p>\n<ol>\n<li>简单介绍背景</li>\n<li>目前存在的问题</li>\n<li>你的具体工作，有几点就写几段</li>\n<li>简单总结<br>推荐语法检查网站（grammarly）</li>\n</ol>\n</li>\n<li><p>目录</p>\n</li>\n<li><p>绪论(综述)</p>\n<ol>\n<li>按时间顺序，阐述研究领域的研究现状</li>\n<li>对研究工作进行分类评述<ul>\n<li>经典文献详细说</li>\n<li>过时观点简单说</li>\n<li>争议焦点 罗列观点进行比较</li>\n</ul>\n</li>\n<li>总结现有工作的优势和不足</li>\n<li>提出发展前景和工作必要性</li>\n</ol>\n</li>\n<li><p>正文</p>\n<ol>\n<li>提出一个模型</li>\n<li>对模型展开分析</li>\n<li>实验</li>\n<li>实验结果 讨论及叙述</li>\n<li>总结</li>\n</ol>\n</li>\n<li><p>总结和展望</p>\n</li>\n<li><p>参考文献<br>使用endnote管理逼得参考文献，学习官网可下载</p>\n</li>\n<li><p>附录</p>\n</li>\n<li><p>致谢</p>\n</li>\n</ul>\n<h2 id=\"查重\"><a href=\"#查重\" class=\"headerlink\" title=\"查重\"></a>查重</h2><h3 id=\"不查重部分\"><a href=\"#不查重部分\" class=\"headerlink\" title=\"不查重部分\"></a>不查重部分</h3><ul>\n<li>封面</li>\n<li>原创性声明</li>\n<li>目录 致谢</li>\n<li>文中图片</li>\n<li>文中代码及数学公式</li>\n</ul>\n<h3 id=\"查重平台\"><a href=\"#查重平台\" class=\"headerlink\" title=\"查重平台\"></a>查重平台</h3><ul>\n<li><p>知网、万方、维普等</p>\n</li>\n<li><p>其他学校官方合作机构</p>\n</li>\n<li><p>paperpass 等第三方平台</p>\n<h3 id=\"如何降重\"><a href=\"#如何降重\" class=\"headerlink\" title=\"如何降重\"></a>如何降重</h3><ul>\n<li>善用国外资料 适当翻译国外文献中可用的内容</li>\n<li>连续字词之间插入新文字或同义词转换，句式转换</li>\n<li>文字改成图片 把一部分调查问卷等改成图片形式</li>\n<li>自己重新复述把原句全部删掉</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://www.bilibili.com/video/BV1L7411K7iH/?spm_id_from=trigger_reload\" target=\"_blank\" rel=\"noopener\">bilibli在家如何写出优秀论文？？</a></p>"},{"title":"0 == false ？","date":"2019-10-23T13:00:05.000Z","_content":"\n在javaScript中，经常会看到 `0 == false` => ture的情况，一个Number类型，怎么能等于一个Boolen类型呢？先从javaScript的基本类型说起\n<!-- more -->\n## javasript类型\n### 类型分类\n传统意义上我们会说是7中基本类型，Number String Boolean undefined null Symbol Object。\n\n目前还在推进阶段的Bigint类型。除了这种分类之外，我们还可以有一个更详尽的分类方式：\n- 6中原始类型\n     - Number\n     - String\n     - Boolean\n     - undefined\n     - Symbol\n     - Bigint\n- Object 引用类型\n    - Array\n    - Object\n    - Map\n    - Set\n    - Date\n    - ...\n- null\n- Function\n\n###  类型判断\n如何判断当前变量的类型呢，将JS常用的几种方式，做一个归纳：\n\n- 原始类型 用 `typeof`\n    - undefined：`typeof instance === \"undefined\"`\n    - Boolean：`typeof instance === \"boolean\"`\n    - Number：`typeof instance === \"number\"`\n    - String：`typeof instance === \"string`\n    - BigInt：`typeof instance === \"bigint\"`\n    - Symbol ：`typeof instance === \"symbol\"`\n \n- 引用类型 \n    - 可以统一用 `Object.prototype.toString.call(ins)` 分别得到以下内容\n        - Null: `'[object Null]'`\n        - Object：`'[object Object]'`\n        - Array：`'[object Object]'`\n        - Set：`'[object Set]'`\n        - Map：`'[object Map]'`\n        - Function: `'[object Function]'`\n        - Date: `'[object Date]'`\n        - RegExp: `'[object RegExp]'`\n        - ...\n    - 也可以用用一些单个API\n        - Object\n        - Array:\n            - `Array.isArray(arr)`\n            - `arr instanceof Array`'\n         - null\n      - Function\n           - `typeof Function === 'function'`\n\n\n###  类型转换\n\n|-     |Number|String|Boolen|Undefined|Null|Object|Symbol|\n|-      |-    |    -|-    |-    |-    |-     |-    |\n|Number  |-   |     |0=>false| x   |  x  |Boxing|  x   |\n|String  |    |-   |\"\"=>false| x   |  x  |Boxing | x   |\n|Boolean | true=>1 false=>0   | true=>'true' false=> 'false'    |-        |x    | x  | Boxing | x  |\n|Undefined| NaN| 'undefined'|  false  |-    | x  |      | x   |\n|Null    | 0 | 'null' | false   |x    |-   |      | x  |\n|Object  | valueOf   | valueOf toString    |  true        |x    | x    |-    | x   \n|Symbol  | x  |  x  | x     |x    | x    |  Boxing |-    |\n\n\n \n#### unboxing & boxing\n\n装箱和拆箱，是在java中提到的概念，在理解这个之前，要首先明白，在JS里类和类型是两个不同的概念。 这是一些动态语言的特性，比如javaScript、python。Javascript有7种基本类型，其中，`Number`、`String`、`Boolen`、`Symbol`又拥有各自的类。这里要特别注意区分类和类型的区别,虽然，`new String('hello').lenth == 'hello'.length` ，但是他们的`typeof`并不相同：\n```js\n    typeof new String('hello')    //object\n    typefo 'hello';              //string\n    \n    !new String('')  //false\n    !''             //true\n\n```\n除了，new操作之外，`Number`、`String`、`Boolean`不带new操作还可以直接进行类型转换,得到的并不是object,而是转换后的类型本身\n```js\n    Number('1')   => 1\n    String(2222)  => '22222' //这里返回的是string类型，而不是String对象\n    Boolen(1)     => true\n    Boolen('0')   => true\n    Boolen(0)     => false\n    Boolen('')    => false\n```\n\n> 这里推荐大家不要用自动的类型转换，涉及到类型转换的地方，都显式地采用手动的类型转换，对可读性比较有帮助。\n\n这里有一个比较特殊的类型`Symbol`，是new不了的。\n\n##### boxing\n装箱就是一个操作的统称，指的是将一个基础类型转换为其对应的Object类型，除了上面提的`new`操作之外，也可以通过`Object(类型变量)`来实现装箱。\n ```js\n    //装箱操作1\n    Object('hello')\n    //装箱操作2 new\n    new String('hello')  //String obj\n```\n\n可以装箱操作的类型有: `Number`、`String`、`Boolean`、`Symbol`;其中`Symbol`无法采用new的方式，其他的三类两种方式均可。\n\n装箱操作一般是需要手动完成得，而在自动类型转换中，会经常遇到拆箱操作\n\n##### unboxing\n拆箱操作是在将`Object`对象转换为其他基础类型时发生的操作。当进行拆箱操作时，将自动调用`[Symbol.toPrimitive]`，`ValueOf`，`toString`三者中的一个，调用的原则是：\n1. 存在 `[Symbol.toPrimitive]`时，按照`[Symbol.toPrimitive]`函数进行转换\n2. 没有`[Symbol.toPrimitive]`的顺序是\n    1.`ValueOf()`\n    2.`toString()`\n3. 当且仅当`ValueOf()`仍然返回Object时，将调用toString函数\n4. 你很少需要自己调用`valueOf`方法；当遇到要预期的原始值的对象时，JavaScript会自动调用它。\n举例说明：\n```js\n    \n    var obj1 = {\n        [Symbol.toPrimitive](){\n            return 1;\n        },\n        valueOf() {\n            return 2;\n        },\n        toString() {\n            return 3;\n        }\n    }\n    \n    console.log(1 + obj1);      // 2\n    \n    \n    var obj2 = {\n        valueOf() {\n            return 2;\n        },\n        toString() {\n            return 3;\n        }\n    }\n    \n    console.log(1 + obj2);      // 3\n    \n     var obj3 = {\n        toString() {\n            return 3;\n        }\n    }\n    \n    console.log(1 + obj3);      // 4\n    \n     var obj4 = {\n        valueOf() {\n            return {};\n        },\n        toString() {\n            return 3;\n        }\n    }\n    \n    console.log(1+obj4);         //4\n    \n    \n      var obj5 = {\n        valueOf() {\n            return '222';\n        },\n        toString() {\n            return 3;\n        }\n     }\n    \n    console.log(1+obj5);         //1222\n\n```\n\n\n\n##### toString toLocaleSting的常见用法\n\n在object对象中已经内置了toSting 和 toLocalString方法，但是你可以重写他们。\n\n- toString()\n\n    每个对象都有一个 toString() 方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，toString() 方法被每个 Object 对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 \"[object type]\"，其中 type 是对象的类型。以下代码说明了这一点：\n    \n```js\n    var o = new Object();\n    o.toString(); // returns [object Object]\n```\n\n在进制转换中也可以使用toString()的方式\n\n```js\n    Number(12).toString(2)  // 1100\n    Number(12).toString(进制)\n    //逆向操作\n    parseInt(1100,2)    //12\n```\n  \n- valueOf()\n\n|对象\t|返回值|\n|-|-|\n|Array\t|返回数组对象本身。|\n|Boolean|\t布尔值。|\n|Date|\t存储的时间是从 1970 年 1 月 1 日午夜开始计的毫秒数 UTC。|\n|Function|\t函数本身。|\n|Number|\t数字值。|\n|Object|\t对象本身。这是默认情况。|\n|String\t|字符串值。|\n|\t|Math 和 Error 对象没有 valueOf 方法。|\n\n- toLocaleString()\ntoLocaleString 不同于前两个API，它并没有类型转换的效果，但是有一些小技巧，在我们日常开发中十分有用。\n\n```js\n    1234567 .toLocaleString();  // \"1,234,567\"\n    \n    \n    const event = new Date(Date.UTC(2012, 11, 20, 3, 0, 0));\n    onsole.log(event.toLocaleString('en-GB', { timeZone: 'UTC' }));// 20/12/2012, 03:00:00\n```\nArray.prototype.toLocaleString()返回一个字符串表示数组中的元素。数组中的元素将使用各自的 toLocaleString 方法转成字符串，这些字符串将使用一个特定语言环境的字符串（例如一个逗号 \",\"）隔开。\n\n## 3.2 String to Number\njavaScript 已经有了Strign to Number的api： \n - parseInt/parseFloat\n - Number\n - 字面量1231\n这些api的使用方式和最终结果，有或多或少的不同。\n\n\n## Number to String\n\n\n##  ===\n\n## 参考文献\n\n[Symbol.toPrimitive](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive)","source":"_posts/font-end/2019/js_type.md","raw":"---\ntitle: 0 == false ？\ndate: 2019-10-23 21:00:05\ncategories: front-end\ntags: \n- 前端\n---\n\n在javaScript中，经常会看到 `0 == false` => ture的情况，一个Number类型，怎么能等于一个Boolen类型呢？先从javaScript的基本类型说起\n<!-- more -->\n## javasript类型\n### 类型分类\n传统意义上我们会说是7中基本类型，Number String Boolean undefined null Symbol Object。\n\n目前还在推进阶段的Bigint类型。除了这种分类之外，我们还可以有一个更详尽的分类方式：\n- 6中原始类型\n     - Number\n     - String\n     - Boolean\n     - undefined\n     - Symbol\n     - Bigint\n- Object 引用类型\n    - Array\n    - Object\n    - Map\n    - Set\n    - Date\n    - ...\n- null\n- Function\n\n###  类型判断\n如何判断当前变量的类型呢，将JS常用的几种方式，做一个归纳：\n\n- 原始类型 用 `typeof`\n    - undefined：`typeof instance === \"undefined\"`\n    - Boolean：`typeof instance === \"boolean\"`\n    - Number：`typeof instance === \"number\"`\n    - String：`typeof instance === \"string`\n    - BigInt：`typeof instance === \"bigint\"`\n    - Symbol ：`typeof instance === \"symbol\"`\n \n- 引用类型 \n    - 可以统一用 `Object.prototype.toString.call(ins)` 分别得到以下内容\n        - Null: `'[object Null]'`\n        - Object：`'[object Object]'`\n        - Array：`'[object Object]'`\n        - Set：`'[object Set]'`\n        - Map：`'[object Map]'`\n        - Function: `'[object Function]'`\n        - Date: `'[object Date]'`\n        - RegExp: `'[object RegExp]'`\n        - ...\n    - 也可以用用一些单个API\n        - Object\n        - Array:\n            - `Array.isArray(arr)`\n            - `arr instanceof Array`'\n         - null\n      - Function\n           - `typeof Function === 'function'`\n\n\n###  类型转换\n\n|-     |Number|String|Boolen|Undefined|Null|Object|Symbol|\n|-      |-    |    -|-    |-    |-    |-     |-    |\n|Number  |-   |     |0=>false| x   |  x  |Boxing|  x   |\n|String  |    |-   |\"\"=>false| x   |  x  |Boxing | x   |\n|Boolean | true=>1 false=>0   | true=>'true' false=> 'false'    |-        |x    | x  | Boxing | x  |\n|Undefined| NaN| 'undefined'|  false  |-    | x  |      | x   |\n|Null    | 0 | 'null' | false   |x    |-   |      | x  |\n|Object  | valueOf   | valueOf toString    |  true        |x    | x    |-    | x   \n|Symbol  | x  |  x  | x     |x    | x    |  Boxing |-    |\n\n\n \n#### unboxing & boxing\n\n装箱和拆箱，是在java中提到的概念，在理解这个之前，要首先明白，在JS里类和类型是两个不同的概念。 这是一些动态语言的特性，比如javaScript、python。Javascript有7种基本类型，其中，`Number`、`String`、`Boolen`、`Symbol`又拥有各自的类。这里要特别注意区分类和类型的区别,虽然，`new String('hello').lenth == 'hello'.length` ，但是他们的`typeof`并不相同：\n```js\n    typeof new String('hello')    //object\n    typefo 'hello';              //string\n    \n    !new String('')  //false\n    !''             //true\n\n```\n除了，new操作之外，`Number`、`String`、`Boolean`不带new操作还可以直接进行类型转换,得到的并不是object,而是转换后的类型本身\n```js\n    Number('1')   => 1\n    String(2222)  => '22222' //这里返回的是string类型，而不是String对象\n    Boolen(1)     => true\n    Boolen('0')   => true\n    Boolen(0)     => false\n    Boolen('')    => false\n```\n\n> 这里推荐大家不要用自动的类型转换，涉及到类型转换的地方，都显式地采用手动的类型转换，对可读性比较有帮助。\n\n这里有一个比较特殊的类型`Symbol`，是new不了的。\n\n##### boxing\n装箱就是一个操作的统称，指的是将一个基础类型转换为其对应的Object类型，除了上面提的`new`操作之外，也可以通过`Object(类型变量)`来实现装箱。\n ```js\n    //装箱操作1\n    Object('hello')\n    //装箱操作2 new\n    new String('hello')  //String obj\n```\n\n可以装箱操作的类型有: `Number`、`String`、`Boolean`、`Symbol`;其中`Symbol`无法采用new的方式，其他的三类两种方式均可。\n\n装箱操作一般是需要手动完成得，而在自动类型转换中，会经常遇到拆箱操作\n\n##### unboxing\n拆箱操作是在将`Object`对象转换为其他基础类型时发生的操作。当进行拆箱操作时，将自动调用`[Symbol.toPrimitive]`，`ValueOf`，`toString`三者中的一个，调用的原则是：\n1. 存在 `[Symbol.toPrimitive]`时，按照`[Symbol.toPrimitive]`函数进行转换\n2. 没有`[Symbol.toPrimitive]`的顺序是\n    1.`ValueOf()`\n    2.`toString()`\n3. 当且仅当`ValueOf()`仍然返回Object时，将调用toString函数\n4. 你很少需要自己调用`valueOf`方法；当遇到要预期的原始值的对象时，JavaScript会自动调用它。\n举例说明：\n```js\n    \n    var obj1 = {\n        [Symbol.toPrimitive](){\n            return 1;\n        },\n        valueOf() {\n            return 2;\n        },\n        toString() {\n            return 3;\n        }\n    }\n    \n    console.log(1 + obj1);      // 2\n    \n    \n    var obj2 = {\n        valueOf() {\n            return 2;\n        },\n        toString() {\n            return 3;\n        }\n    }\n    \n    console.log(1 + obj2);      // 3\n    \n     var obj3 = {\n        toString() {\n            return 3;\n        }\n    }\n    \n    console.log(1 + obj3);      // 4\n    \n     var obj4 = {\n        valueOf() {\n            return {};\n        },\n        toString() {\n            return 3;\n        }\n    }\n    \n    console.log(1+obj4);         //4\n    \n    \n      var obj5 = {\n        valueOf() {\n            return '222';\n        },\n        toString() {\n            return 3;\n        }\n     }\n    \n    console.log(1+obj5);         //1222\n\n```\n\n\n\n##### toString toLocaleSting的常见用法\n\n在object对象中已经内置了toSting 和 toLocalString方法，但是你可以重写他们。\n\n- toString()\n\n    每个对象都有一个 toString() 方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，toString() 方法被每个 Object 对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 \"[object type]\"，其中 type 是对象的类型。以下代码说明了这一点：\n    \n```js\n    var o = new Object();\n    o.toString(); // returns [object Object]\n```\n\n在进制转换中也可以使用toString()的方式\n\n```js\n    Number(12).toString(2)  // 1100\n    Number(12).toString(进制)\n    //逆向操作\n    parseInt(1100,2)    //12\n```\n  \n- valueOf()\n\n|对象\t|返回值|\n|-|-|\n|Array\t|返回数组对象本身。|\n|Boolean|\t布尔值。|\n|Date|\t存储的时间是从 1970 年 1 月 1 日午夜开始计的毫秒数 UTC。|\n|Function|\t函数本身。|\n|Number|\t数字值。|\n|Object|\t对象本身。这是默认情况。|\n|String\t|字符串值。|\n|\t|Math 和 Error 对象没有 valueOf 方法。|\n\n- toLocaleString()\ntoLocaleString 不同于前两个API，它并没有类型转换的效果，但是有一些小技巧，在我们日常开发中十分有用。\n\n```js\n    1234567 .toLocaleString();  // \"1,234,567\"\n    \n    \n    const event = new Date(Date.UTC(2012, 11, 20, 3, 0, 0));\n    onsole.log(event.toLocaleString('en-GB', { timeZone: 'UTC' }));// 20/12/2012, 03:00:00\n```\nArray.prototype.toLocaleString()返回一个字符串表示数组中的元素。数组中的元素将使用各自的 toLocaleString 方法转成字符串，这些字符串将使用一个特定语言环境的字符串（例如一个逗号 \",\"）隔开。\n\n## 3.2 String to Number\njavaScript 已经有了Strign to Number的api： \n - parseInt/parseFloat\n - Number\n - 字面量1231\n这些api的使用方式和最终结果，有或多或少的不同。\n\n\n## Number to String\n\n\n##  ===\n\n## 参考文献\n\n[Symbol.toPrimitive](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive)","slug":"font-end/2019/js_type","published":1,"updated":"2021-03-08T05:31:52.903Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm05nqem00142cl26oeodalg","content":"<p>在javaScript中，经常会看到 <code>0 == false</code> =&gt; ture的情况，一个Number类型，怎么能等于一个Boolen类型呢？先从javaScript的基本类型说起</p>\n<a id=\"more\"></a>\n<h2 id=\"javasript类型\"><a href=\"#javasript类型\" class=\"headerlink\" title=\"javasript类型\"></a>javasript类型</h2><h3 id=\"类型分类\"><a href=\"#类型分类\" class=\"headerlink\" title=\"类型分类\"></a>类型分类</h3><p>传统意义上我们会说是7中基本类型，Number String Boolean undefined null Symbol Object。</p>\n<p>目前还在推进阶段的Bigint类型。除了这种分类之外，我们还可以有一个更详尽的分类方式：</p>\n<ul>\n<li>6中原始类型<ul>\n<li>Number</li>\n<li>String</li>\n<li>Boolean</li>\n<li>undefined</li>\n<li>Symbol</li>\n<li>Bigint</li>\n</ul>\n</li>\n<li>Object 引用类型<ul>\n<li>Array</li>\n<li>Object</li>\n<li>Map</li>\n<li>Set</li>\n<li>Date</li>\n<li>…</li>\n</ul>\n</li>\n<li>null</li>\n<li>Function</li>\n</ul>\n<h3 id=\"类型判断\"><a href=\"#类型判断\" class=\"headerlink\" title=\"类型判断\"></a>类型判断</h3><p>如何判断当前变量的类型呢，将JS常用的几种方式，做一个归纳：</p>\n<ul>\n<li><p>原始类型 用 <code>typeof</code></p>\n<ul>\n<li>undefined：<code>typeof instance === &quot;undefined&quot;</code></li>\n<li>Boolean：<code>typeof instance === &quot;boolean&quot;</code></li>\n<li>Number：<code>typeof instance === &quot;number&quot;</code></li>\n<li>String：<code>typeof instance === &quot;string</code></li>\n<li>BigInt：<code>typeof instance === &quot;bigint&quot;</code></li>\n<li>Symbol ：<code>typeof instance === &quot;symbol&quot;</code></li>\n</ul>\n</li>\n<li><p>引用类型 </p>\n<ul>\n<li>可以统一用 <code>Object.prototype.toString.call(ins)</code> 分别得到以下内容<ul>\n<li>Null: <code>&#39;[object Null]&#39;</code></li>\n<li>Object：<code>&#39;[object Object]&#39;</code></li>\n<li>Array：<code>&#39;[object Object]&#39;</code></li>\n<li>Set：<code>&#39;[object Set]&#39;</code></li>\n<li>Map：<code>&#39;[object Map]&#39;</code></li>\n<li>Function: <code>&#39;[object Function]&#39;</code></li>\n<li>Date: <code>&#39;[object Date]&#39;</code></li>\n<li>RegExp: <code>&#39;[object RegExp]&#39;</code></li>\n<li>…</li>\n</ul>\n</li>\n<li>也可以用用一些单个API<ul>\n<li>Object</li>\n<li>Array:<ul>\n<li><code>Array.isArray(arr)</code></li>\n<li><code>arr instanceof Array</code>‘<ul>\n<li>null</li>\n<li>Function</li>\n<li><code>typeof Function === &#39;function&#39;</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h3><table>\n<thead>\n<tr>\n<th>-</th>\n<th>Number</th>\n<th>String</th>\n<th>Boolen</th>\n<th>Undefined</th>\n<th>Null</th>\n<th>Object</th>\n<th>Symbol</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Number</td>\n<td>-</td>\n<td></td>\n<td>0=&gt;false</td>\n<td>x</td>\n<td>x</td>\n<td>Boxing</td>\n<td>x</td>\n</tr>\n<tr>\n<td>String</td>\n<td></td>\n<td>-</td>\n<td>“”=&gt;false</td>\n<td>x</td>\n<td>x</td>\n<td>Boxing</td>\n<td>x</td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>true=&gt;1 false=&gt;0</td>\n<td>true=&gt;’true’ false=&gt; ‘false’</td>\n<td>-</td>\n<td>x</td>\n<td>x</td>\n<td>Boxing</td>\n<td>x</td>\n</tr>\n<tr>\n<td>Undefined</td>\n<td>NaN</td>\n<td>‘undefined’</td>\n<td>false</td>\n<td>-</td>\n<td>x</td>\n<td></td>\n<td>x</td>\n</tr>\n<tr>\n<td>Null</td>\n<td>0</td>\n<td>‘null’</td>\n<td>false</td>\n<td>x</td>\n<td>-</td>\n<td></td>\n<td>x</td>\n</tr>\n<tr>\n<td>Object</td>\n<td>valueOf</td>\n<td>valueOf toString</td>\n<td>true</td>\n<td>x</td>\n<td>x</td>\n<td>-</td>\n<td>x</td>\n</tr>\n<tr>\n<td>Symbol</td>\n<td>x</td>\n<td>x</td>\n<td>x</td>\n<td>x</td>\n<td>x</td>\n<td>Boxing</td>\n<td>-</td>\n</tr>\n</tbody></table>\n<h4 id=\"unboxing-amp-boxing\"><a href=\"#unboxing-amp-boxing\" class=\"headerlink\" title=\"unboxing &amp; boxing\"></a>unboxing &amp; boxing</h4><p>装箱和拆箱，是在java中提到的概念，在理解这个之前，要首先明白，在JS里类和类型是两个不同的概念。 这是一些动态语言的特性，比如javaScript、python。Javascript有7种基本类型，其中，<code>Number</code>、<code>String</code>、<code>Boolen</code>、<code>Symbol</code>又拥有各自的类。这里要特别注意区分类和类型的区别,虽然，<code>new String(&#39;hello&#39;).lenth == &#39;hello&#39;.length</code> ，但是他们的<code>typeof</code>并不相同：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">'hello'</span>)    <span class=\"comment\">//object</span></span><br><span class=\"line\">typefo <span class=\"string\">'hello'</span>;              <span class=\"comment\">//string</span></span><br><span class=\"line\"></span><br><span class=\"line\">!<span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">''</span>)  <span class=\"comment\">//false</span></span><br><span class=\"line\">!<span class=\"string\">''</span>             <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>除了，new操作之外，<code>Number</code>、<code>String</code>、<code>Boolean</code>不带new操作还可以直接进行类型转换,得到的并不是object,而是转换后的类型本身</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"string\">'1'</span>)   =&gt; <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"built_in\">String</span>(<span class=\"number\">2222</span>)  =&gt; <span class=\"string\">'22222'</span> <span class=\"comment\">//这里返回的是string类型，而不是String对象</span></span><br><span class=\"line\">Boolen(<span class=\"number\">1</span>)     =&gt; <span class=\"literal\">true</span></span><br><span class=\"line\">Boolen(<span class=\"string\">'0'</span>)   =&gt; <span class=\"literal\">true</span></span><br><span class=\"line\">Boolen(<span class=\"number\">0</span>)     =&gt; <span class=\"literal\">false</span></span><br><span class=\"line\">Boolen(<span class=\"string\">''</span>)    =&gt; <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里推荐大家不要用自动的类型转换，涉及到类型转换的地方，都显式地采用手动的类型转换，对可读性比较有帮助。</p>\n</blockquote>\n<p>这里有一个比较特殊的类型<code>Symbol</code>，是new不了的。</p>\n<h5 id=\"boxing\"><a href=\"#boxing\" class=\"headerlink\" title=\"boxing\"></a>boxing</h5><p>装箱就是一个操作的统称，指的是将一个基础类型转换为其对应的Object类型，除了上面提的<code>new</code>操作之外，也可以通过<code>Object(类型变量)</code>来实现装箱。<br> <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//装箱操作1</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>(<span class=\"string\">'hello'</span>)</span><br><span class=\"line\"><span class=\"comment\">//装箱操作2 new</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">'hello'</span>)  <span class=\"comment\">//String obj</span></span><br></pre></td></tr></table></figure></p>\n<p>可以装箱操作的类型有: <code>Number</code>、<code>String</code>、<code>Boolean</code>、<code>Symbol</code>;其中<code>Symbol</code>无法采用new的方式，其他的三类两种方式均可。</p>\n<p>装箱操作一般是需要手动完成得，而在自动类型转换中，会经常遇到拆箱操作</p>\n<h5 id=\"unboxing\"><a href=\"#unboxing\" class=\"headerlink\" title=\"unboxing\"></a>unboxing</h5><p>拆箱操作是在将<code>Object</code>对象转换为其他基础类型时发生的操作。当进行拆箱操作时，将自动调用<code>[Symbol.toPrimitive]</code>，<code>ValueOf</code>，<code>toString</code>三者中的一个，调用的原则是：</p>\n<ol>\n<li>存在 <code>[Symbol.toPrimitive]</code>时，按照<code>[Symbol.toPrimitive]</code>函数进行转换</li>\n<li>没有<code>[Symbol.toPrimitive]</code>的顺序是<br> 1.<code>ValueOf()</code><br> 2.<code>toString()</code></li>\n<li>当且仅当<code>ValueOf()</code>仍然返回Object时，将调用toString函数</li>\n<li>你很少需要自己调用<code>valueOf</code>方法；当遇到要预期的原始值的对象时，JavaScript会自动调用它。<br>举例说明：<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">    [<span class=\"built_in\">Symbol</span>.toPrimitive]()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    valueOf() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    toString() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span> + obj1);      <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">    valueOf() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    toString() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span> + obj2);      <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">var</span> obj3 = &#123;</span><br><span class=\"line\">    toString() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span> + obj3);      <span class=\"comment\">// 4</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">var</span> obj4 = &#123;</span><br><span class=\"line\">    valueOf() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    toString() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>+obj4);         <span class=\"comment\">//4</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> obj5 = &#123;</span><br><span class=\"line\">    valueOf() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'222'</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    toString() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>+obj5);         <span class=\"comment\">//1222</span></span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<h5 id=\"toString-toLocaleSting的常见用法\"><a href=\"#toString-toLocaleSting的常见用法\" class=\"headerlink\" title=\"toString toLocaleSting的常见用法\"></a>toString toLocaleSting的常见用法</h5><p>在object对象中已经内置了toSting 和 toLocalString方法，但是你可以重写他们。</p>\n<ul>\n<li><p>toString()</p>\n<p>  每个对象都有一个 toString() 方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，toString() 方法被每个 Object 对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 “[object type]”，其中 type 是对象的类型。以下代码说明了这一点：</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">o.toString(); <span class=\"comment\">// returns [object Object]</span></span><br></pre></td></tr></table></figure>\n\n<p>在进制转换中也可以使用toString()的方式</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"number\">12</span>).toString(<span class=\"number\">2</span>)  <span class=\"comment\">// 1100</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"number\">12</span>).toString(进制)</span><br><span class=\"line\"><span class=\"comment\">//逆向操作</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"number\">1100</span>,<span class=\"number\">2</span>)    <span class=\"comment\">//12</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>valueOf()</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>对象</th>\n<th>返回值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Array</td>\n<td>返回数组对象本身。</td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>布尔值。</td>\n</tr>\n<tr>\n<td>Date</td>\n<td>存储的时间是从 1970 年 1 月 1 日午夜开始计的毫秒数 UTC。</td>\n</tr>\n<tr>\n<td>Function</td>\n<td>函数本身。</td>\n</tr>\n<tr>\n<td>Number</td>\n<td>数字值。</td>\n</tr>\n<tr>\n<td>Object</td>\n<td>对象本身。这是默认情况。</td>\n</tr>\n<tr>\n<td>String</td>\n<td>字符串值。</td>\n</tr>\n<tr>\n<td></td>\n<td>Math 和 Error 对象没有 valueOf 方法。</td>\n</tr>\n</tbody></table>\n<ul>\n<li>toLocaleString()<br>toLocaleString 不同于前两个API，它并没有类型转换的效果，但是有一些小技巧，在我们日常开发中十分有用。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1234567</span> .toLocaleString();  <span class=\"comment\">// \"1,234,567\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> event = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(<span class=\"built_in\">Date</span>.UTC(<span class=\"number\">2012</span>, <span class=\"number\">11</span>, <span class=\"number\">20</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">onsole.log(event.toLocaleString(<span class=\"string\">'en-GB'</span>, &#123; <span class=\"attr\">timeZone</span>: <span class=\"string\">'UTC'</span> &#125;));<span class=\"comment\">// 20/12/2012, 03:00:00</span></span><br></pre></td></tr></table></figure>\n<p>Array.prototype.toLocaleString()返回一个字符串表示数组中的元素。数组中的元素将使用各自的 toLocaleString 方法转成字符串，这些字符串将使用一个特定语言环境的字符串（例如一个逗号 “,”）隔开。</p>\n<h2 id=\"3-2-String-to-Number\"><a href=\"#3-2-String-to-Number\" class=\"headerlink\" title=\"3.2 String to Number\"></a>3.2 String to Number</h2><p>javaScript 已经有了Strign to Number的api： </p>\n<ul>\n<li>parseInt/parseFloat</li>\n<li>Number</li>\n<li>字面量1231<br>这些api的使用方式和最终结果，有或多或少的不同。</li>\n</ul>\n<h2 id=\"Number-to-String\"><a href=\"#Number-to-String\" class=\"headerlink\" title=\"Number to String\"></a>Number to String</h2><h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"===\"></a>===</h2><h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive\" target=\"_blank\" rel=\"noopener\">Symbol.toPrimitive</a></p>\n","site":{"data":{}},"excerpt":"<p>在javaScript中，经常会看到 <code>0 == false</code> =&gt; ture的情况，一个Number类型，怎么能等于一个Boolen类型呢？先从javaScript的基本类型说起</p>","more":"<h2 id=\"javasript类型\"><a href=\"#javasript类型\" class=\"headerlink\" title=\"javasript类型\"></a>javasript类型</h2><h3 id=\"类型分类\"><a href=\"#类型分类\" class=\"headerlink\" title=\"类型分类\"></a>类型分类</h3><p>传统意义上我们会说是7中基本类型，Number String Boolean undefined null Symbol Object。</p>\n<p>目前还在推进阶段的Bigint类型。除了这种分类之外，我们还可以有一个更详尽的分类方式：</p>\n<ul>\n<li>6中原始类型<ul>\n<li>Number</li>\n<li>String</li>\n<li>Boolean</li>\n<li>undefined</li>\n<li>Symbol</li>\n<li>Bigint</li>\n</ul>\n</li>\n<li>Object 引用类型<ul>\n<li>Array</li>\n<li>Object</li>\n<li>Map</li>\n<li>Set</li>\n<li>Date</li>\n<li>…</li>\n</ul>\n</li>\n<li>null</li>\n<li>Function</li>\n</ul>\n<h3 id=\"类型判断\"><a href=\"#类型判断\" class=\"headerlink\" title=\"类型判断\"></a>类型判断</h3><p>如何判断当前变量的类型呢，将JS常用的几种方式，做一个归纳：</p>\n<ul>\n<li><p>原始类型 用 <code>typeof</code></p>\n<ul>\n<li>undefined：<code>typeof instance === &quot;undefined&quot;</code></li>\n<li>Boolean：<code>typeof instance === &quot;boolean&quot;</code></li>\n<li>Number：<code>typeof instance === &quot;number&quot;</code></li>\n<li>String：<code>typeof instance === &quot;string</code></li>\n<li>BigInt：<code>typeof instance === &quot;bigint&quot;</code></li>\n<li>Symbol ：<code>typeof instance === &quot;symbol&quot;</code></li>\n</ul>\n</li>\n<li><p>引用类型 </p>\n<ul>\n<li>可以统一用 <code>Object.prototype.toString.call(ins)</code> 分别得到以下内容<ul>\n<li>Null: <code>&#39;[object Null]&#39;</code></li>\n<li>Object：<code>&#39;[object Object]&#39;</code></li>\n<li>Array：<code>&#39;[object Object]&#39;</code></li>\n<li>Set：<code>&#39;[object Set]&#39;</code></li>\n<li>Map：<code>&#39;[object Map]&#39;</code></li>\n<li>Function: <code>&#39;[object Function]&#39;</code></li>\n<li>Date: <code>&#39;[object Date]&#39;</code></li>\n<li>RegExp: <code>&#39;[object RegExp]&#39;</code></li>\n<li>…</li>\n</ul>\n</li>\n<li>也可以用用一些单个API<ul>\n<li>Object</li>\n<li>Array:<ul>\n<li><code>Array.isArray(arr)</code></li>\n<li><code>arr instanceof Array</code>‘<ul>\n<li>null</li>\n<li>Function</li>\n<li><code>typeof Function === &#39;function&#39;</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h3><table>\n<thead>\n<tr>\n<th>-</th>\n<th>Number</th>\n<th>String</th>\n<th>Boolen</th>\n<th>Undefined</th>\n<th>Null</th>\n<th>Object</th>\n<th>Symbol</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Number</td>\n<td>-</td>\n<td></td>\n<td>0=&gt;false</td>\n<td>x</td>\n<td>x</td>\n<td>Boxing</td>\n<td>x</td>\n</tr>\n<tr>\n<td>String</td>\n<td></td>\n<td>-</td>\n<td>“”=&gt;false</td>\n<td>x</td>\n<td>x</td>\n<td>Boxing</td>\n<td>x</td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>true=&gt;1 false=&gt;0</td>\n<td>true=&gt;’true’ false=&gt; ‘false’</td>\n<td>-</td>\n<td>x</td>\n<td>x</td>\n<td>Boxing</td>\n<td>x</td>\n</tr>\n<tr>\n<td>Undefined</td>\n<td>NaN</td>\n<td>‘undefined’</td>\n<td>false</td>\n<td>-</td>\n<td>x</td>\n<td></td>\n<td>x</td>\n</tr>\n<tr>\n<td>Null</td>\n<td>0</td>\n<td>‘null’</td>\n<td>false</td>\n<td>x</td>\n<td>-</td>\n<td></td>\n<td>x</td>\n</tr>\n<tr>\n<td>Object</td>\n<td>valueOf</td>\n<td>valueOf toString</td>\n<td>true</td>\n<td>x</td>\n<td>x</td>\n<td>-</td>\n<td>x</td>\n</tr>\n<tr>\n<td>Symbol</td>\n<td>x</td>\n<td>x</td>\n<td>x</td>\n<td>x</td>\n<td>x</td>\n<td>Boxing</td>\n<td>-</td>\n</tr>\n</tbody></table>\n<h4 id=\"unboxing-amp-boxing\"><a href=\"#unboxing-amp-boxing\" class=\"headerlink\" title=\"unboxing &amp; boxing\"></a>unboxing &amp; boxing</h4><p>装箱和拆箱，是在java中提到的概念，在理解这个之前，要首先明白，在JS里类和类型是两个不同的概念。 这是一些动态语言的特性，比如javaScript、python。Javascript有7种基本类型，其中，<code>Number</code>、<code>String</code>、<code>Boolen</code>、<code>Symbol</code>又拥有各自的类。这里要特别注意区分类和类型的区别,虽然，<code>new String(&#39;hello&#39;).lenth == &#39;hello&#39;.length</code> ，但是他们的<code>typeof</code>并不相同：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">'hello'</span>)    <span class=\"comment\">//object</span></span><br><span class=\"line\">typefo <span class=\"string\">'hello'</span>;              <span class=\"comment\">//string</span></span><br><span class=\"line\"></span><br><span class=\"line\">!<span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">''</span>)  <span class=\"comment\">//false</span></span><br><span class=\"line\">!<span class=\"string\">''</span>             <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>除了，new操作之外，<code>Number</code>、<code>String</code>、<code>Boolean</code>不带new操作还可以直接进行类型转换,得到的并不是object,而是转换后的类型本身</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"string\">'1'</span>)   =&gt; <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"built_in\">String</span>(<span class=\"number\">2222</span>)  =&gt; <span class=\"string\">'22222'</span> <span class=\"comment\">//这里返回的是string类型，而不是String对象</span></span><br><span class=\"line\">Boolen(<span class=\"number\">1</span>)     =&gt; <span class=\"literal\">true</span></span><br><span class=\"line\">Boolen(<span class=\"string\">'0'</span>)   =&gt; <span class=\"literal\">true</span></span><br><span class=\"line\">Boolen(<span class=\"number\">0</span>)     =&gt; <span class=\"literal\">false</span></span><br><span class=\"line\">Boolen(<span class=\"string\">''</span>)    =&gt; <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里推荐大家不要用自动的类型转换，涉及到类型转换的地方，都显式地采用手动的类型转换，对可读性比较有帮助。</p>\n</blockquote>\n<p>这里有一个比较特殊的类型<code>Symbol</code>，是new不了的。</p>\n<h5 id=\"boxing\"><a href=\"#boxing\" class=\"headerlink\" title=\"boxing\"></a>boxing</h5><p>装箱就是一个操作的统称，指的是将一个基础类型转换为其对应的Object类型，除了上面提的<code>new</code>操作之外，也可以通过<code>Object(类型变量)</code>来实现装箱。<br> <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//装箱操作1</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>(<span class=\"string\">'hello'</span>)</span><br><span class=\"line\"><span class=\"comment\">//装箱操作2 new</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">'hello'</span>)  <span class=\"comment\">//String obj</span></span><br></pre></td></tr></table></figure></p>\n<p>可以装箱操作的类型有: <code>Number</code>、<code>String</code>、<code>Boolean</code>、<code>Symbol</code>;其中<code>Symbol</code>无法采用new的方式，其他的三类两种方式均可。</p>\n<p>装箱操作一般是需要手动完成得，而在自动类型转换中，会经常遇到拆箱操作</p>\n<h5 id=\"unboxing\"><a href=\"#unboxing\" class=\"headerlink\" title=\"unboxing\"></a>unboxing</h5><p>拆箱操作是在将<code>Object</code>对象转换为其他基础类型时发生的操作。当进行拆箱操作时，将自动调用<code>[Symbol.toPrimitive]</code>，<code>ValueOf</code>，<code>toString</code>三者中的一个，调用的原则是：</p>\n<ol>\n<li>存在 <code>[Symbol.toPrimitive]</code>时，按照<code>[Symbol.toPrimitive]</code>函数进行转换</li>\n<li>没有<code>[Symbol.toPrimitive]</code>的顺序是<br> 1.<code>ValueOf()</code><br> 2.<code>toString()</code></li>\n<li>当且仅当<code>ValueOf()</code>仍然返回Object时，将调用toString函数</li>\n<li>你很少需要自己调用<code>valueOf</code>方法；当遇到要预期的原始值的对象时，JavaScript会自动调用它。<br>举例说明：<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">    [<span class=\"built_in\">Symbol</span>.toPrimitive]()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    valueOf() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    toString() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span> + obj1);      <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">    valueOf() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    toString() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span> + obj2);      <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">var</span> obj3 = &#123;</span><br><span class=\"line\">    toString() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span> + obj3);      <span class=\"comment\">// 4</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">var</span> obj4 = &#123;</span><br><span class=\"line\">    valueOf() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    toString() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>+obj4);         <span class=\"comment\">//4</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> obj5 = &#123;</span><br><span class=\"line\">    valueOf() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'222'</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    toString() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>+obj5);         <span class=\"comment\">//1222</span></span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<h5 id=\"toString-toLocaleSting的常见用法\"><a href=\"#toString-toLocaleSting的常见用法\" class=\"headerlink\" title=\"toString toLocaleSting的常见用法\"></a>toString toLocaleSting的常见用法</h5><p>在object对象中已经内置了toSting 和 toLocalString方法，但是你可以重写他们。</p>\n<ul>\n<li><p>toString()</p>\n<p>  每个对象都有一个 toString() 方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，toString() 方法被每个 Object 对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 “[object type]”，其中 type 是对象的类型。以下代码说明了这一点：</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">o.toString(); <span class=\"comment\">// returns [object Object]</span></span><br></pre></td></tr></table></figure>\n\n<p>在进制转换中也可以使用toString()的方式</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"number\">12</span>).toString(<span class=\"number\">2</span>)  <span class=\"comment\">// 1100</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"number\">12</span>).toString(进制)</span><br><span class=\"line\"><span class=\"comment\">//逆向操作</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"number\">1100</span>,<span class=\"number\">2</span>)    <span class=\"comment\">//12</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>valueOf()</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>对象</th>\n<th>返回值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Array</td>\n<td>返回数组对象本身。</td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>布尔值。</td>\n</tr>\n<tr>\n<td>Date</td>\n<td>存储的时间是从 1970 年 1 月 1 日午夜开始计的毫秒数 UTC。</td>\n</tr>\n<tr>\n<td>Function</td>\n<td>函数本身。</td>\n</tr>\n<tr>\n<td>Number</td>\n<td>数字值。</td>\n</tr>\n<tr>\n<td>Object</td>\n<td>对象本身。这是默认情况。</td>\n</tr>\n<tr>\n<td>String</td>\n<td>字符串值。</td>\n</tr>\n<tr>\n<td></td>\n<td>Math 和 Error 对象没有 valueOf 方法。</td>\n</tr>\n</tbody></table>\n<ul>\n<li>toLocaleString()<br>toLocaleString 不同于前两个API，它并没有类型转换的效果，但是有一些小技巧，在我们日常开发中十分有用。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1234567</span> .toLocaleString();  <span class=\"comment\">// \"1,234,567\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> event = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(<span class=\"built_in\">Date</span>.UTC(<span class=\"number\">2012</span>, <span class=\"number\">11</span>, <span class=\"number\">20</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">onsole.log(event.toLocaleString(<span class=\"string\">'en-GB'</span>, &#123; <span class=\"attr\">timeZone</span>: <span class=\"string\">'UTC'</span> &#125;));<span class=\"comment\">// 20/12/2012, 03:00:00</span></span><br></pre></td></tr></table></figure>\n<p>Array.prototype.toLocaleString()返回一个字符串表示数组中的元素。数组中的元素将使用各自的 toLocaleString 方法转成字符串，这些字符串将使用一个特定语言环境的字符串（例如一个逗号 “,”）隔开。</p>\n<h2 id=\"3-2-String-to-Number\"><a href=\"#3-2-String-to-Number\" class=\"headerlink\" title=\"3.2 String to Number\"></a>3.2 String to Number</h2><p>javaScript 已经有了Strign to Number的api： </p>\n<ul>\n<li>parseInt/parseFloat</li>\n<li>Number</li>\n<li>字面量1231<br>这些api的使用方式和最终结果，有或多或少的不同。</li>\n</ul>\n<h2 id=\"Number-to-String\"><a href=\"#Number-to-String\" class=\"headerlink\" title=\"Number to String\"></a>Number to String</h2><h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"===\"></a>===</h2><h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive\" target=\"_blank\" rel=\"noopener\">Symbol.toPrimitive</a></p>"},{"title":"ES6中的数据结构","date":"2019-09-21T02:00:05.000Z","_content":"\nES6之前JS中能用到的数据结构就是`Array`和`Object`。通过数组`Array`来模拟多种结构比如，\n> 通过push+pop 或者 shift + unshift来模拟栈的操作; 通过push+shift 或者 unshift + pop来模拟队列的操作。\n\nArray有很丰富的API，但是数组去重，一直是一个很常见的问题。\n\nObject是一个键值对的结构。JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。\n\n<!-- more -->\n\nES6给我们提供了Map和Set两种数据结构，让JS的数据结构能力有了更大的提升。\n\n## Set\nES6 提供了新的数据结构 `Set`。它类似于数组，但是成员的值都是唯一的，没有重复的值。\n\n`Set`本身是一个构造函数，用来生成 `Set` 数据结构。\n\n`Set`对成员值是否重复用的方式是`===`。\n   - 两个NaN是相等的\n   - 两个对象总是不相等的\n\n\n### Set的属性和方法\n\nSet的属性:\n - Set.prototype.constructor: 构造函数，默认就是Set函数\n - Set.prototype.size: 返回`Set`实例的成员总数\n \n Set的方法分为两大类，操作方法和遍历方法。\n \n - 操作方法\n     - Set.prototype.add(value):添加某个值，返回Set结构本身\n     - Set.prototype.delete(value):删除某个值，返回一个布尔值，表示删除是否成功\n     - Set.prototype.has(value): 返回一个布尔值，表示该值是否为Set成员\n     - Set.prototype.clear(): 清楚素有成员。没有返回值\n     \n- 遍历方法\n    - Set.prototype.keys():返回键名的遍历器\n    - Set.prototype.values(): 返回键值的遍历器\n    - Set.prototype.entries(): 返回键值对的遍历器\n    - Set.prototype.forEach():使用回调函数遍历每个成员 \n> 由于Set结构没有键名，只有键值（或者说键值和键名是同一个值），所以`keys()`方法和`values()`方法的行为完全一致。\n\n### WeakSet\n   WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。\n\n - 首先，WeakSet 的成员只能是对象，而不能是其他类型的值。\n\n - 其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。\n\nWeakSet内的对象，随时都可能被垃圾回收，所以WeakSet不可遍历，只有三种方法\n- Set.prototype.add(value): 添加成员\n- Set.prototype.has(value): 返回布尔值，表示某个值是否在WeakSet中\n- Set.prototype.delete(value): 清楚WeakSet实例的指定成员，\n\n## Map\n`Map`类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。\n\n### Map的属性和方法\n - Map.prototype.size\n - 操作方法\n     - Map.prototype.set(key, value)\n     - Map.prototype.get(key)\n        get方法 读取key对应的键值，如果找不到key，返回undefined。\n     - Map.prototype.has(key)\n     - Map.prototype.delete(key)\n   - Map.prototype.clear()\n - 遍历方法\n     - Map.prototype.keys(): 返回键名的遍历器。\n     - Map.prototype.values(): 返回键值的遍历器\n     - Map.prototype.entries(): 返回所有成员的遍历器\n     - Map.prototype.forEach(): 遍历Map的所有成员\n\n\n### WeakMap\nWeakMap与Map的区别有两点。\n- 首先，WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。\n- 其次，WeakMap的键名所指向的对象，不计入垃圾回收机制。\n\nWeakMap是无法遍历的，所以只有四个方法可以使用\n- Set.prototype.set(key, value);\n- Set.prototype.get(key);\n- Set.prototype.has(key);\n- Set.prototype.delete(key);\n\n\n## 实战应用\n\n### 利用Set完成数组(字符串)去重\n\n```js\n    let arr = [1,2,3,3,4,4,5,6,6];\n    let str = 'abccdd33bbaa'\n\n    arr = [...new Set(arr)];\n    str = [...new Set(str)].join('');\n```\n\n### 利用WeakMap不被引用计数\n```js\nlet myWeakmap = new WeakMap();\n\nmyWeakmap.set(\n  document.getElementById('logo'),\n  {timesClicked: 0})\n;\n\ndocument.getElementById('logo').addEventListener('click', function() {\n  let logoData = myWeakmap.get(document.getElementById('logo'));\n  logoData.timesClicked++;\n}, false);\n```\n\n### Map类型互换\n```js\n    const myMap = new Map()\n          .set(true, 7)\n          .set({foo: 3}, ['abc']);\n    //Map转数组\n    let arr = [...myMap]; //[ [ true, 7 ], [ { foo: 3 }, [ 'abc' ] ] ]\n    \n    //对象转Map\n    let obj = {\"a\":1, \"b\":2};\n    let map = new Map(Object.entries(obj));\n    \n```","source":"_posts/font-end/2019/map_set.md","raw":"---\ntitle: ES6中的数据结构\ntags: 前端 数据结构\ndate: 2019-09-21 10:00:05\ncategories: front-end\n---\n\nES6之前JS中能用到的数据结构就是`Array`和`Object`。通过数组`Array`来模拟多种结构比如，\n> 通过push+pop 或者 shift + unshift来模拟栈的操作; 通过push+shift 或者 unshift + pop来模拟队列的操作。\n\nArray有很丰富的API，但是数组去重，一直是一个很常见的问题。\n\nObject是一个键值对的结构。JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。\n\n<!-- more -->\n\nES6给我们提供了Map和Set两种数据结构，让JS的数据结构能力有了更大的提升。\n\n## Set\nES6 提供了新的数据结构 `Set`。它类似于数组，但是成员的值都是唯一的，没有重复的值。\n\n`Set`本身是一个构造函数，用来生成 `Set` 数据结构。\n\n`Set`对成员值是否重复用的方式是`===`。\n   - 两个NaN是相等的\n   - 两个对象总是不相等的\n\n\n### Set的属性和方法\n\nSet的属性:\n - Set.prototype.constructor: 构造函数，默认就是Set函数\n - Set.prototype.size: 返回`Set`实例的成员总数\n \n Set的方法分为两大类，操作方法和遍历方法。\n \n - 操作方法\n     - Set.prototype.add(value):添加某个值，返回Set结构本身\n     - Set.prototype.delete(value):删除某个值，返回一个布尔值，表示删除是否成功\n     - Set.prototype.has(value): 返回一个布尔值，表示该值是否为Set成员\n     - Set.prototype.clear(): 清楚素有成员。没有返回值\n     \n- 遍历方法\n    - Set.prototype.keys():返回键名的遍历器\n    - Set.prototype.values(): 返回键值的遍历器\n    - Set.prototype.entries(): 返回键值对的遍历器\n    - Set.prototype.forEach():使用回调函数遍历每个成员 \n> 由于Set结构没有键名，只有键值（或者说键值和键名是同一个值），所以`keys()`方法和`values()`方法的行为完全一致。\n\n### WeakSet\n   WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。\n\n - 首先，WeakSet 的成员只能是对象，而不能是其他类型的值。\n\n - 其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。\n\nWeakSet内的对象，随时都可能被垃圾回收，所以WeakSet不可遍历，只有三种方法\n- Set.prototype.add(value): 添加成员\n- Set.prototype.has(value): 返回布尔值，表示某个值是否在WeakSet中\n- Set.prototype.delete(value): 清楚WeakSet实例的指定成员，\n\n## Map\n`Map`类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。\n\n### Map的属性和方法\n - Map.prototype.size\n - 操作方法\n     - Map.prototype.set(key, value)\n     - Map.prototype.get(key)\n        get方法 读取key对应的键值，如果找不到key，返回undefined。\n     - Map.prototype.has(key)\n     - Map.prototype.delete(key)\n   - Map.prototype.clear()\n - 遍历方法\n     - Map.prototype.keys(): 返回键名的遍历器。\n     - Map.prototype.values(): 返回键值的遍历器\n     - Map.prototype.entries(): 返回所有成员的遍历器\n     - Map.prototype.forEach(): 遍历Map的所有成员\n\n\n### WeakMap\nWeakMap与Map的区别有两点。\n- 首先，WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。\n- 其次，WeakMap的键名所指向的对象，不计入垃圾回收机制。\n\nWeakMap是无法遍历的，所以只有四个方法可以使用\n- Set.prototype.set(key, value);\n- Set.prototype.get(key);\n- Set.prototype.has(key);\n- Set.prototype.delete(key);\n\n\n## 实战应用\n\n### 利用Set完成数组(字符串)去重\n\n```js\n    let arr = [1,2,3,3,4,4,5,6,6];\n    let str = 'abccdd33bbaa'\n\n    arr = [...new Set(arr)];\n    str = [...new Set(str)].join('');\n```\n\n### 利用WeakMap不被引用计数\n```js\nlet myWeakmap = new WeakMap();\n\nmyWeakmap.set(\n  document.getElementById('logo'),\n  {timesClicked: 0})\n;\n\ndocument.getElementById('logo').addEventListener('click', function() {\n  let logoData = myWeakmap.get(document.getElementById('logo'));\n  logoData.timesClicked++;\n}, false);\n```\n\n### Map类型互换\n```js\n    const myMap = new Map()\n          .set(true, 7)\n          .set({foo: 3}, ['abc']);\n    //Map转数组\n    let arr = [...myMap]; //[ [ true, 7 ], [ { foo: 3 }, [ 'abc' ] ] ]\n    \n    //对象转Map\n    let obj = {\"a\":1, \"b\":2};\n    let map = new Map(Object.entries(obj));\n    \n```","slug":"font-end/2019/map_set","published":1,"updated":"2021-03-08T03:34:06.492Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm05nqen00152cl2fq28fah0","content":"<p>ES6之前JS中能用到的数据结构就是<code>Array</code>和<code>Object</code>。通过数组<code>Array</code>来模拟多种结构比如，</p>\n<blockquote>\n<p>通过push+pop 或者 shift + unshift来模拟栈的操作; 通过push+shift 或者 unshift + pop来模拟队列的操作。</p>\n</blockquote>\n<p>Array有很丰富的API，但是数组去重，一直是一个很常见的问题。</p>\n<p>Object是一个键值对的结构。JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p>\n<a id=\"more\"></a>\n\n<p>ES6给我们提供了Map和Set两种数据结构，让JS的数据结构能力有了更大的提升。</p>\n<h2 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h2><p>ES6 提供了新的数据结构 <code>Set</code>。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>\n<p><code>Set</code>本身是一个构造函数，用来生成 <code>Set</code> 数据结构。</p>\n<p><code>Set</code>对成员值是否重复用的方式是<code>===</code>。</p>\n<ul>\n<li>两个NaN是相等的</li>\n<li>两个对象总是不相等的</li>\n</ul>\n<h3 id=\"Set的属性和方法\"><a href=\"#Set的属性和方法\" class=\"headerlink\" title=\"Set的属性和方法\"></a>Set的属性和方法</h3><p>Set的属性:</p>\n<ul>\n<li><p>Set.prototype.constructor: 构造函数，默认就是Set函数</p>\n</li>\n<li><p>Set.prototype.size: 返回<code>Set</code>实例的成员总数</p>\n<p>Set的方法分为两大类，操作方法和遍历方法。</p>\n</li>\n<li><p>操作方法</p>\n<ul>\n<li>Set.prototype.add(value):添加某个值，返回Set结构本身</li>\n<li>Set.prototype.delete(value):删除某个值，返回一个布尔值，表示删除是否成功</li>\n<li>Set.prototype.has(value): 返回一个布尔值，表示该值是否为Set成员</li>\n<li>Set.prototype.clear(): 清楚素有成员。没有返回值</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>遍历方法<ul>\n<li>Set.prototype.keys():返回键名的遍历器</li>\n<li>Set.prototype.values(): 返回键值的遍历器</li>\n<li>Set.prototype.entries(): 返回键值对的遍历器</li>\n<li>Set.prototype.forEach():使用回调函数遍历每个成员 <blockquote>\n<p>由于Set结构没有键名，只有键值（或者说键值和键名是同一个值），所以<code>keys()</code>方法和<code>values()</code>方法的行为完全一致。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"WeakSet\"><a href=\"#WeakSet\" class=\"headerlink\" title=\"WeakSet\"></a>WeakSet</h3><p>   WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p>\n<ul>\n<li><p>首先，WeakSet 的成员只能是对象，而不能是其他类型的值。</p>\n</li>\n<li><p>其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p>\n</li>\n</ul>\n<p>WeakSet内的对象，随时都可能被垃圾回收，所以WeakSet不可遍历，只有三种方法</p>\n<ul>\n<li>Set.prototype.add(value): 添加成员</li>\n<li>Set.prototype.has(value): 返回布尔值，表示某个值是否在WeakSet中</li>\n<li>Set.prototype.delete(value): 清楚WeakSet实例的指定成员，</li>\n</ul>\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><p><code>Map</code>类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p>\n<h3 id=\"Map的属性和方法\"><a href=\"#Map的属性和方法\" class=\"headerlink\" title=\"Map的属性和方法\"></a>Map的属性和方法</h3><ul>\n<li>Map.prototype.size</li>\n<li>操作方法<ul>\n<li>Map.prototype.set(key, value)</li>\n<li>Map.prototype.get(key)<br> get方法 读取key对应的键值，如果找不到key，返回undefined。</li>\n<li>Map.prototype.has(key)</li>\n<li>Map.prototype.delete(key)<ul>\n<li>Map.prototype.clear()</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>遍历方法<ul>\n<li>Map.prototype.keys(): 返回键名的遍历器。</li>\n<li>Map.prototype.values(): 返回键值的遍历器</li>\n<li>Map.prototype.entries(): 返回所有成员的遍历器</li>\n<li>Map.prototype.forEach(): 遍历Map的所有成员</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"WeakMap\"><a href=\"#WeakMap\" class=\"headerlink\" title=\"WeakMap\"></a>WeakMap</h3><p>WeakMap与Map的区别有两点。</p>\n<ul>\n<li>首先，WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。</li>\n<li>其次，WeakMap的键名所指向的对象，不计入垃圾回收机制。</li>\n</ul>\n<p>WeakMap是无法遍历的，所以只有四个方法可以使用</p>\n<ul>\n<li>Set.prototype.set(key, value);</li>\n<li>Set.prototype.get(key);</li>\n<li>Set.prototype.has(key);</li>\n<li>Set.prototype.delete(key);</li>\n</ul>\n<h2 id=\"实战应用\"><a href=\"#实战应用\" class=\"headerlink\" title=\"实战应用\"></a>实战应用</h2><h3 id=\"利用Set完成数组-字符串-去重\"><a href=\"#利用Set完成数组-字符串-去重\" class=\"headerlink\" title=\"利用Set完成数组(字符串)去重\"></a>利用Set完成数组(字符串)去重</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">'abccdd33bbaa'</span></span><br><span class=\"line\"></span><br><span class=\"line\">arr = [...new <span class=\"built_in\">Set</span>(arr)];</span><br><span class=\"line\">str = [...new <span class=\"built_in\">Set</span>(str)].join(<span class=\"string\">''</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"利用WeakMap不被引用计数\"><a href=\"#利用WeakMap不被引用计数\" class=\"headerlink\" title=\"利用WeakMap不被引用计数\"></a>利用WeakMap不被引用计数</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myWeakmap = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">myWeakmap.set(</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'logo'</span>),</span><br><span class=\"line\">  &#123;<span class=\"attr\">timesClicked</span>: <span class=\"number\">0</span>&#125;)</span><br><span class=\"line\">;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'logo'</span>).addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> logoData = myWeakmap.get(<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'logo'</span>));</span><br><span class=\"line\">  logoData.timesClicked++;</span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Map类型互换\"><a href=\"#Map类型互换\" class=\"headerlink\" title=\"Map类型互换\"></a>Map类型互换</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>()</span><br><span class=\"line\">      .set(<span class=\"literal\">true</span>, <span class=\"number\">7</span>)</span><br><span class=\"line\">      .set(&#123;<span class=\"attr\">foo</span>: <span class=\"number\">3</span>&#125;, [<span class=\"string\">'abc'</span>]);</span><br><span class=\"line\"><span class=\"comment\">//Map转数组</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [...myMap]; <span class=\"comment\">//[ [ true, 7 ], [ &#123; foo: 3 &#125;, [ 'abc' ] ] ]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//对象转Map</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;<span class=\"string\">\"a\"</span>:<span class=\"number\">1</span>, <span class=\"string\">\"b\"</span>:<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>(<span class=\"built_in\">Object</span>.entries(obj));</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>ES6之前JS中能用到的数据结构就是<code>Array</code>和<code>Object</code>。通过数组<code>Array</code>来模拟多种结构比如，</p>\n<blockquote>\n<p>通过push+pop 或者 shift + unshift来模拟栈的操作; 通过push+shift 或者 unshift + pop来模拟队列的操作。</p>\n</blockquote>\n<p>Array有很丰富的API，但是数组去重，一直是一个很常见的问题。</p>\n<p>Object是一个键值对的结构。JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p>","more":"<p>ES6给我们提供了Map和Set两种数据结构，让JS的数据结构能力有了更大的提升。</p>\n<h2 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h2><p>ES6 提供了新的数据结构 <code>Set</code>。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>\n<p><code>Set</code>本身是一个构造函数，用来生成 <code>Set</code> 数据结构。</p>\n<p><code>Set</code>对成员值是否重复用的方式是<code>===</code>。</p>\n<ul>\n<li>两个NaN是相等的</li>\n<li>两个对象总是不相等的</li>\n</ul>\n<h3 id=\"Set的属性和方法\"><a href=\"#Set的属性和方法\" class=\"headerlink\" title=\"Set的属性和方法\"></a>Set的属性和方法</h3><p>Set的属性:</p>\n<ul>\n<li><p>Set.prototype.constructor: 构造函数，默认就是Set函数</p>\n</li>\n<li><p>Set.prototype.size: 返回<code>Set</code>实例的成员总数</p>\n<p>Set的方法分为两大类，操作方法和遍历方法。</p>\n</li>\n<li><p>操作方法</p>\n<ul>\n<li>Set.prototype.add(value):添加某个值，返回Set结构本身</li>\n<li>Set.prototype.delete(value):删除某个值，返回一个布尔值，表示删除是否成功</li>\n<li>Set.prototype.has(value): 返回一个布尔值，表示该值是否为Set成员</li>\n<li>Set.prototype.clear(): 清楚素有成员。没有返回值</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>遍历方法<ul>\n<li>Set.prototype.keys():返回键名的遍历器</li>\n<li>Set.prototype.values(): 返回键值的遍历器</li>\n<li>Set.prototype.entries(): 返回键值对的遍历器</li>\n<li>Set.prototype.forEach():使用回调函数遍历每个成员 <blockquote>\n<p>由于Set结构没有键名，只有键值（或者说键值和键名是同一个值），所以<code>keys()</code>方法和<code>values()</code>方法的行为完全一致。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"WeakSet\"><a href=\"#WeakSet\" class=\"headerlink\" title=\"WeakSet\"></a>WeakSet</h3><p>   WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p>\n<ul>\n<li><p>首先，WeakSet 的成员只能是对象，而不能是其他类型的值。</p>\n</li>\n<li><p>其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p>\n</li>\n</ul>\n<p>WeakSet内的对象，随时都可能被垃圾回收，所以WeakSet不可遍历，只有三种方法</p>\n<ul>\n<li>Set.prototype.add(value): 添加成员</li>\n<li>Set.prototype.has(value): 返回布尔值，表示某个值是否在WeakSet中</li>\n<li>Set.prototype.delete(value): 清楚WeakSet实例的指定成员，</li>\n</ul>\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><p><code>Map</code>类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p>\n<h3 id=\"Map的属性和方法\"><a href=\"#Map的属性和方法\" class=\"headerlink\" title=\"Map的属性和方法\"></a>Map的属性和方法</h3><ul>\n<li>Map.prototype.size</li>\n<li>操作方法<ul>\n<li>Map.prototype.set(key, value)</li>\n<li>Map.prototype.get(key)<br> get方法 读取key对应的键值，如果找不到key，返回undefined。</li>\n<li>Map.prototype.has(key)</li>\n<li>Map.prototype.delete(key)<ul>\n<li>Map.prototype.clear()</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>遍历方法<ul>\n<li>Map.prototype.keys(): 返回键名的遍历器。</li>\n<li>Map.prototype.values(): 返回键值的遍历器</li>\n<li>Map.prototype.entries(): 返回所有成员的遍历器</li>\n<li>Map.prototype.forEach(): 遍历Map的所有成员</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"WeakMap\"><a href=\"#WeakMap\" class=\"headerlink\" title=\"WeakMap\"></a>WeakMap</h3><p>WeakMap与Map的区别有两点。</p>\n<ul>\n<li>首先，WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。</li>\n<li>其次，WeakMap的键名所指向的对象，不计入垃圾回收机制。</li>\n</ul>\n<p>WeakMap是无法遍历的，所以只有四个方法可以使用</p>\n<ul>\n<li>Set.prototype.set(key, value);</li>\n<li>Set.prototype.get(key);</li>\n<li>Set.prototype.has(key);</li>\n<li>Set.prototype.delete(key);</li>\n</ul>\n<h2 id=\"实战应用\"><a href=\"#实战应用\" class=\"headerlink\" title=\"实战应用\"></a>实战应用</h2><h3 id=\"利用Set完成数组-字符串-去重\"><a href=\"#利用Set完成数组-字符串-去重\" class=\"headerlink\" title=\"利用Set完成数组(字符串)去重\"></a>利用Set完成数组(字符串)去重</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">'abccdd33bbaa'</span></span><br><span class=\"line\"></span><br><span class=\"line\">arr = [...new <span class=\"built_in\">Set</span>(arr)];</span><br><span class=\"line\">str = [...new <span class=\"built_in\">Set</span>(str)].join(<span class=\"string\">''</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"利用WeakMap不被引用计数\"><a href=\"#利用WeakMap不被引用计数\" class=\"headerlink\" title=\"利用WeakMap不被引用计数\"></a>利用WeakMap不被引用计数</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myWeakmap = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">myWeakmap.set(</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'logo'</span>),</span><br><span class=\"line\">  &#123;<span class=\"attr\">timesClicked</span>: <span class=\"number\">0</span>&#125;)</span><br><span class=\"line\">;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'logo'</span>).addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> logoData = myWeakmap.get(<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'logo'</span>));</span><br><span class=\"line\">  logoData.timesClicked++;</span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Map类型互换\"><a href=\"#Map类型互换\" class=\"headerlink\" title=\"Map类型互换\"></a>Map类型互换</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>()</span><br><span class=\"line\">      .set(<span class=\"literal\">true</span>, <span class=\"number\">7</span>)</span><br><span class=\"line\">      .set(&#123;<span class=\"attr\">foo</span>: <span class=\"number\">3</span>&#125;, [<span class=\"string\">'abc'</span>]);</span><br><span class=\"line\"><span class=\"comment\">//Map转数组</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [...myMap]; <span class=\"comment\">//[ [ true, 7 ], [ &#123; foo: 3 &#125;, [ 'abc' ] ] ]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//对象转Map</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;<span class=\"string\">\"a\"</span>:<span class=\"number\">1</span>, <span class=\"string\">\"b\"</span>:<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>(<span class=\"built_in\">Object</span>.entries(obj));</span><br></pre></td></tr></table></figure>"},{"title":"shell 以及他的命令行环境","date":"2020-09-01T09:46:29.000Z","_content":"苹果Macos 从Catalina版本开始使用zsh作为默认的登录shell 和 交互shell。之前默认的是bash,这个转变是什么意思呢？这要从shell开始说起。\n## shell\n学习 Bash，首先需要理解 Shell 是什么。Shell 这个单词的原意是“外壳”，跟 kernel（内核）相对应，比喻内核外面的一层，即用户跟内核交互的对话界面。\n具体来说，Shell 这个词有多种含义。\n首先，Shell 是一个程序，提供一个与用户对话的环境。这个环境只有一个命令提示符，让用户从键盘输入命令，所以又称为命令行环境（commandline，简写为 CLI）。Shell 接收到用户输入的命令，将命令送入操作系统执行，并将结果返回给用户。本书中，除非特别指明，Shell 指的就是命令行环境。\n其次，Shell 是一个命令解释器，解释用户输入的命令。它支持变量、条件判断、循环操作等语法，所以用户可以用 Shell 命令写出各种小程序，又称为脚本（script）。这些脚本都通过 Shell 的解释执行，而不通过编译。\n最后，Shell 是一个工具箱，提供了各种小工具，供用户方便地使用操作系统的功能。\n<!-- more -->\n\n##  bash\nBash 是 Unix 系统和 Linux 系统的一种 Shell（命令行环境），是目前绝大多数 Linux 发行版的默认 Shell。Mac 从Catalina版本开始默认采用zsh。\nZsh??\n\nshell的种类很多，只要能给用户提供命令行环境的程序，都可以看作是Shell。常见的shell有\n* Bourne Shell（sh）\n* Bourne Again shell（bash）\n* C Shell（csh）\n* TENEX C Shell（tcsh）\n* Korn shell（ksh）\n* Z Shell（zsh）\n* Friendly Interactive Shell（fish）\n查看当前运行的Shell\n$ echo $SHELL \n\n## bash 和 zsh的不同\n- zsh性能更好\n- 配置文件不同  bash  `.bashrc`   和 zsh的`.zshrc`\n- zsh有更强的定制能力\n\n\n## .bash_profile 和 .bashrc\n通过这两个文件可以个性化定制你的shell环境。\n`.bash_profile` and `.bashrc` are files containing shell commands that are run when Bash is invoked. `.bash_profile` is read and executed on interactive login shells, while `.bashrc` on non-login shells.\n\n### Interactive Login and Non-Login Shell\n当启动bash时，bash会从一组启动文件中读取和执行命令。具体去读哪些文件取决于shell是交互式登录shell还是非登录shell。shell可以是交互式或者内交互式的。\n简而言之，交互式Shell是一个读写用户终端的Shell，就是有用户输入有屏幕输出，而非交互式Shell是一个与终端交互的Shell，例如执行脚本时。交互式Shell程序可以是登录Shell，也可以是非登录Shell。\n\n当用户通过ssh远程登录到终端或在本地登录终端时，或者使用--login选项启动Bash时，都会调用登录Shell。从登录Shell调用交互式非登录Shell，例如在Shell提示符下键入bash或打开新的Gnome终端选项卡时。\n\n### Bash启动文件\n当作为交互式登录shell调用时，Bash查找/etc/profile文件，如果该文件存在，它将运行文件中列出的命令。然后Bash按照列出的顺序搜索〜/.bash_profile，〜/.bash_login和〜/.profile文件，并从找到的第一个可读文件中执行命令。\n\n当Bash作为交互式非登录外壳程序被调用时，它从〜/.bashrc读取并执行命令（如果该文件存在并且可读）。\n \n## shell 和 bash的历史\nShell 伴随着 Unix 系统的诞生而诞生。\n1969年，Ken Thompson 和 Dennis Ritchie 开发了第一版的 Unix。\n1971年，Ken Thompson 编写了最初的 Shell，称为 Thompson shell，程序名是sh，方便用户使用 Unix。\n1973年至1975年间，John R. Mashey 扩展了最初的 Thompson shell，添加了编程功能，使得 Shell 成为一种编程语言。这个版本的 Shell 称为 Mashey shell。\n1976年，Stephen Bourne 结合 Mashey shell 的功能，重写一个新的 Shell，称为 Bourne shell。\n1978年，加州大学伯克利分校的 Bill Joy 开发了 C shell，为 Shell 提供 C 语言的语法，程序名是csh。它是第一个真正替代sh的 UNIX shell，被合并到 Berkeley UNIX 的 2BSD 版本中。\n1979年，UNIX 第七版发布，内置了 Bourne Shell，导致它成为 Unix 的默认 Shell。注意，Thompson shell、Mashey shell 和 Bourne shell 都是贝尔实验室的产品，程序名都是sh。对于用户来说，它们是同一个东西，只是底层代码不同而已。\n1983年，David Korn 开发了Korn shell，程序名是ksh。\n1985年，Richard Stallman 成立了自由软件基金会（FSF），由于 Shell 的版权属于贝尔公司，所以他决定写一个自由版权的、使用 GNU 许可证的 Shell 程序，避免 Unix 的版权争议。\n1988年，自由软件基金会的第一个付薪程序员 Brian Fox 写了一个 Shell，功能基本上是 Bourne shell 的克隆，叫做 Bourne-Again SHell，简称 Bash，程序名为bash，任何人都可以免费使用。后来，它逐渐成为 Linux 系统的标准 Shell。\n1989年，Bash 发布1.0版。\n1996年，Bash 发布2.0版。\n2004年，Bash 发布3.0版。\n2009年，Bash 发布4.0版。\n2019年，Bash 发布5.0版。\n用户可以通过bash命令的--version参数或者环境变量$BASH_VERSION，查看本机的 Bash 版本。\n\n\n## Reference\n[.bashrc vs .bash_profile](https://linuxize.com/post/bashrc-vs-bash-profile/)","source":"_posts/language/bash-zsh-shell/bash-zsh-shell.md","raw":"---\ntitle: shell 以及他的命令行环境\ndate: 2020-09-01 17:46:29\ntags: 计算机通识 \ncategories: language\n---\n苹果Macos 从Catalina版本开始使用zsh作为默认的登录shell 和 交互shell。之前默认的是bash,这个转变是什么意思呢？这要从shell开始说起。\n## shell\n学习 Bash，首先需要理解 Shell 是什么。Shell 这个单词的原意是“外壳”，跟 kernel（内核）相对应，比喻内核外面的一层，即用户跟内核交互的对话界面。\n具体来说，Shell 这个词有多种含义。\n首先，Shell 是一个程序，提供一个与用户对话的环境。这个环境只有一个命令提示符，让用户从键盘输入命令，所以又称为命令行环境（commandline，简写为 CLI）。Shell 接收到用户输入的命令，将命令送入操作系统执行，并将结果返回给用户。本书中，除非特别指明，Shell 指的就是命令行环境。\n其次，Shell 是一个命令解释器，解释用户输入的命令。它支持变量、条件判断、循环操作等语法，所以用户可以用 Shell 命令写出各种小程序，又称为脚本（script）。这些脚本都通过 Shell 的解释执行，而不通过编译。\n最后，Shell 是一个工具箱，提供了各种小工具，供用户方便地使用操作系统的功能。\n<!-- more -->\n\n##  bash\nBash 是 Unix 系统和 Linux 系统的一种 Shell（命令行环境），是目前绝大多数 Linux 发行版的默认 Shell。Mac 从Catalina版本开始默认采用zsh。\nZsh??\n\nshell的种类很多，只要能给用户提供命令行环境的程序，都可以看作是Shell。常见的shell有\n* Bourne Shell（sh）\n* Bourne Again shell（bash）\n* C Shell（csh）\n* TENEX C Shell（tcsh）\n* Korn shell（ksh）\n* Z Shell（zsh）\n* Friendly Interactive Shell（fish）\n查看当前运行的Shell\n$ echo $SHELL \n\n## bash 和 zsh的不同\n- zsh性能更好\n- 配置文件不同  bash  `.bashrc`   和 zsh的`.zshrc`\n- zsh有更强的定制能力\n\n\n## .bash_profile 和 .bashrc\n通过这两个文件可以个性化定制你的shell环境。\n`.bash_profile` and `.bashrc` are files containing shell commands that are run when Bash is invoked. `.bash_profile` is read and executed on interactive login shells, while `.bashrc` on non-login shells.\n\n### Interactive Login and Non-Login Shell\n当启动bash时，bash会从一组启动文件中读取和执行命令。具体去读哪些文件取决于shell是交互式登录shell还是非登录shell。shell可以是交互式或者内交互式的。\n简而言之，交互式Shell是一个读写用户终端的Shell，就是有用户输入有屏幕输出，而非交互式Shell是一个与终端交互的Shell，例如执行脚本时。交互式Shell程序可以是登录Shell，也可以是非登录Shell。\n\n当用户通过ssh远程登录到终端或在本地登录终端时，或者使用--login选项启动Bash时，都会调用登录Shell。从登录Shell调用交互式非登录Shell，例如在Shell提示符下键入bash或打开新的Gnome终端选项卡时。\n\n### Bash启动文件\n当作为交互式登录shell调用时，Bash查找/etc/profile文件，如果该文件存在，它将运行文件中列出的命令。然后Bash按照列出的顺序搜索〜/.bash_profile，〜/.bash_login和〜/.profile文件，并从找到的第一个可读文件中执行命令。\n\n当Bash作为交互式非登录外壳程序被调用时，它从〜/.bashrc读取并执行命令（如果该文件存在并且可读）。\n \n## shell 和 bash的历史\nShell 伴随着 Unix 系统的诞生而诞生。\n1969年，Ken Thompson 和 Dennis Ritchie 开发了第一版的 Unix。\n1971年，Ken Thompson 编写了最初的 Shell，称为 Thompson shell，程序名是sh，方便用户使用 Unix。\n1973年至1975年间，John R. Mashey 扩展了最初的 Thompson shell，添加了编程功能，使得 Shell 成为一种编程语言。这个版本的 Shell 称为 Mashey shell。\n1976年，Stephen Bourne 结合 Mashey shell 的功能，重写一个新的 Shell，称为 Bourne shell。\n1978年，加州大学伯克利分校的 Bill Joy 开发了 C shell，为 Shell 提供 C 语言的语法，程序名是csh。它是第一个真正替代sh的 UNIX shell，被合并到 Berkeley UNIX 的 2BSD 版本中。\n1979年，UNIX 第七版发布，内置了 Bourne Shell，导致它成为 Unix 的默认 Shell。注意，Thompson shell、Mashey shell 和 Bourne shell 都是贝尔实验室的产品，程序名都是sh。对于用户来说，它们是同一个东西，只是底层代码不同而已。\n1983年，David Korn 开发了Korn shell，程序名是ksh。\n1985年，Richard Stallman 成立了自由软件基金会（FSF），由于 Shell 的版权属于贝尔公司，所以他决定写一个自由版权的、使用 GNU 许可证的 Shell 程序，避免 Unix 的版权争议。\n1988年，自由软件基金会的第一个付薪程序员 Brian Fox 写了一个 Shell，功能基本上是 Bourne shell 的克隆，叫做 Bourne-Again SHell，简称 Bash，程序名为bash，任何人都可以免费使用。后来，它逐渐成为 Linux 系统的标准 Shell。\n1989年，Bash 发布1.0版。\n1996年，Bash 发布2.0版。\n2004年，Bash 发布3.0版。\n2009年，Bash 发布4.0版。\n2019年，Bash 发布5.0版。\n用户可以通过bash命令的--version参数或者环境变量$BASH_VERSION，查看本机的 Bash 版本。\n\n\n## Reference\n[.bashrc vs .bash_profile](https://linuxize.com/post/bashrc-vs-bash-profile/)","slug":"language/bash-zsh-shell/bash-zsh-shell","published":1,"updated":"2021-03-08T03:30:11.262Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm05nqeo00192cl249fpcvna","content":"<p>苹果Macos 从Catalina版本开始使用zsh作为默认的登录shell 和 交互shell。之前默认的是bash,这个转变是什么意思呢？这要从shell开始说起。</p>\n<h2 id=\"shell\"><a href=\"#shell\" class=\"headerlink\" title=\"shell\"></a>shell</h2><p>学习 Bash，首先需要理解 Shell 是什么。Shell 这个单词的原意是“外壳”，跟 kernel（内核）相对应，比喻内核外面的一层，即用户跟内核交互的对话界面。<br>具体来说，Shell 这个词有多种含义。<br>首先，Shell 是一个程序，提供一个与用户对话的环境。这个环境只有一个命令提示符，让用户从键盘输入命令，所以又称为命令行环境（commandline，简写为 CLI）。Shell 接收到用户输入的命令，将命令送入操作系统执行，并将结果返回给用户。本书中，除非特别指明，Shell 指的就是命令行环境。<br>其次，Shell 是一个命令解释器，解释用户输入的命令。它支持变量、条件判断、循环操作等语法，所以用户可以用 Shell 命令写出各种小程序，又称为脚本（script）。这些脚本都通过 Shell 的解释执行，而不通过编译。<br>最后，Shell 是一个工具箱，提供了各种小工具，供用户方便地使用操作系统的功能。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"bash\"><a href=\"#bash\" class=\"headerlink\" title=\"bash\"></a>bash</h2><p>Bash 是 Unix 系统和 Linux 系统的一种 Shell（命令行环境），是目前绝大多数 Linux 发行版的默认 Shell。Mac 从Catalina版本开始默认采用zsh。<br>Zsh??</p>\n<p>shell的种类很多，只要能给用户提供命令行环境的程序，都可以看作是Shell。常见的shell有</p>\n<ul>\n<li>Bourne Shell（sh）</li>\n<li>Bourne Again shell（bash）</li>\n<li>C Shell（csh）</li>\n<li>TENEX C Shell（tcsh）</li>\n<li>Korn shell（ksh）</li>\n<li>Z Shell（zsh）</li>\n<li>Friendly Interactive Shell（fish）<br>查看当前运行的Shell<br>$ echo $SHELL </li>\n</ul>\n<h2 id=\"bash-和-zsh的不同\"><a href=\"#bash-和-zsh的不同\" class=\"headerlink\" title=\"bash 和 zsh的不同\"></a>bash 和 zsh的不同</h2><ul>\n<li>zsh性能更好</li>\n<li>配置文件不同  bash  <code>.bashrc</code>   和 zsh的<code>.zshrc</code></li>\n<li>zsh有更强的定制能力</li>\n</ul>\n<h2 id=\"bash-profile-和-bashrc\"><a href=\"#bash-profile-和-bashrc\" class=\"headerlink\" title=\".bash_profile 和 .bashrc\"></a>.bash_profile 和 .bashrc</h2><p>通过这两个文件可以个性化定制你的shell环境。<br><code>.bash_profile</code> and <code>.bashrc</code> are files containing shell commands that are run when Bash is invoked. <code>.bash_profile</code> is read and executed on interactive login shells, while <code>.bashrc</code> on non-login shells.</p>\n<h3 id=\"Interactive-Login-and-Non-Login-Shell\"><a href=\"#Interactive-Login-and-Non-Login-Shell\" class=\"headerlink\" title=\"Interactive Login and Non-Login Shell\"></a>Interactive Login and Non-Login Shell</h3><p>当启动bash时，bash会从一组启动文件中读取和执行命令。具体去读哪些文件取决于shell是交互式登录shell还是非登录shell。shell可以是交互式或者内交互式的。<br>简而言之，交互式Shell是一个读写用户终端的Shell，就是有用户输入有屏幕输出，而非交互式Shell是一个与终端交互的Shell，例如执行脚本时。交互式Shell程序可以是登录Shell，也可以是非登录Shell。</p>\n<p>当用户通过ssh远程登录到终端或在本地登录终端时，或者使用–login选项启动Bash时，都会调用登录Shell。从登录Shell调用交互式非登录Shell，例如在Shell提示符下键入bash或打开新的Gnome终端选项卡时。</p>\n<h3 id=\"Bash启动文件\"><a href=\"#Bash启动文件\" class=\"headerlink\" title=\"Bash启动文件\"></a>Bash启动文件</h3><p>当作为交互式登录shell调用时，Bash查找/etc/profile文件，如果该文件存在，它将运行文件中列出的命令。然后Bash按照列出的顺序搜索〜/.bash_profile，〜/.bash_login和〜/.profile文件，并从找到的第一个可读文件中执行命令。</p>\n<p>当Bash作为交互式非登录外壳程序被调用时，它从〜/.bashrc读取并执行命令（如果该文件存在并且可读）。</p>\n<h2 id=\"shell-和-bash的历史\"><a href=\"#shell-和-bash的历史\" class=\"headerlink\" title=\"shell 和 bash的历史\"></a>shell 和 bash的历史</h2><p>Shell 伴随着 Unix 系统的诞生而诞生。<br>1969年，Ken Thompson 和 Dennis Ritchie 开发了第一版的 Unix。<br>1971年，Ken Thompson 编写了最初的 Shell，称为 Thompson shell，程序名是sh，方便用户使用 Unix。<br>1973年至1975年间，John R. Mashey 扩展了最初的 Thompson shell，添加了编程功能，使得 Shell 成为一种编程语言。这个版本的 Shell 称为 Mashey shell。<br>1976年，Stephen Bourne 结合 Mashey shell 的功能，重写一个新的 Shell，称为 Bourne shell。<br>1978年，加州大学伯克利分校的 Bill Joy 开发了 C shell，为 Shell 提供 C 语言的语法，程序名是csh。它是第一个真正替代sh的 UNIX shell，被合并到 Berkeley UNIX 的 2BSD 版本中。<br>1979年，UNIX 第七版发布，内置了 Bourne Shell，导致它成为 Unix 的默认 Shell。注意，Thompson shell、Mashey shell 和 Bourne shell 都是贝尔实验室的产品，程序名都是sh。对于用户来说，它们是同一个东西，只是底层代码不同而已。<br>1983年，David Korn 开发了Korn shell，程序名是ksh。<br>1985年，Richard Stallman 成立了自由软件基金会（FSF），由于 Shell 的版权属于贝尔公司，所以他决定写一个自由版权的、使用 GNU 许可证的 Shell 程序，避免 Unix 的版权争议。<br>1988年，自由软件基金会的第一个付薪程序员 Brian Fox 写了一个 Shell，功能基本上是 Bourne shell 的克隆，叫做 Bourne-Again SHell，简称 Bash，程序名为bash，任何人都可以免费使用。后来，它逐渐成为 Linux 系统的标准 Shell。<br>1989年，Bash 发布1.0版。<br>1996年，Bash 发布2.0版。<br>2004年，Bash 发布3.0版。<br>2009年，Bash 发布4.0版。<br>2019年，Bash 发布5.0版。<br>用户可以通过bash命令的–version参数或者环境变量$BASH_VERSION，查看本机的 Bash 版本。</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://linuxize.com/post/bashrc-vs-bash-profile/\" target=\"_blank\" rel=\"noopener\">.bashrc vs .bash_profile</a></p>\n","site":{"data":{}},"excerpt":"<p>苹果Macos 从Catalina版本开始使用zsh作为默认的登录shell 和 交互shell。之前默认的是bash,这个转变是什么意思呢？这要从shell开始说起。</p>\n<h2 id=\"shell\"><a href=\"#shell\" class=\"headerlink\" title=\"shell\"></a>shell</h2><p>学习 Bash，首先需要理解 Shell 是什么。Shell 这个单词的原意是“外壳”，跟 kernel（内核）相对应，比喻内核外面的一层，即用户跟内核交互的对话界面。<br>具体来说，Shell 这个词有多种含义。<br>首先，Shell 是一个程序，提供一个与用户对话的环境。这个环境只有一个命令提示符，让用户从键盘输入命令，所以又称为命令行环境（commandline，简写为 CLI）。Shell 接收到用户输入的命令，将命令送入操作系统执行，并将结果返回给用户。本书中，除非特别指明，Shell 指的就是命令行环境。<br>其次，Shell 是一个命令解释器，解释用户输入的命令。它支持变量、条件判断、循环操作等语法，所以用户可以用 Shell 命令写出各种小程序，又称为脚本（script）。这些脚本都通过 Shell 的解释执行，而不通过编译。<br>最后，Shell 是一个工具箱，提供了各种小工具，供用户方便地使用操作系统的功能。</p>","more":"<h2 id=\"bash\"><a href=\"#bash\" class=\"headerlink\" title=\"bash\"></a>bash</h2><p>Bash 是 Unix 系统和 Linux 系统的一种 Shell（命令行环境），是目前绝大多数 Linux 发行版的默认 Shell。Mac 从Catalina版本开始默认采用zsh。<br>Zsh??</p>\n<p>shell的种类很多，只要能给用户提供命令行环境的程序，都可以看作是Shell。常见的shell有</p>\n<ul>\n<li>Bourne Shell（sh）</li>\n<li>Bourne Again shell（bash）</li>\n<li>C Shell（csh）</li>\n<li>TENEX C Shell（tcsh）</li>\n<li>Korn shell（ksh）</li>\n<li>Z Shell（zsh）</li>\n<li>Friendly Interactive Shell（fish）<br>查看当前运行的Shell<br>$ echo $SHELL </li>\n</ul>\n<h2 id=\"bash-和-zsh的不同\"><a href=\"#bash-和-zsh的不同\" class=\"headerlink\" title=\"bash 和 zsh的不同\"></a>bash 和 zsh的不同</h2><ul>\n<li>zsh性能更好</li>\n<li>配置文件不同  bash  <code>.bashrc</code>   和 zsh的<code>.zshrc</code></li>\n<li>zsh有更强的定制能力</li>\n</ul>\n<h2 id=\"bash-profile-和-bashrc\"><a href=\"#bash-profile-和-bashrc\" class=\"headerlink\" title=\".bash_profile 和 .bashrc\"></a>.bash_profile 和 .bashrc</h2><p>通过这两个文件可以个性化定制你的shell环境。<br><code>.bash_profile</code> and <code>.bashrc</code> are files containing shell commands that are run when Bash is invoked. <code>.bash_profile</code> is read and executed on interactive login shells, while <code>.bashrc</code> on non-login shells.</p>\n<h3 id=\"Interactive-Login-and-Non-Login-Shell\"><a href=\"#Interactive-Login-and-Non-Login-Shell\" class=\"headerlink\" title=\"Interactive Login and Non-Login Shell\"></a>Interactive Login and Non-Login Shell</h3><p>当启动bash时，bash会从一组启动文件中读取和执行命令。具体去读哪些文件取决于shell是交互式登录shell还是非登录shell。shell可以是交互式或者内交互式的。<br>简而言之，交互式Shell是一个读写用户终端的Shell，就是有用户输入有屏幕输出，而非交互式Shell是一个与终端交互的Shell，例如执行脚本时。交互式Shell程序可以是登录Shell，也可以是非登录Shell。</p>\n<p>当用户通过ssh远程登录到终端或在本地登录终端时，或者使用–login选项启动Bash时，都会调用登录Shell。从登录Shell调用交互式非登录Shell，例如在Shell提示符下键入bash或打开新的Gnome终端选项卡时。</p>\n<h3 id=\"Bash启动文件\"><a href=\"#Bash启动文件\" class=\"headerlink\" title=\"Bash启动文件\"></a>Bash启动文件</h3><p>当作为交互式登录shell调用时，Bash查找/etc/profile文件，如果该文件存在，它将运行文件中列出的命令。然后Bash按照列出的顺序搜索〜/.bash_profile，〜/.bash_login和〜/.profile文件，并从找到的第一个可读文件中执行命令。</p>\n<p>当Bash作为交互式非登录外壳程序被调用时，它从〜/.bashrc读取并执行命令（如果该文件存在并且可读）。</p>\n<h2 id=\"shell-和-bash的历史\"><a href=\"#shell-和-bash的历史\" class=\"headerlink\" title=\"shell 和 bash的历史\"></a>shell 和 bash的历史</h2><p>Shell 伴随着 Unix 系统的诞生而诞生。<br>1969年，Ken Thompson 和 Dennis Ritchie 开发了第一版的 Unix。<br>1971年，Ken Thompson 编写了最初的 Shell，称为 Thompson shell，程序名是sh，方便用户使用 Unix。<br>1973年至1975年间，John R. Mashey 扩展了最初的 Thompson shell，添加了编程功能，使得 Shell 成为一种编程语言。这个版本的 Shell 称为 Mashey shell。<br>1976年，Stephen Bourne 结合 Mashey shell 的功能，重写一个新的 Shell，称为 Bourne shell。<br>1978年，加州大学伯克利分校的 Bill Joy 开发了 C shell，为 Shell 提供 C 语言的语法，程序名是csh。它是第一个真正替代sh的 UNIX shell，被合并到 Berkeley UNIX 的 2BSD 版本中。<br>1979年，UNIX 第七版发布，内置了 Bourne Shell，导致它成为 Unix 的默认 Shell。注意，Thompson shell、Mashey shell 和 Bourne shell 都是贝尔实验室的产品，程序名都是sh。对于用户来说，它们是同一个东西，只是底层代码不同而已。<br>1983年，David Korn 开发了Korn shell，程序名是ksh。<br>1985年，Richard Stallman 成立了自由软件基金会（FSF），由于 Shell 的版权属于贝尔公司，所以他决定写一个自由版权的、使用 GNU 许可证的 Shell 程序，避免 Unix 的版权争议。<br>1988年，自由软件基金会的第一个付薪程序员 Brian Fox 写了一个 Shell，功能基本上是 Bourne shell 的克隆，叫做 Bourne-Again SHell，简称 Bash，程序名为bash，任何人都可以免费使用。后来，它逐渐成为 Linux 系统的标准 Shell。<br>1989年，Bash 发布1.0版。<br>1996年，Bash 发布2.0版。<br>2004年，Bash 发布3.0版。<br>2009年，Bash 发布4.0版。<br>2019年，Bash 发布5.0版。<br>用户可以通过bash命令的–version参数或者环境变量$BASH_VERSION，查看本机的 Bash 版本。</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://linuxize.com/post/bashrc-vs-bash-profile/\" target=\"_blank\" rel=\"noopener\">.bashrc vs .bash_profile</a></p>"},{"title":"如何在命令行添加一条命令","date":"2020-09-02T09:31:46.000Z","_content":"在使用node的时候，经常会好奇，为什么在命令行输入了一个`npm install`这样的命令，会自动执行那么多操作? 电脑是如何识别`npm`的? 为什么可以识别`npm`却不能识别`ilovewyl`呢(其实注册了这个命令之后是可以执行的)？\n\n如果想要让命令行知道你的命令，你需要完成两步操作\n1. 通过安装将这个命令注册在bin文件夹内\n2. 确保这个bin文件夹路径在/etc/paths中（可以通过``` echo $PATH```查看当前路径）  \n<!-- more -->\n第一步其实在安装软件的时候会自动完成，但是我们需要对`bin`目录有一个更加理性的认识，这样在出现一些问题的时候，我们才不会不知道如何下手。下面就对`bin`目录做一个简单的介绍。\n\n`Bin`目录是众多`Linux`目录中的一个（文末有其他重要的目录），是存放可执行文件的目录，可分为用户可执行文件和系统可执行文件.\n\n## 1. 用户可执行文件\n包括 `/bin` 、`/usr/bin`、 `/usr/local/bin`\n`/usr/bin`下面的都是系统预装的可执行程序，会随着系统升级而改变。\n`/usr/local/bin`目录是用户放置自己的可执行程序的地方，不会被系统升级而覆盖同名文件。\n###  /bin\n`bin`为binary的简写，主要放置一些系统的必备执行档， `/bin`是系统的一些指令。比如\n- cat \n- cp\n- dd \n- launchctl\n- test\n- df\n- pwd \n- link \n- unlink\n- rm \n- echo\n- ln \n- rmdir\n- mkdir\n- mv\n- wait4path\n- chmod\n- ed\n- ls\n- expr \n- sleep\n- hostname\n- stty\n- kill\n- ps\n- sync\n- pax\n- data\n- shell相关\n    - bash\n    - sh\n    - zsh\n    - csh\n    - dash\n    - ksh\n    - tchs\n\n### /usr/bin\n是你在后期安装的一些软件的运行脚本。主要放置一些应用软体工具的必备执行档，`usr` 指 `Unix System Resource`，而不是`User`，比如列举一下我们常见的\n- git \n- sudo\n- vim\n- zip\n- ssh\n- c++\n- php\n- python\n- pip\n- ...\n\n### /usr/local/bin\n`/usr/local/bin` 用于普通用户可以运行的程序，`/usr/local`层次结构供系统管理员在本地安装软件时使用,不会被系统升级而覆盖同名文件。本地安装的软件必须放在`/usr/local`而不是`/usr`中，除非要安装它来替换或升级/usr中的软件。比如\n- node\n- npm\n- pyhton3.8 ..\n\n## 系统可执行文件\n系统可执行文件：/sbin、/usr/sbin\n\n### /sbin\n `/sbin`一般是指超级用户指令。（system binary）主要放置一些系统管理的必备程式例如\n \n - cfdisk\n - dump\n - shutdown\n - ifconfig\n - ping\n - reboot\n - md5\n - ...\n### /usr/sbin\n`/usr/sbin`   放置一些用户安装的系统管理的必备程式\n- dhcpd\n- httpd\n- imap\n- samba\n- ...\n\n## 简单归纳：\n/bin目录（binary）是二进制执行文件目录，主要用于具体应用\n/sbin目录（system binary）是系统管理员专用的二进制代码存放目录，主要用于系统管理\n\n## 其他重要的目录\n- 主目录：/root、/home/username\n- 用户可执行文件：/bin、/usr/bin、/usr/local/bin\n- 系统可执行文件：/sbin、/usr/sbin、/usr/local/sbin\n- 其他挂载点：/media、/mnt\n- 配置：/etc\n   - paths就保存在这里通过 `echo $PATH`命令可以看到path配置\n- 临时文件：/tmp\n- 内核和Bootloader：/boot\n- 服务器数据：/var、/srv\n- 系统信息：/proc、/sys\n- 共享库：/lib、/usr/lib、/usr/local/lib\n\n## Reference\n[Linux 基础知识 /bin,/sbin,/usr/sbin,/usr/bin 目录 区别详解](https://blog.51cto.com/14551658/2440488)","source":"_posts/language/how_to_add_cli/how_to_add_cli.md","raw":"---\ntitle: 如何在命令行添加一条命令\ndate: 2020-09-02 17:31:46\ntags: 计算机通识 \ncategories: language\n---\n在使用node的时候，经常会好奇，为什么在命令行输入了一个`npm install`这样的命令，会自动执行那么多操作? 电脑是如何识别`npm`的? 为什么可以识别`npm`却不能识别`ilovewyl`呢(其实注册了这个命令之后是可以执行的)？\n\n如果想要让命令行知道你的命令，你需要完成两步操作\n1. 通过安装将这个命令注册在bin文件夹内\n2. 确保这个bin文件夹路径在/etc/paths中（可以通过``` echo $PATH```查看当前路径）  \n<!-- more -->\n第一步其实在安装软件的时候会自动完成，但是我们需要对`bin`目录有一个更加理性的认识，这样在出现一些问题的时候，我们才不会不知道如何下手。下面就对`bin`目录做一个简单的介绍。\n\n`Bin`目录是众多`Linux`目录中的一个（文末有其他重要的目录），是存放可执行文件的目录，可分为用户可执行文件和系统可执行文件.\n\n## 1. 用户可执行文件\n包括 `/bin` 、`/usr/bin`、 `/usr/local/bin`\n`/usr/bin`下面的都是系统预装的可执行程序，会随着系统升级而改变。\n`/usr/local/bin`目录是用户放置自己的可执行程序的地方，不会被系统升级而覆盖同名文件。\n###  /bin\n`bin`为binary的简写，主要放置一些系统的必备执行档， `/bin`是系统的一些指令。比如\n- cat \n- cp\n- dd \n- launchctl\n- test\n- df\n- pwd \n- link \n- unlink\n- rm \n- echo\n- ln \n- rmdir\n- mkdir\n- mv\n- wait4path\n- chmod\n- ed\n- ls\n- expr \n- sleep\n- hostname\n- stty\n- kill\n- ps\n- sync\n- pax\n- data\n- shell相关\n    - bash\n    - sh\n    - zsh\n    - csh\n    - dash\n    - ksh\n    - tchs\n\n### /usr/bin\n是你在后期安装的一些软件的运行脚本。主要放置一些应用软体工具的必备执行档，`usr` 指 `Unix System Resource`，而不是`User`，比如列举一下我们常见的\n- git \n- sudo\n- vim\n- zip\n- ssh\n- c++\n- php\n- python\n- pip\n- ...\n\n### /usr/local/bin\n`/usr/local/bin` 用于普通用户可以运行的程序，`/usr/local`层次结构供系统管理员在本地安装软件时使用,不会被系统升级而覆盖同名文件。本地安装的软件必须放在`/usr/local`而不是`/usr`中，除非要安装它来替换或升级/usr中的软件。比如\n- node\n- npm\n- pyhton3.8 ..\n\n## 系统可执行文件\n系统可执行文件：/sbin、/usr/sbin\n\n### /sbin\n `/sbin`一般是指超级用户指令。（system binary）主要放置一些系统管理的必备程式例如\n \n - cfdisk\n - dump\n - shutdown\n - ifconfig\n - ping\n - reboot\n - md5\n - ...\n### /usr/sbin\n`/usr/sbin`   放置一些用户安装的系统管理的必备程式\n- dhcpd\n- httpd\n- imap\n- samba\n- ...\n\n## 简单归纳：\n/bin目录（binary）是二进制执行文件目录，主要用于具体应用\n/sbin目录（system binary）是系统管理员专用的二进制代码存放目录，主要用于系统管理\n\n## 其他重要的目录\n- 主目录：/root、/home/username\n- 用户可执行文件：/bin、/usr/bin、/usr/local/bin\n- 系统可执行文件：/sbin、/usr/sbin、/usr/local/sbin\n- 其他挂载点：/media、/mnt\n- 配置：/etc\n   - paths就保存在这里通过 `echo $PATH`命令可以看到path配置\n- 临时文件：/tmp\n- 内核和Bootloader：/boot\n- 服务器数据：/var、/srv\n- 系统信息：/proc、/sys\n- 共享库：/lib、/usr/lib、/usr/local/lib\n\n## Reference\n[Linux 基础知识 /bin,/sbin,/usr/sbin,/usr/bin 目录 区别详解](https://blog.51cto.com/14551658/2440488)","slug":"language/how_to_add_cli/how_to_add_cli","published":1,"updated":"2021-03-08T03:28:47.906Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm05nqeq001a2cl2for3as7f","content":"<p>在使用node的时候，经常会好奇，为什么在命令行输入了一个<code>npm install</code>这样的命令，会自动执行那么多操作? 电脑是如何识别<code>npm</code>的? 为什么可以识别<code>npm</code>却不能识别<code>ilovewyl</code>呢(其实注册了这个命令之后是可以执行的)？</p>\n<p>如果想要让命令行知道你的命令，你需要完成两步操作</p>\n<ol>\n<li>通过安装将这个命令注册在bin文件夹内</li>\n<li>确保这个bin文件夹路径在/etc/paths中（可以通过<code>echo $PATH</code>查看当前路径）  <a id=\"more\"></a>\n第一步其实在安装软件的时候会自动完成，但是我们需要对<code>bin</code>目录有一个更加理性的认识，这样在出现一些问题的时候，我们才不会不知道如何下手。下面就对<code>bin</code>目录做一个简单的介绍。</li>\n</ol>\n<p><code>Bin</code>目录是众多<code>Linux</code>目录中的一个（文末有其他重要的目录），是存放可执行文件的目录，可分为用户可执行文件和系统可执行文件.</p>\n<h2 id=\"1-用户可执行文件\"><a href=\"#1-用户可执行文件\" class=\"headerlink\" title=\"1. 用户可执行文件\"></a>1. 用户可执行文件</h2><p>包括 <code>/bin</code> 、<code>/usr/bin</code>、 <code>/usr/local/bin</code><br><code>/usr/bin</code>下面的都是系统预装的可执行程序，会随着系统升级而改变。<br><code>/usr/local/bin</code>目录是用户放置自己的可执行程序的地方，不会被系统升级而覆盖同名文件。</p>\n<h3 id=\"bin\"><a href=\"#bin\" class=\"headerlink\" title=\"/bin\"></a>/bin</h3><p><code>bin</code>为binary的简写，主要放置一些系统的必备执行档， <code>/bin</code>是系统的一些指令。比如</p>\n<ul>\n<li>cat </li>\n<li>cp</li>\n<li>dd </li>\n<li>launchctl</li>\n<li>test</li>\n<li>df</li>\n<li>pwd </li>\n<li>link </li>\n<li>unlink</li>\n<li>rm </li>\n<li>echo</li>\n<li>ln </li>\n<li>rmdir</li>\n<li>mkdir</li>\n<li>mv</li>\n<li>wait4path</li>\n<li>chmod</li>\n<li>ed</li>\n<li>ls</li>\n<li>expr </li>\n<li>sleep</li>\n<li>hostname</li>\n<li>stty</li>\n<li>kill</li>\n<li>ps</li>\n<li>sync</li>\n<li>pax</li>\n<li>data</li>\n<li>shell相关<ul>\n<li>bash</li>\n<li>sh</li>\n<li>zsh</li>\n<li>csh</li>\n<li>dash</li>\n<li>ksh</li>\n<li>tchs</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"usr-bin\"><a href=\"#usr-bin\" class=\"headerlink\" title=\"/usr/bin\"></a>/usr/bin</h3><p>是你在后期安装的一些软件的运行脚本。主要放置一些应用软体工具的必备执行档，<code>usr</code> 指 <code>Unix System Resource</code>，而不是<code>User</code>，比如列举一下我们常见的</p>\n<ul>\n<li>git </li>\n<li>sudo</li>\n<li>vim</li>\n<li>zip</li>\n<li>ssh</li>\n<li>c++</li>\n<li>php</li>\n<li>python</li>\n<li>pip</li>\n<li>…</li>\n</ul>\n<h3 id=\"usr-local-bin\"><a href=\"#usr-local-bin\" class=\"headerlink\" title=\"/usr/local/bin\"></a>/usr/local/bin</h3><p><code>/usr/local/bin</code> 用于普通用户可以运行的程序，<code>/usr/local</code>层次结构供系统管理员在本地安装软件时使用,不会被系统升级而覆盖同名文件。本地安装的软件必须放在<code>/usr/local</code>而不是<code>/usr</code>中，除非要安装它来替换或升级/usr中的软件。比如</p>\n<ul>\n<li>node</li>\n<li>npm</li>\n<li>pyhton3.8 ..</li>\n</ul>\n<h2 id=\"系统可执行文件\"><a href=\"#系统可执行文件\" class=\"headerlink\" title=\"系统可执行文件\"></a>系统可执行文件</h2><p>系统可执行文件：/sbin、/usr/sbin</p>\n<h3 id=\"sbin\"><a href=\"#sbin\" class=\"headerlink\" title=\"/sbin\"></a>/sbin</h3><p> <code>/sbin</code>一般是指超级用户指令。（system binary）主要放置一些系统管理的必备程式例如</p>\n<ul>\n<li>cfdisk</li>\n<li>dump</li>\n<li>shutdown</li>\n<li>ifconfig</li>\n<li>ping</li>\n<li>reboot</li>\n<li>md5</li>\n<li>…<h3 id=\"usr-sbin\"><a href=\"#usr-sbin\" class=\"headerlink\" title=\"/usr/sbin\"></a>/usr/sbin</h3><code>/usr/sbin</code>   放置一些用户安装的系统管理的必备程式<ul>\n<li>dhcpd</li>\n<li>httpd</li>\n<li>imap</li>\n<li>samba</li>\n<li>…</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"简单归纳：\"><a href=\"#简单归纳：\" class=\"headerlink\" title=\"简单归纳：\"></a>简单归纳：</h2><p>/bin目录（binary）是二进制执行文件目录，主要用于具体应用<br>/sbin目录（system binary）是系统管理员专用的二进制代码存放目录，主要用于系统管理</p>\n<h2 id=\"其他重要的目录\"><a href=\"#其他重要的目录\" class=\"headerlink\" title=\"其他重要的目录\"></a>其他重要的目录</h2><ul>\n<li>主目录：/root、/home/username</li>\n<li>用户可执行文件：/bin、/usr/bin、/usr/local/bin</li>\n<li>系统可执行文件：/sbin、/usr/sbin、/usr/local/sbin</li>\n<li>其他挂载点：/media、/mnt</li>\n<li>配置：/etc<ul>\n<li>paths就保存在这里通过 <code>echo $PATH</code>命令可以看到path配置</li>\n</ul>\n</li>\n<li>临时文件：/tmp</li>\n<li>内核和Bootloader：/boot</li>\n<li>服务器数据：/var、/srv</li>\n<li>系统信息：/proc、/sys</li>\n<li>共享库：/lib、/usr/lib、/usr/local/lib</li>\n</ul>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://blog.51cto.com/14551658/2440488\" target=\"_blank\" rel=\"noopener\">Linux 基础知识 /bin,/sbin,/usr/sbin,/usr/bin 目录 区别详解</a></p>\n","site":{"data":{}},"excerpt":"<p>在使用node的时候，经常会好奇，为什么在命令行输入了一个<code>npm install</code>这样的命令，会自动执行那么多操作? 电脑是如何识别<code>npm</code>的? 为什么可以识别<code>npm</code>却不能识别<code>ilovewyl</code>呢(其实注册了这个命令之后是可以执行的)？</p>\n<p>如果想要让命令行知道你的命令，你需要完成两步操作</p>\n<ol>\n<li>通过安装将这个命令注册在bin文件夹内</li>\n<li>确保这个bin文件夹路径在/etc/paths中（可以通过<code>echo $PATH</code>查看当前路径）","more":"第一步其实在安装软件的时候会自动完成，但是我们需要对<code>bin</code>目录有一个更加理性的认识，这样在出现一些问题的时候，我们才不会不知道如何下手。下面就对<code>bin</code>目录做一个简单的介绍。</li>\n</ol>\n<p><code>Bin</code>目录是众多<code>Linux</code>目录中的一个（文末有其他重要的目录），是存放可执行文件的目录，可分为用户可执行文件和系统可执行文件.</p>\n<h2 id=\"1-用户可执行文件\"><a href=\"#1-用户可执行文件\" class=\"headerlink\" title=\"1. 用户可执行文件\"></a>1. 用户可执行文件</h2><p>包括 <code>/bin</code> 、<code>/usr/bin</code>、 <code>/usr/local/bin</code><br><code>/usr/bin</code>下面的都是系统预装的可执行程序，会随着系统升级而改变。<br><code>/usr/local/bin</code>目录是用户放置自己的可执行程序的地方，不会被系统升级而覆盖同名文件。</p>\n<h3 id=\"bin\"><a href=\"#bin\" class=\"headerlink\" title=\"/bin\"></a>/bin</h3><p><code>bin</code>为binary的简写，主要放置一些系统的必备执行档， <code>/bin</code>是系统的一些指令。比如</p>\n<ul>\n<li>cat </li>\n<li>cp</li>\n<li>dd </li>\n<li>launchctl</li>\n<li>test</li>\n<li>df</li>\n<li>pwd </li>\n<li>link </li>\n<li>unlink</li>\n<li>rm </li>\n<li>echo</li>\n<li>ln </li>\n<li>rmdir</li>\n<li>mkdir</li>\n<li>mv</li>\n<li>wait4path</li>\n<li>chmod</li>\n<li>ed</li>\n<li>ls</li>\n<li>expr </li>\n<li>sleep</li>\n<li>hostname</li>\n<li>stty</li>\n<li>kill</li>\n<li>ps</li>\n<li>sync</li>\n<li>pax</li>\n<li>data</li>\n<li>shell相关<ul>\n<li>bash</li>\n<li>sh</li>\n<li>zsh</li>\n<li>csh</li>\n<li>dash</li>\n<li>ksh</li>\n<li>tchs</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"usr-bin\"><a href=\"#usr-bin\" class=\"headerlink\" title=\"/usr/bin\"></a>/usr/bin</h3><p>是你在后期安装的一些软件的运行脚本。主要放置一些应用软体工具的必备执行档，<code>usr</code> 指 <code>Unix System Resource</code>，而不是<code>User</code>，比如列举一下我们常见的</p>\n<ul>\n<li>git </li>\n<li>sudo</li>\n<li>vim</li>\n<li>zip</li>\n<li>ssh</li>\n<li>c++</li>\n<li>php</li>\n<li>python</li>\n<li>pip</li>\n<li>…</li>\n</ul>\n<h3 id=\"usr-local-bin\"><a href=\"#usr-local-bin\" class=\"headerlink\" title=\"/usr/local/bin\"></a>/usr/local/bin</h3><p><code>/usr/local/bin</code> 用于普通用户可以运行的程序，<code>/usr/local</code>层次结构供系统管理员在本地安装软件时使用,不会被系统升级而覆盖同名文件。本地安装的软件必须放在<code>/usr/local</code>而不是<code>/usr</code>中，除非要安装它来替换或升级/usr中的软件。比如</p>\n<ul>\n<li>node</li>\n<li>npm</li>\n<li>pyhton3.8 ..</li>\n</ul>\n<h2 id=\"系统可执行文件\"><a href=\"#系统可执行文件\" class=\"headerlink\" title=\"系统可执行文件\"></a>系统可执行文件</h2><p>系统可执行文件：/sbin、/usr/sbin</p>\n<h3 id=\"sbin\"><a href=\"#sbin\" class=\"headerlink\" title=\"/sbin\"></a>/sbin</h3><p> <code>/sbin</code>一般是指超级用户指令。（system binary）主要放置一些系统管理的必备程式例如</p>\n<ul>\n<li>cfdisk</li>\n<li>dump</li>\n<li>shutdown</li>\n<li>ifconfig</li>\n<li>ping</li>\n<li>reboot</li>\n<li>md5</li>\n<li>…<h3 id=\"usr-sbin\"><a href=\"#usr-sbin\" class=\"headerlink\" title=\"/usr/sbin\"></a>/usr/sbin</h3><code>/usr/sbin</code>   放置一些用户安装的系统管理的必备程式<ul>\n<li>dhcpd</li>\n<li>httpd</li>\n<li>imap</li>\n<li>samba</li>\n<li>…</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"简单归纳：\"><a href=\"#简单归纳：\" class=\"headerlink\" title=\"简单归纳：\"></a>简单归纳：</h2><p>/bin目录（binary）是二进制执行文件目录，主要用于具体应用<br>/sbin目录（system binary）是系统管理员专用的二进制代码存放目录，主要用于系统管理</p>\n<h2 id=\"其他重要的目录\"><a href=\"#其他重要的目录\" class=\"headerlink\" title=\"其他重要的目录\"></a>其他重要的目录</h2><ul>\n<li>主目录：/root、/home/username</li>\n<li>用户可执行文件：/bin、/usr/bin、/usr/local/bin</li>\n<li>系统可执行文件：/sbin、/usr/sbin、/usr/local/sbin</li>\n<li>其他挂载点：/media、/mnt</li>\n<li>配置：/etc<ul>\n<li>paths就保存在这里通过 <code>echo $PATH</code>命令可以看到path配置</li>\n</ul>\n</li>\n<li>临时文件：/tmp</li>\n<li>内核和Bootloader：/boot</li>\n<li>服务器数据：/var、/srv</li>\n<li>系统信息：/proc、/sys</li>\n<li>共享库：/lib、/usr/lib、/usr/local/lib</li>\n</ul>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://blog.51cto.com/14551658/2440488\" target=\"_blank\" rel=\"noopener\">Linux 基础知识 /bin,/sbin,/usr/sbin,/usr/bin 目录 区别详解</a></p>"}],"PostAsset":[{"_id":"source/_posts/daily/2020-04-16-bit/deal.jpeg","slug":"deal.jpeg","post":"ckm05nqdr00072cl2gcey3yjd","modified":1,"renderable":0},{"_id":"source/_posts/daily/2020-04-16-bit/bbjy.png","post":"ckm05nqdr00072cl2gcey3yjd","slug":"bbjy.png","modified":1,"renderable":1},{"_id":"source/_posts/language/program_language/machine_language.png","slug":"machine_language.png","post":"ckm05nqdw000c2cl2bcu76h1c","modified":1,"renderable":0},{"_id":"source/_posts/language/program_language/translate.png","slug":"translate.png","post":"ckm05nqdw000c2cl2bcu76h1c","modified":1,"renderable":0},{"_id":"source/_posts/daily/paper/paper-search/fudan_data.png","slug":"fudan_data.png","post":"ckm05nqee000z2cl27rzb5m9y","modified":1,"renderable":0}],"PostCategory":[{"post_id":"ckm05nqd500002cl255lffyd9","category_id":"ckm05nqde00032cl2f29w98a7","_id":"ckm05nqdi00062cl2d5ieh7ky"},{"post_id":"ckm05nqdy000d2cl2d2rq1n1l","category_id":"ckm05nqdv000b2cl24ewnb4xb","_id":"ckm05nqe1000h2cl27dxp4i2e"},{"post_id":"ckm05nqdt00082cl295f456p7","category_id":"ckm05nqdv000b2cl24ewnb4xb","_id":"ckm05nqe2000j2cl24w8mf2kl"},{"post_id":"ckm05nqdu000a2cl29iya8idk","category_id":"ckm05nqdz000f2cl231bo4x3p","_id":"ckm05nqe2000l2cl2cok720fb"},{"post_id":"ckm05nqdw000c2cl2bcu76h1c","category_id":"ckm05nqdv000b2cl24ewnb4xb","_id":"ckm05nqe3000p2cl2e7oihk1l"},{"post_id":"ckm05nqef00102cl2b0v0fvyb","category_id":"ckm05nqde00032cl2f29w98a7","_id":"ckm05nqen00162cl28p7ifzu3"},{"post_id":"ckm05nqem00142cl26oeodalg","category_id":"ckm05nqde00032cl2f29w98a7","_id":"ckm05nqeq001b2cl259fogukc"},{"post_id":"ckm05nqee000z2cl27rzb5m9y","category_id":"ckm05nqeg00112cl2haix65do","_id":"ckm05nqeu001e2cl24avx5blj"},{"post_id":"ckm05nqen00152cl2fq28fah0","category_id":"ckm05nqde00032cl2f29w98a7","_id":"ckm05nqeu001g2cl2ha1ne6ht"},{"post_id":"ckm05nqeo00192cl249fpcvna","category_id":"ckm05nqdv000b2cl24ewnb4xb","_id":"ckm05nqev001j2cl2dw1bdro0"},{"post_id":"ckm05nqeg00132cl2h1ws5t0n","category_id":"ckm05nqeg00112cl2haix65do","_id":"ckm05nqev001l2cl2edky04bl"},{"post_id":"ckm05nqeq001a2cl2for3as7f","category_id":"ckm05nqdv000b2cl24ewnb4xb","_id":"ckm05nqev001n2cl26j1v51bo"}],"PostTag":[{"post_id":"ckm05nqd500002cl255lffyd9","tag_id":"ckm05nqdf00042cl2apph7gua","_id":"ckm05nqdh00052cl2e17vg7fs"},{"post_id":"ckm05nqdr00072cl2gcey3yjd","tag_id":"ckm05nqdu00092cl29l3k65pv","_id":"ckm05nqe3000m2cl220ll4q9v"},{"post_id":"ckm05nqdr00072cl2gcey3yjd","tag_id":"ckm05nqdz000e2cl2egfn66zx","_id":"ckm05nqe3000n2cl24mzg4nbg"},{"post_id":"ckm05nqdr00072cl2gcey3yjd","tag_id":"ckm05nqe0000g2cl2heea6sqw","_id":"ckm05nqe3000q2cl22zn32zjo"},{"post_id":"ckm05nqdt00082cl295f456p7","tag_id":"ckm05nqe2000k2cl23ejqcjw9","_id":"ckm05nqe3000r2cl2foow2cnw"},{"post_id":"ckm05nqdu000a2cl29iya8idk","tag_id":"ckm05nqe3000o2cl2fycqfjhw","_id":"ckm05nqe5000u2cl21b0q5mu9"},{"post_id":"ckm05nqdu000a2cl29iya8idk","tag_id":"ckm05nqe3000s2cl23eloaxef","_id":"ckm05nqe5000v2cl2609w04n3"},{"post_id":"ckm05nqdw000c2cl2bcu76h1c","tag_id":"ckm05nqe2000k2cl23ejqcjw9","_id":"ckm05nqe6000x2cl2gd2ffasd"},{"post_id":"ckm05nqdy000d2cl2d2rq1n1l","tag_id":"ckm05nqe2000k2cl23ejqcjw9","_id":"ckm05nqe6000y2cl2a6ksas0h"},{"post_id":"ckm05nqeo00192cl249fpcvna","tag_id":"ckm05nqe2000k2cl23ejqcjw9","_id":"ckm05nqeu001d2cl219jj5qcz"},{"post_id":"ckm05nqee000z2cl27rzb5m9y","tag_id":"ckm05nqeg00122cl2h91l7i5v","_id":"ckm05nqeu001f2cl22ddmcr6t"},{"post_id":"ckm05nqee000z2cl27rzb5m9y","tag_id":"ckm05nqeo00182cl2fdamffp5","_id":"ckm05nqev001i2cl2bkp70uk7"},{"post_id":"ckm05nqeq001a2cl2for3as7f","tag_id":"ckm05nqe2000k2cl23ejqcjw9","_id":"ckm05nqev001k2cl2awhkdz04"},{"post_id":"ckm05nqef00102cl2b0v0fvyb","tag_id":"ckm05nqeq001c2cl283z5b3ws","_id":"ckm05nqew001o2cl23fklc8iw"},{"post_id":"ckm05nqef00102cl2b0v0fvyb","tag_id":"ckm05nqev001h2cl23mvs110j","_id":"ckm05nqew001p2cl2ffxpedwl"},{"post_id":"ckm05nqeg00132cl2h1ws5t0n","tag_id":"ckm05nqeg00122cl2h91l7i5v","_id":"ckm05nqex001s2cl2fn1099vo"},{"post_id":"ckm05nqeg00132cl2h1ws5t0n","tag_id":"ckm05nqew001q2cl2glt66p7t","_id":"ckm05nqex001t2cl28r886bhi"},{"post_id":"ckm05nqem00142cl26oeodalg","tag_id":"ckm05nqeq001c2cl283z5b3ws","_id":"ckm05nqex001v2cl2ewebbmaq"},{"post_id":"ckm05nqen00152cl2fq28fah0","tag_id":"ckm05nqex001u2cl2g60ced9l","_id":"ckm05nqey001w2cl2hfx52zwm"}],"Tag":[{"name":"hexo","_id":"ckm05nqdf00042cl2apph7gua"},{"name":"理财","_id":"ckm05nqdu00092cl29l3k65pv"},{"name":"比特币","_id":"ckm05nqdz000e2cl2egfn66zx"},{"name":"火币","_id":"ckm05nqe0000g2cl2heea6sqw"},{"name":"计算机通识","_id":"ckm05nqe2000k2cl23ejqcjw9"},{"name":"服务器配置","_id":"ckm05nqe3000o2cl2fycqfjhw"},{"name":"nginx","_id":"ckm05nqe3000s2cl23eloaxef"},{"name":"paper","_id":"ckm05nqeg00122cl2h91l7i5v"},{"name":"前端智能化","_id":"ckm05nqeo00182cl2fdamffp5"},{"name":"前端","_id":"ckm05nqeq001c2cl283z5b3ws"},{"name":"布局","_id":"ckm05nqev001h2cl23mvs110j"},{"name":"效率","_id":"ckm05nqew001q2cl2glt66p7t"},{"name":"前端 数据结构","_id":"ckm05nqex001u2cl2g60ced9l"}]}}